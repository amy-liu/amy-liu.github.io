<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[云端笔记]]></title>
  <link href="http://amy-liu.github.io/atom.xml" rel="self"/>
  <link href="http://amy-liu.github.io/"/>
  <updated>2015-10-20T22:53:45+08:00</updated>
  <id>http://amy-liu.github.io/</id>
  <author>
    <name><![CDATA[amy-liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 对象和数组]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu/"/>
    <updated>2015-10-20T22:19:20+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu</id>
    <content type="html"><![CDATA[<p>test</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 函数]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/18/javascrhan-shu/"/>
    <updated>2015-10-18T21:15:57+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/18/javascrhan-shu</id>
    <content type="html"><![CDATA[<h3>一、函数声明</h3>

<p>函数对任何语言来说都是一个核心的概念 。通过函数可以封装任意多条语句 ,而且可以 在任何地方、任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明,后跟 一组参数以及函数体。</p>

<pre><code>function box() {                              //没有参数的函数 
    alert('只有函数被调用,我才会被之执行 ');
} box();                                      //直接调用函数

function box(name, age) {                     //带参数的函数
    alert('你的姓名:'+name+',年龄:'+age);
}
box('李',28);                                 //调用函数,并传参
</code></pre>

<h2>二、return 返回值</h2>

<p>带参和不带参的函数 ,都没有定义返回值 ,而是调用后直接执行的 。实际上,任何函数 都可以通过 return 语句跟后面的要返回的值来实现返回值。</p>

<!--more-->


<pre><code>function box() {                     //没有参数的函数
    return '我被返回了!';             //通过 return 把函数的最终值返回
} 
alert(box());                       //调用函数会得到返回值 ,然后外面输出


function box(name, age) {                      //有参数的函数
    return '你的姓名:'+name+',年龄:'+age;        //通过 return 把函数的最终值返回
}
alert(box('李炎恢', 28));                       /调用函数得到返回值,然后外面输出
</code></pre>

<p>我们还可以把函数的返回值赋给一个变量,然后通过变量进行操作。</p>

<pre><code>function box(num1, num2) { 
    return num1 * num2;
}
var num = box(10, 5); //函数得到的返回值赋给变量 
alert(num);
</code></pre>

<p><code>return</code> 语句还有一个功能就是退出当前函数 ,注意和 <code>break</code> 的区别。PS: <code>break</code> 用在循环 和 <code>switch</code> 分支语句里。</p>

<pre><code>function box(num) {
    if (num &lt; 5) return num;            //满足条件,就返回 num
    return 100;                         //返回之后,就不执行下面的语句了
} alert(box(10));
</code></pre>

<h2>三、arguments 对象</h2>

<p>ECMAScript 函数不介意传递进来多少参数,也不会因为参数不统一而错误。实际上, 函数体内可以通过 arguments 对象来接收传递进来的参数。</p>

<pre><code>function box() {
    return arguments[0]+' | '+arguments[1];           //得到每次参数的值
}
alert(box(1,2,3,4,5,6));                              //传递参数
</code></pre>

<p>arguments 对象的 length 属性可以得到参数的数量。</p>

<pre><code>function box() {
    return arguments.length;            //得到 6
    }
alert(box(1,2,3,4,5,6));
</code></pre>

<p>我们可以利用 <code>length</code> 这个属性,来智能的判断有多少参数 ,然后把参数进行合理的应用 。 比如,要实现一个加法运算,将所有传进来的数字累加,而数字的个数又不确定。</p>

<pre><code>function box() { 
var sum = 0;
    if (arguments.length == 0) return sum;                //如果没有参数,退出
    for(var i = 0;i &lt; arguments.length; i++) {            //如果有,就累加
    sum = sum + arguments[i]; 
    }
return sum;                                               //返回累加结果
}
alert(box(5,9,12));
</code></pre>

<p>ECMAScript 中的函数,没有像其他高级语言那种函数重载功能。</p>

<pre><code>function box(num) {
    return num + 100; 
}

function box (num) {              //会执行这个函数
    return num + 200;             //返回结果
} 
alert(box(50));
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 流程控制语句]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/18/javascript-zhi-liu-cheng-kong-zhi-yu-ju/"/>
    <updated>2015-10-18T20:41:18+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/18/javascript-zhi-liu-cheng-kong-zhi-yu-ju</id>
    <content type="html"><![CDATA[<h3>一、语句的定义</h3>

<p>语句的种类</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>声明语句   变量声明语句   var box = 100;
</span><span class='line'>          标签声明语句   label : box;
</span><span class='line'>
</span><span class='line'>达式语句   变量赋值语句    box = 100;
</span><span class='line'>          函数调用语句    box();
</span><span class='line'>          属性赋值语句    box.property = 100;
</span><span class='line'>          方法调用语句    box.method();
</span><span class='line'>
</span><span class='line'>分支语句   条件分支语句    if () {} else {}
</span><span class='line'>          多重分支语句    switch () { case n : ...};</span></code></pre></td></tr></table></div></figure>


<p>语句的种类 (续)</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>循环语句       for            for (;;;) {}
</span><span class='line'>              for ... in     for ( x in x) {}
</span><span class='line'>              while          while () {};
</span><span class='line'>              do ... while   do {} while ();
</span><span class='line'>
</span><span class='line'>控制结构       继续执行子句     continue ;
</span><span class='line'>              终断执行子句     break ;
</span><span class='line'>              函数返回子句     return ;
</span><span class='line'>              异常触发子句     throw ;
</span><span class='line'>              异常捕获与处理    try {} catch () {} finally {}
</span><span class='line'>
</span><span class='line'>其他           空语句          ;
</span><span class='line'>               with 语句      with () {}</span></code></pre></td></tr></table></div></figure>


<h3>二、if 语句</h3>

<p>略</p>

<h2>三、switch 语句</h2>

<p>switch 语句是多重条件判断,用于多个值相等的比较。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = 1;
</span><span class='line'>switch (box) {                        //用于判断 box 相等的多个值
</span><span class='line'>  case 1 : 
</span><span class='line'>      alert('one');
</span><span class='line'>      break;                        //break;用于防止语句的穿透
</span><span class='line'>  case 2 :
</span><span class='line'>      alert('two');
</span><span class='line'>      break; 
</span><span class='line'>  case 3 :
</span><span class='line'>      alert('three'); 
</span><span class='line'>      break;
</span><span class='line'>      default :                    //相当于 if 语句里的 else,否则的意思 
</span><span class='line'>      alert('error');
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>四、do&hellip;while 语句</h2>

<p>do&hellip;while 语句是一种先运行,后判断的循环语句。也就是说,不管条件是否满足,至少先运行一次循环体。</p>

<pre><code>var box = 1;       //如果是 1,执行五次,如果是 10,执行 1 次     
do {
    alert(box);
    box++;
} while (box &lt;= 5);   //先运行一次,再判断
</code></pre>

<h2>五、while 语句</h2>

<p>while 语句是一种先判断,后运行的循环语句。也就是说,必须满足条件了之后,方可运行循环体。</p>

<pre><code>var box = 1;        //如果是 1,执行五次,如果是 10,不执行 
while (box &lt;= 5) {  //先判断,再执行
    alert(box);
    box++; 
}
</code></pre>

<h2>六、for 语句</h2>

<p>for 语句也是一种先判断,后运行的循环语句。但它具有在执行循环之前初始变量和定义循环后要执行代码的能力。</p>

<pre><code>for (var box = 1; box &lt;= 5 ; box++) {     //第一步,声明变量 var box = 1;
    alert(box);                           //第二步,判断 box &lt;=5
}                                         //第三步,alert(box)
                                          //第四步,box++ //第五步,从第二步再来,直到判断为 false
</code></pre>

<h2>七、 for&hellip;in 语句</h2>

<p>for&hellip;in 语句是一种精准的迭代语句,可以用来枚举对象的属性。</p>

<pre><code>var box = {                         //创建一个对象 
    'name' : '李炎恢',               //键值对,左边是属性名,右边是值
    'age' : 28,
    'height' : 178 };
for (var p in box) {                //列举出对象的所有属性
    alert(p);
</code></pre>

<h2>八、break 和 continue 语句</h2>

<p>break 和 continue 语句用于在循环中精确地控制代码的执行 。其中,break 语句会立即退出循环,强制继续执行循环体后面的语句 。而 continue 语句退出当前循环,继续后面的循环。</p>

<pre><code>for (var box = 1; box &lt;= 10; box++) {
    if (box == 5) break;                //如果 box 是 5,就退出循环
    document.write(box); 
    document.write('&lt;br /&gt;');
}
</code></pre>

<p>continue</p>

<pre><code>for (var box = 1; box &lt;= 10; box++) { 
    if (box == 5) continue;      //如果 box 是 5,就退出当前循环
    document.write(box); 
    document.write('&lt;br /&gt;');
}
</code></pre>

<h2>九、with 语句</h2>

<p>with 语句的作用是将代码的作用域设置到一个特定的对象中。</p>

<pre><code>var box = {                  //创建一个对象 
    'name' : '李炎恢',        //键值对
    'age' : 28,
    'height' : 178 
};
var n = box.name;            //从对象里取值赋给变量
var a = box.age; 
var h = box.height;
</code></pre>

<p>可以将上面的三段赋值操作改写成:</p>

<pre><code>with (box) {                 //省略了 box 对象名   
    var n = name;           
    var a = age;            
    var h = height;         
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 运算符]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-yun-suan-fu/"/>
    <updated>2015-10-17T23:31:08+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-yun-suan-fu</id>
    <content type="html"><![CDATA[<h3>一、什么是表达式</h3>

<p>表达式是 ECMAScript 中的一个“短语”,解释器会通过计算把它转换成一个值。最简 单的表达式是字面量或者变量名。例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5.96                           //数值字面量
</span><span class='line'>'Lee'                          //字符串字面量
</span><span class='line'>true                           //布尔值字面量 
</span><span class='line'>null                           //空值字面量
</span><span class='line'>/Java/                         //正则表达式字面量
</span><span class='line'>{x:1, y:2}                     //对象字面量、对象表达式
</span><span class='line'>[1,2,3]                        //数组字面量、数组表达式
</span><span class='line'>function(n) {return x+y;}      //函数字面量、函数表达式
</span><span class='line'>box                            //变量</span></code></pre></td></tr></table></div></figure>


<p>    <br/>
当然,还可以通过合并简单的表达式来创建复杂的表达式。比如:</p>

<pre><code>box + 5.96      //加法运算的表达式
typeof(box)     //查看数据类型的表达式
box &gt; 8         //逻辑运算表达式
</code></pre>

<p>通过上面的叙述,我们得知,单一的字面量和组合字面量的运算符都可称为表达式。</p>

<h2>二、一元运算符</h2>

<p>只能操作一个值的运算符叫做一元运算符。</p>

<p>1.递增++和递减- -</p>

<pre><code>var box = 100;
++box; //把 box 累加一个 1,相当于 box = box+1 
--box; //把 box 累减一个 1,相当于 box = box-1
box++; //同上
box--; //同上
</code></pre>

<!--more-->


<p>2.前置和后置的区别</p>

<p>在没有赋值操作 ,前置和后置是一样的 。但在赋值操作时 ,如果递增或递减运算符前置 , 那么前置的运算符会先累加或累减再赋值,如果是后置运算符则先赋值再累加或累减。</p>

<pre><code>var box = 100;
var age = ++box;     //age 值为 101 
var height = box++;  //height 值为 100
</code></pre>

<p>3.其他类型应用一元运算符的规则</p>

<pre><code>var box = '89'; box++;                 //90,数值字符串自动转换成数值              
var box = 'ab'; box++;                 //NaN,字符串包含非数值转成 NaN
var box = false; box++;                //1,false 转成数值是 0,累加就是 1
var box = 2.3; box++;                  //3.3,直接加 1
var box = {                            //1,不设置 toString 或 valueOf 即为 NaN
    toString : function() { 
    return 1;
}
box++;
}
</code></pre>

<p>4.加和减运算符</p>

<p>加运算规则如下:(其实就是取正)</p>

<pre><code>var box = 100; +box;              //100,对于数值,不会产生任何影响 
var box = '89'; +box;             //89,数值字符串转换成数值
var box = 'ab'; +box;             //NaN,字符串包含非数值转成 NaN 
var box = false; +box;            //0,布尔值转换成相应数值 
var box = 2.3; +box;              //2.3,没有变化
var box = {                       //1,不设置 toString 或 valueOf 即为 NaN
    toString : function() { 
    return 1;
};
};
+box;
</code></pre>

<p>减运算规则如下:(其实就是取负)</p>

<pre><code>var box = 100; －box;              //－100,对于数值,不会产生任何影响 
var box = '89'; －box;             //－89,数值字符串转换成数值
var box = 'ab'; －box;             //NaN,字符串包含非数值转成 NaN 
var box = false; －box;            //0,布尔值转换成相应数值 
var box = 2.3; －box;              //－2.3,没有变化
var box = {                       //－1,不设置 toString 或 valueOf 即为 NaN
    toString : function() { 
    return 1;
};
};
－box;
</code></pre>

<p>加法和减法运算符一般用于算术运算,也可向上面进行类型转换。</p>

<h2>三、算术运算符</h2>

<p>ECMAScript 定义了 5 个算术运算符,加减乘除求模 (取余)。如果在算术运算的值不是 数值,那么后台会先使用 Number()转型函数将其转换为数值(隐式转换)。</p>

<pre><code>var box = 1 + 2;                              //等于 3
var box = 1 + NaN;                            //NaN,只要有一个 NaN 就为 NaN
var box = Infinity + -Infinity;               //NaN,正无穷和负无穷相加等 NaN
var box = 100 + '100';                        //100100,字符串连接符,有字符串就不是加法
var box = '您的年龄是:' + 10 + 20;             //您的年龄是:1020,被转换成字符串
var box = 10 + 20 + '是您的年龄';              //30 是您的年龄,没有被转成字符串
var box = '您的年龄是:' + (10 + 20);           //您的年龄是:30,没有被转成字符串
varbox=10+ 对象                //10[object Object],如果有 toString()或 valueOf() 则返回 10+返回数的值

var box = 100 - true;             //99,true 转成数值为 1 
var box = 100 - '';               //100,''转成了 0
var box = 100 - null;             //100,null 转成了 0
var box = 100 - 'Lee';            //NaN,Lee 转成了 NaN
varbox=100- 对象                   //NaN,如果有 toString()或 valueOf()则返回 10-返回数的值

...
</code></pre>

<h2>四、关系运算符</h2>

<p>用于进行比较的运算符称作为关系运算符:小于 (&lt;)、大于(>)、小于等于(&lt;=)、大于等于(>=)、相等(==)、不等(!=)、全等(恒等)(===)、不全等(不恒等)(!==)</p>

<p>和其他运算符一样,当关系运算符操作非数值时要遵循一下规则:</p>

<p>1.两个操作数都是数值,则数值比较;<br/>
2.两个操作数都是字符串,则比较两个字符串对应的字符编码值; <br/>
3.两个操作数有一个是数值,则将另一个转换为数值,再进行数值比较; <br/>
4.两个操作数有一个是对象,则先调用 valueOf()方法或 toString()方法,再用结果比较;</p>

<pre><code>var box = 3 &gt; 2;          //true
var box = 3 &gt; 22;         //false
var box = '3' &gt; 22;       //false
var box = '3' &gt; '22';     //true
var box = 'a' &gt; 'b';      //false
var box = 'a' &gt; 'B';      //true B=66
var box = 1 &gt; 对象;        //false,如果有 toString()或 valueOf()则返回 1 &gt; 返回数的值
</code></pre>

<p>在相等和不等的比较上,如果操作数是非数值,则遵循一下规则:</p>

<p>1.一个操作数是布尔值,则比较之前将其转换为数值, <code>false</code> 转成 <code>0</code> , <code>true</code> 转成 <code>1</code> ; <br/>
2.一个操作数是字符串,则比较之前将其转成为数值再比较; <br/>
3.一个操作数是对象,则先调用 <code>valueOf()</code> 或 <code>toString()</code> 方法后再和返回值比较; <br/>
4.不需要任何转换的情况下, <code>null</code> 和 <code>undefined</code> 是相等的;<br/>
5.一个操作数是 NaN,则==返回 false,!=返回 true;并且 NaN 和自身不等;<br/>
6.两个操作数都是对象 ,则比较他们是否是同一个对象 ,如果都指向同一个对象 ,则返 回 <code>true</code> ,否则返回 <code>false</code> 。<br/>
7.在全等和全不等的判断上,比如值和类型都相等,才返回 <code>true</code> ,否则返回 <code>false</code>。</p>

<h2>五、逻辑运算符</h2>

<p>逻辑运算符通常用于布尔值的操作,一般和关系运算符配合使用,有三个逻辑运算符 :
逻辑与 &amp;&amp; (AND)、逻辑或 || (OR)、逻辑非 ! (NOT)。</p>

<p>1.逻辑与(AND) :&amp;&amp;</p>

<pre><code>var box = (5 &gt; 4) &amp;&amp; (4 &gt; 3) //true,两边都为 true,返回 
</code></pre>

<p>如果两边的操作数有一个操作数不是布尔值的情况下,与运算就不一定返回布尔值 ,此 时,遵循已下规则:</p>

<p>1.第一个操作数是对象,则返回第二个操作数; <br/>
2.第二个操作数是对象,则第一个操作数返回 true,才返回第二个操作数,否则返回 false; <br/>
3.有一个操作数是 null,则返回 null;<br/>
4.有一个操作数是 undefined,则返回 undefined。</p>

<pre><code>var box = 对象 &amp;&amp; (5 &gt; 4);      //true,返回第二个操作数
var box = (5 &gt; 4) &amp;&amp; 对象;      //[object Object]
var box = (3 &gt; 4) &amp;&amp; 对象;      //false
var box = (5 &gt; 4) &amp;&amp; null;     //null
</code></pre>

<p>逻辑与运算符属于短路操作,顾名思义,如果第一个操作数返回是 false,第二个数不 管是 true 还是 false 都返回的 false。</p>

<pre><code>var box = true &amp;&amp; age;            //出错,age 未定义 
var box = false &amp;&amp; age;           //false,不执行 age 了
</code></pre>

<p>2.逻辑或(OR):||</p>

<p>如果两边的操作数有一个操作数不是布尔值的情况下,逻辑与运算就不一定返回布尔 值,此时,遵循已下规则:</p>

<p>1.第一个操作数是对象,则返回第一个操作数;<br/>
2.第一个操作数的求值结果为 false,则返回第二个操作数;<br/>
3.两个操作数都是对象,则返回第一个操作数; <br/>
4.两个操作数都是 null,则返回 null;<br/>
5.两个操作数都是 NaN,则返回 NaN; <br/>
6.两个操作数都是 undefined,则返回 undefined;</p>

<pre><code>var box = 对象 || (5 &gt; 3);          //[object Object]
varbox=(5&gt;3)|| 对象;                //true
var box = 对象 1 || 对象 2;          //[object Object]1
var box = null || null;             //null
var box = NaN || NaN;               //NaN
var box = undefined || undefined;   //undefined
</code></pre>

<p>3.逻辑非(NOT):!</p>

<p>逻辑非运算符可以用于任何值 。无论这个值是什么数据类型 ,这个运算符都会返回一个 布尔值。它的流程是:先将这个值转换成布尔值,然后取反,规则如下:</p>

<p>1.操作数是一个对象,返回 false;  <br/>
2.操作数是一个空字符串,返回 true; <br/>
3.操作数是一个非空字符串,返回 false; <br/>
4.操作数是数值 0,返回 true; <br/>
5.操作数是任意非 0 数值(包括 Infinity),false; <br/>
6.操作数是 null,返回 true;
7.操作数是 NaN,返回 true; <br/>
8.操作数是 <code>undefined</code>,返回 <code>true</code>;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = !(5 &gt; 4);       //false
</span><span class='line'>var box = !{};            //false
</span><span class='line'>var box = !'';            //true
</span><span class='line'>var box = !'Lee';         //false
</span><span class='line'>var box = !0;             //true
</span><span class='line'>var box = !8;             //false
</span><span class='line'>var box = !null;          //true      
</span><span class='line'>var box = !NaN;           //true
</span><span class='line'>var box = !undefined;     //true</span></code></pre></td></tr></table></div></figure>


<p>三元条件运算符</p>

<p>三元条件运算符其实就是后面将要学到的 if 语句的简写形式。</p>

<pre><code>var box = 5 &gt; 4 ? '对' : '错';       //对,5&gt;4 返回 true 则把'对'赋值给 box,反之。
</code></pre>

<p>相当于:</p>

<pre><code>var box = ''; 
if (5 &gt; 4) {
    box = '对'; 
} else {
    box = '错';
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 数据类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-shu-ju-lei-xing/"/>
    <updated>2015-10-17T23:23:46+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-shu-ju-lei-xing</id>
    <content type="html"><![CDATA[<p>ECMAScript 中有 5 种简单数据类型:<code>Undefined、Null、Boolean、Number 和 String。</code> 还有一种复杂数据类型——<code>Object</code>。ECMAScript 不支持任何创建自定义类型的机制,所有 值都成为以上 6 中数据类型之一。</p>

<h3>一、typeof 操作符</h3>

<p><code>typeof</code> 操作符是用来检测变量的数据类型 。对于值或变量使用 <code>typeof</code> 操作符会返回如下字符串。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>undefined  未定义
</span><span class='line'>boolean    布尔值
</span><span class='line'>string     字符串
</span><span class='line'>number     数值
</span><span class='line'>object     对象或 null
</span><span class='line'>function   函数</span></code></pre></td></tr></table></div></figure>


<p>typeof 操作符可以操作变量,也可以操作字面量。虽然也可以这样使用: typeof(box), 但,typeof 是操作符而非内置函数。PS:函数在 ECMAScript 中是对象,不是一种数据类型。 所以,使用 typeof 来区分 function 和 object 是非常有必要的。</p>

<pre><code>alert(typeof box);
</code></pre>

<!--more-->


<h2>二、Undefined 类型</h2>

<p><code>Undefined</code> 类型只有一个值,即特殊的 undefined。在使用 var 声明变量,但没有对其初 始化时,这个变量的值就是 <code>undefined</code> 。</p>

<pre><code>var box; 
alert(box);
</code></pre>

<p>PS:我们没有必要显式的给一个变量赋值为 <code>undefined</code> ,因为没有赋值的变量会隐式的 (自动的)赋值为 <code>undefined</code> ;而 <code>undefined</code> 主要的目的是为了用于比较 ,ECMAScript 第 3 版之 前并没有引入这个值,引入之后为了正式区分空对象与未经初始化的变量。</p>

<p>未初始化的变量与根本不存在的变量 (未声明的变量)也是不一样的。</p>

<pre><code>var box;
alert(age); //age is not defined
</code></pre>

<p>PS : 如果 <code>typeof box,typeof age</code> 都返回的 undefined。从逻辑上思考,他们的值,一个 是 undefined,一个报错;他们的类型,却都是 undefined。所以,我们在定义变量的时候, 尽可能的不要只声明,不赋值。</p>

<h2>三、Null 类型</h2>

<p>Null 类型是一个只有一个值的数据类型,即特殊的值 null。它表示一个空对象引用(指 针),而 typeof 操作符检测 null 会返回 object。</p>

<pre><code>var box = null; 
alert(typeof box);
</code></pre>

<p>如果定义的变量准备在将来用于保存对象,那么最好将该变量初始化为 null。这样,当 检查 null 值就知道是否已经变量是否已经分配了对象引用了。</p>

<pre><code>var box = null; 
if (box != null) {
    alert('box 对象已存在!'); 
}
</code></pre>

<p>有个要说明的是:undefined 是派生自 null 的,因此 ECMA-262 规定对它们的相等性测 试返回 true。</p>

<p>alert(undefined == null);</p>

<p>由于 <code>undefined</code> 和 <code>null</code> 两个值的比较是相等的,所以,未初始化的变量和赋值为 null 的 变量会相等。这时,可以采用 typeof 变量的类型进行比较。但,建议还是养成编码的规范, 不要忘记初始化变量。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box;
</span><span class='line'>var car = null;
</span><span class='line'>alert(typeof box == typeof car)</span></code></pre></td></tr></table></div></figure>


<h2>四、Boolean</h2>

<p>Boolean 类型有两个值(字面量):<code>true</code> 和 <code>false</code>。而 <code>true</code> 不一定等于 1,<code>false</code> 不一定等于 0。 JavaScript 是区分大小写的,True 和 False 或者其他都不是 Boolean 类型的值。</p>

<pre><code>var box = true; 
alert(typeof box);
</code></pre>

<p>虽然 Boolean 类型的字面量只有 true 和 false 两种,但 ECMAScript 中所有类型的值都有 与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值,可以使用转型函数 <code>Boolean()</code>。</p>

<pre><code>var hello = 'Hello World!'; 
var hello2 = Boolean(hello); 
alert(typeof hello);
</code></pre>

<p>上面是一种显示转换 ,属于强制性转换 。而实际应用中 ,还有一种隐式转换 。比如,在 if 条件语句里面的条件判断,就存在隐式转换。</p>

<pre><code>var hello = 'Hello World!';
if (hello) {
    alert('如果条件为 true,就执行我这条!'); 
    } else {
    alert('如果条件为 false,就执行我这条!'); 
    }
</code></pre>

<p>以下是其他类型转换成 Boolean 类型规则</p>

<pre><code>数据类型      转换为 true 的值             转换为 false 的值
Boolean     true                         false
String      任何非空字符串                 空字符串
Number      任何非零数字值 (包括无穷大 )     0 和 NaN
Object      任何对象                       null
Undefined                                 undefined
</code></pre>

<h2>五、Number 类型</h2>

<p>Number 类型包含两种数值:整型和浮点型。为了支持各种数值类型, ECMA-262 定义了不同的数值字面量格式。
最基本的数值字面量是十进制整数。</p>

<pre><code>var box = 100; //十进制整数
</code></pre>

<h2>六、String 类型</h2>

<p>String 类型用于表示由于零或多个 16 位 Unicode 字符组成的字符序列,即字符串。字 符串可以由双引号(&ldquo;)或单引号(&lsquo;)表示。</p>

<pre><code>var box = 'Lee'; 
var box = "Lee";
</code></pre>

<p>PS:在某些其他语言(PHP)中,单引号和双引号表示的字符串解析方式不同, 而 ECMAScript 中,这两种表示方法没有任何区别。但要记住的是,必须成对出现,不能穿插 使用,否则会出错。</p>

<p>String 类型包含了一些特殊的字符字面量,也叫转义序列。</p>

<pre><code>\n  换行
\t  制表
\b  空格
\r  回车
\f  进纸
\\  斜杠
\'  单引号
\"  双引号
\xnn    以十六进制代码 nn 表示的一个字符(0~F)。例:\x41
\unnn   以十六进制代码 nnn 表示的一个 Unicode 字符(0~F)。例:\u03a3
</code></pre>

<p>字符串一旦创建,它们的值就不能改 变。要改变某个变量保存的字符串 ,首先要销毁原来的字符串 ,然后再用另一个包含新值的 字符串填充该变量。</p>

<pre><code>var box = 'Mr.'; 
box = box + ' Lee';
</code></pre>

<p><code>toString()</code>方法可以把值转换成字符串。</p>

<pre><code>var box = 11;
var box = true;
alert(typeof box.toString());
</code></pre>

<p><code>toString()</code>方法一般是不需要传参的,但在数值转成字符串的时候,可以传递进制参数 。</p>

<pre><code>var box = 10;
alert(box.toString());   //10,默认输出 
alert(box.toString(2));   //1010,二进制输出
alert(box.toString(8));    //12,八进制输出
alert(box.toString(10));   //10,十进制输出
alert(box.toString(16));   //a,十六进制输出
</code></pre>

<p>如果在转型之前不知道变量是否是 null 或者 undefined 的情况下,我们还可以使用转型 函数 <code>String()</code> ,这个函数能够将任何类型的值转换为字符串。</p>

<p>var box = null;
alert(String(box));</p>

<p>PS:如果值有 <code>toString()</code> 方法,则调用该方法并返回相应的结果;如果是 null 或者 undefined,则返回"null"或者"undeinfed"。</p>

<h2>七、Object 类型</h2>

<p>ECMAScript 中的对象其实就是一组数据和功能的集合 。对象可以通过执行 new 操作符 后跟要创建的对象类型的名称来创建。</p>

<pre><code>var box = new Object();
</code></pre>

<p><code>Object()</code>是对象构造,如果对象初始化时不需要传递参数,可以不用写括号,但这种方 式我们是不推荐的。</p>

<pre><code>var box = new Object;
</code></pre>

<p>Object()里可以任意传参,可以传数值、字符串、布尔值等。而且,还可以进行相应的 计算。</p>

<pre><code>var box = new Object(2);             //Object 类型,值是 2
var age = box + 2;                  //可以和普通变量运算 
alert(age);                        //输出结果,转型成 Number 类型了
</code></pre>

<p>既然可以使用 new Object()来表示一个对象,那么我们也可以使用这种 new 操作符来创 建其他类型的对象。</p>

<pre><code>var box = new Number(5); //new String('Lee')、new Boolean(true) 
alert(typeof box); //Object 类型
</code></pre>

<p>PS:面向对象是 JavaScript 课程的重点,这里我们只是简单做个介绍 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 Ajax]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/15/jquery-ajax/"/>
    <updated>2015-10-15T21:41:51+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/15/jquery-ajax</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 动画效果]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/15/jquery-zhi-dong-hua-xiao-guo/"/>
    <updated>2015-10-15T21:40:46+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/15/jquery-zhi-dong-hua-xiao-guo</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 高级事件]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-gao-ji-jian/"/>
    <updated>2015-10-14T22:34:16+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-gao-ji-jian</id>
    <content type="html"><![CDATA[<h3>一、模拟操作</h3>

<p>在事件触发的时候,有时我们需要一些模拟用户行为的操作。例如:当网页加载完毕后 自行点击一个按钮触发一个事件,而不是用户去点击。</p>

<p>点击按钮事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function () {
</span><span class='line'>  alert('我的第一次点击来自模拟!'); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>模拟用户点击行为</p>

<pre><code>$('input').trigger('click');
</code></pre>

<!--more-->


<p>可以合并两个方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function () {
</span><span class='line'>  alert('我的第一次点击来自模拟!'); 
</span><span class='line'>}).trigger('click');</span></code></pre></td></tr></table></div></figure>


<p>有时在模拟用户行为的时候,我们需要给事件执行传递参数,这个参数类似与 <code>event.data</code> 的额外数据,可以可以是数字、字符串、数组、对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e, data1, data2) { 
</span><span class='line'>  alert(data1 + ',' + data2);
</span><span class='line'>}).trigger('click', ['abc', '123']);</span></code></pre></td></tr></table></div></figure>


<p>jQuery 还提供了另外一个模拟用户行为的方法 : <code>.triggerHandler();</code>这个方法的使用 和 <code>.trigger()</code> 方法一样。</p>

<pre><code>$('input').click(function () { 
    alert('我的第一次点击来自模拟!');
}).triggerHandler('click');
</code></pre>

<p>1 <code>.triggerHandler()</code> 方法并不会触发事件的默认行为,而 <code>.trigger()</code> 会。</p>

<pre><code>$('form').trigger('submit');         //模拟用户执行提交,并跳转到执行页面 
$('form').triggerHandler('submit');  //模拟用户执行提交,并阻止的默认行为
</code></pre>

<p>如果我们希望使用 <code>.trigger()</code> 来模拟用户提交,并且阻止事件的默认行为,则需要这么写:</p>

<pre><code>$('form').submit(function (e) {
    e.preventDefault(); //阻止默认行为 
}).trigger('submit');
</code></pre>

<p>2 <code>.triggerHandler()</code> 方法只会影响第一个匹配到的元素,而 <code>.trigger()</code> 会影响所有。</p>

<p>3 <code>.triggerHandler()</code> 方法会返回当前事件执行的返回值,如果没有返回值,则返回 <code>undefined;</code> 而 <code>.trigger()</code> 则返回当前包含事件触发元素的 jQuery 对象(方便链式连缀调用)。</p>

<pre><code>alert($('input').click(function () { 
    return 123;
}).triggerHandler('click')); //返回 123,没有 return 返回
</code></pre>

<p>4 <code>.trigger()</code> 在创建事件的时候,会冒泡。但这种冒泡是自定义事件才能体现出来,是 jQuery 扩展于 DOM 的机制,并非 DOM 特性。而 <code>.triggerHandler()</code>不会冒泡。</p>

<pre><code>var index = 1; 
$('div').bind('myEvent',function(){
    alert('自定义事件' + index);
    index++; });
$('.div3').trigger("myEvent");
</code></pre>

<h2>二、命名空间</h2>

<p>有时,我们想对事件进行移除。但对于同名同元素绑定的事件移除往往比较麻烦,这个 时候,可以使用事件的命名空间解决。</p>

<pre><code>$('input').bind('click.abc', function () { 
    alert('abc');
});
$('input').bind('click.xyz', function () { 
    alert('xyz');
});
$('input').unbind('click.abc');    //移除 click 实践中命名空间为 abc 的
</code></pre>

<p>注意 : 也可以直接使用(&lsquo;.abc&rsquo;),这样的话,可以移除相同命名空间的不同事件。对于模拟操作 <code>.trigger()</code> 和 <code>.triggerHandler(),</code>用法也是一样的。</p>

<pre><code>$('input').trigger('click.abc');
</code></pre>

<h2>三、事件委托</h2>

<p>使用 <code>.bind()</code> 不具备动态绑定功能,只有点击原始按钮才能生成</p>

<pre><code>$('.button').bind('click', function () {
    $(this).clone().appendTo('#box'); 
});
</code></pre>

<p>使用 <code>.live()</code> 具备动态绑定功能,jQuery1.3 使用,jQuery1.7 之后废弃,jQuery1.9 删除</p>

<pre><code>$('.button').live('click', function () {
    $(this).clone().appendTo('#box'); 
});
</code></pre>

<p><code>.live()</code> 原理就是把 <code>click</code> 事件绑定到祖先元素 <code>$(document)</code> 上,而只需要给 <code>$(document)</code> 绑 定一次即可。
然后就可以处理后续动态加载的按钮的单击事件。在接受任何 事件时, <code>$(document)</code> 对象都会检查事件类型 <code>(event.type)</code> 和事件目标 <code>(event.target),</code> 如果 click 事件是 <code>.button,</code> 那么就执行委托给它的处理程序。.live()方法已经被删除,无法使用了。需 要测试使用的话,需要引入向下兼容插件。</p>

<p>当我们需要停止事件委托的时候,可以使用.die()来取消掉。</p>

<pre><code>$('.button').die('click');
</code></pre>

<p>由于.live()和.die()在 jQuery1.4.3 版本中废弃了,之后推出语义清晰、减少冒泡传播层次、 又支持链接连缀调用方式的方法:<code>.delegate()</code>和.<code>undelegate()。</code>但这个方法在 jQuery1.7 版本中 被 <code>.on()</code> 方法整合替代了。</p>

<pre><code>$('#box').delegate('.button', 'click', function () { 
    $(this).clone().appendTo('#box');
});

$('#box').undelegate('.button','click');
</code></pre>

<p>注意 : .live()和.delegate()和.bind()方法一样都是事件绑定,那么区别也很明显,用途上 遵循两个规则:</p>

<p>1.在 DOM 中很多元素绑定相同事件时;</p>

<p>2.在 DOM 中尚不存在即将生成的 元素绑定事件时;我们推荐使用事件委托的绑定方式,否则推荐使用.bind()的普通绑定。</p>

<h2>四、on、off 和 one</h2>

<p>目前绑定事件和解绑的方法有三组共六个。由于这三组的共存可能会造成一定的混乱,为此 jQuery1.7 以后推出了 <code>.on()</code> 和 <code>.off()</code>方法彻底摒弃前面三组。</p>

<p>替代.bind()方式,并使用额外数据和事件对象</p>

<pre><code>$('.button').on('click', {user : 'Lee'}, function (e) {
    alert('替代.bind()' + e.data.user); 
});
</code></pre>

<p>替代.bind()方式,并绑定多个事件</p>

<pre><code>$('.button').on('mouseover mouseout', function () {
    alert('替代.bind()移入移出!'); 
});
</code></pre>

<p>代.bind()方式,以对象模式绑定多个事件</p>

<pre><code>$('.button').on({
    mouseover : function () { 
        alert('替代.bind()移入!');
        },
    mouseout : function () {
        alert('替代.bind()移出!'); 
        }
    });
</code></pre>

<p>替代.bind()方式,阻止默认行为并取消冒泡</p>

<pre><code>$('form').on('submit', function () {
    return false; 
});
</code></pre>

<p>或</p>

<pre><code>$('form').on('submit', false);
</code></pre>

<p>替代.unbind()方式,移除事件</p>

<pre><code>$('.button').off('click'); 
$('.button').off('click', fn); 
$('.button').off('click.abc');
</code></pre>

<p>替代.live()和.delegate(),事件委托</p>

<pre><code>$('#box').on('click', '.button', function () {
    $(this).clone().appendTo('#box'); 
});
</code></pre>

<p>替代.die()和.undelegate(),取消事件委托</p>

<pre><code>$('#box').off('click', '.button');
</code></pre>

<p>不管是.bind()还是.on(),绑定事件后都不是自动移除事件的,需要通过.unbind()和.off() 来手工移除。jQuery 提供了 <code>.one()</code> 方法,绑定元素执行完毕后自动移除事件,可以方法仅触 发一次的事件。</p>

<p>类似于.bind()只触发一次</p>

<pre><code>$('.button').one('click', function () {
    alert('one 仅触发一次!'); 
});
</code></pre>

<p>类似于.delegate()只触发一次</p>

<pre><code>$('#box).one('click', 'click', function () {
    alert('one 仅触发一次!'); 
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 事件对象]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-shi-jian-dui-xiang/"/>
    <updated>2015-10-14T21:58:43+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-shi-jian-dui-xiang</id>
    <content type="html"><![CDATA[<p>事件对象就是 <code>event</code> 对象,通过处理函数默认传递接受。之前处理函数的 <code>e</code> 就是 <code>event</code> 事件对象。</p>

<h3>一、事件对象</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', function (e) {       //接受事件对象参数
</span><span class='line'>  alert(e); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>通过 event.type 属性获取触发事件名</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert(e.type); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>通过 event.target 获取绑定的 DOM 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert(e.target); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>通过 event.data 获取额外数据,可以是数字、字符串、数组、对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', 123, function () {          //传递 data 数据 
</span><span class='line'>  alert(e.data);                                   //获取数字数据
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 如果字符串就传递:<code>'123'</code>、如果是数组就传递: <code>[123,'abc']</code> ,如果是对象就传递: <code>{user : 'Lee', age : 100}</code> 。数组的调用方式是: <code>e.data[1],</code> 对象的调用方式是: <code>e.data.user。</code></p>

<p>event.data 获取额外数据,对于封装的简写事件也可以使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click({user : 'Lee', age : 100},function (e) {
</span><span class='line'>  alert(e.data.user); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 键值对的键可以加上引号,也可以不加;在调用的时候也可以使用数组的方式: <code>alert(e.data['user']);</code></p>

<p>获取移入到 div 之前的那个 DOM 元素</p>

<pre><code>$('div').mouseover(function (e) {
    alert(e.relatedTarget); 
});
</code></pre>

<p>获取移出 div 之后到达最近的那个 DOM 元素</p>

<pre><code>$('div').mouseout(function (e) {
    alert(e.relatedTarget);
 });
</code></pre>

<p>获取绑定的那个 DOM 元素,相当于 this,区别与 <code>event.target</code></p>

<pre><code>$('div').click(function (e) {
    alert(e.currentTarget); 
});
</code></pre>

<p>注意 : <code>event.target</code> 得到的是触发元素的 DOM,<code>event.currentTarget</code> 得到的是监听元素的 DOM。而 <code>this</code>也是得到监听元素的 DOM。</p>

<p>获取上一次事件的返回值</p>

<pre><code>$('div').click(function (e) {
    return '123'; 
});
$('div').click(function (e) { 
    alert(e.result);
});
</code></pre>

<p>获取当前的时间戳</p>

<pre><code>$('div').click(function (e) {
    alert(e.timeStamp); 
});
</code></pre>

<p>获取触发元素鼠标当前的位置</p>

<pre><code>$(document).click(function (e) {
    alert(e.screenY+ ',' + e.pageY + ',' + e.clientY); 
});
</code></pre>

<h3>二、冒泡和默认行为</h3>

<p>如果在页面中重叠了多个元素,并且重叠的这些元素都绑定了同一个事件,那么就会出 现冒泡问题。</p>

<p>jQuery 提供了一个事件对象的方法: <code>event.stopPropagation();</code> 这个方法设置到需要触发 的事件上时,所有上层的冒泡行为都将被取消。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) { 
</span><span class='line'>  alert('按钮被触发了!'); 
</span><span class='line'>  e.stopPropagation();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>默认行为</p>

<p>网页中的元素,在操作的时候会有自己的默认行为。比如:右击文本框输入区域,会弹 出系统菜单、点击超链接会跳转到指定页面、点击提交按钮会提交数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('a').click(function (e) { 
</span><span class='line'>  e.preventDefault();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>禁止提交表单跳转</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('form').submit(function (e) {
</span><span class='line'>  e.preventDefault(); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 如果想让上面的超链接同时阻止默认行为且禁止冒泡行为,可以把两个方法同时 写上: <code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code> 。这两个方法如果需要同时启用的时候, 还有一种简写方案代替,就是直接 <code>return false。</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('a').click(function (e) { 
</span><span class='line'>  return false;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>冒泡和默认行为的一些方法</h2>

<p>判断是否取消了元素的默认行为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $('input').keyup(function (e) {
</span><span class='line'>  e.preventDefault();
</span><span class='line'>  alert(e.isDefaultPrevented()); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>取消冒泡并取消后续事件处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert('input');
</span><span class='line'>  e.stopImmediatePropagation();
</span><span class='line'> });
</span><span class='line'>
</span><span class='line'>$('input').click(function () { 
</span><span class='line'>  alert('input2');
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>$(document).click(function () { 
</span><span class='line'>  alert('document');
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>判断是否调用了 <code>stopPropagation()</code> 方法</p>

<pre><code>$('input').click(function (e) {
    e.stopPropagation();
    alert(e.isPropagationStopped()); 
});
</code></pre>

<p>判断是否执行了 <code>stopImmediatePropagation()</code> 方法</p>

<pre><code>$('input').click(function (e) {
    e.stopImmediatePropagation();
    alert(e.isImmediatePropagationStopped());
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 基础事件]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/13/jquery-zhi-ji-chu-shi-jian/"/>
    <updated>2015-10-13T21:42:16+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/13/jquery-zhi-ji-chu-shi-jian</id>
    <content type="html"><![CDATA[<p>在 JavaScript 课程的学习中,我们掌握了很多使用的事件,常用的事件有:<code>click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、change、select、submit、keydown、 keypress、keyup、blur、focus、load、resize、scroll、error。</code>那么,还有更多的事件可以参考 手册中的事件部分。</p>

<h3>一、绑定事件</h3>

<p>jQuery 通过 <code>.bind()</code> 方法来为元素绑定这些事件。可以传递三个参数<code>bind(type, [data], fn),</code>  <code>type</code> 表示一个或多个类型的事件名字符串; <code>[data]</code> 是可选的,作为 <code>event.data</code> 属性值传递一个 额外的数据,这个数据是一个字符串、一个数字、一个数组或一个对象;fn 表示绑定到指 定元素的处理函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', function () {    //点击按钮后执行匿名函数
</span><span class='line'>  alert('点击!'); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>普通处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', fn);       //执行普通函数式无须圆括号
</span><span class='line'>  function fn() {
</span><span class='line'>  alert('点击!'); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以同时绑定多个事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('mouseout mouseover', function () {    //移入和移出分别执行一次
</span><span class='line'>  $('div').html(function (index, value) { 
</span><span class='line'>      return value + '1';
</span><span class='line'>  }); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>通过对象键值对绑定多个参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind({             传递一个对象 
</span><span class='line'>  'mouseout' : function () {     //事件名的引号可以省略
</span><span class='line'>      alert('移出');
</span><span class='line'>  },
</span><span class='line'>  'mouseover' : function () {
</span><span class='line'>      alert('移入'); 
</span><span class='line'>  }
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>使用 unbind 删除绑定的事件</p>

<pre><code> $('input').unbind();
</code></pre>

<p>使用 unbind 参数删除指定类型事件</p>

<pre><code>$('input').unbind('click');
</code></pre>

<p><code>.mouseover()和.mouseout()</code> 表示鼠标移入和移出的时候触发。<code>.mouseenter()和.mouseleave()</code> 这组穿过,子元素不会触发。</p>

<p><code>.keydown()、.keyup()</code>返回的是键码,而 <code>.keypress</code>  返回的是字符编码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').keydown(function (e) {
</span><span class='line'>  alert(e.keyCode);
</span><span class='line'>});
</span><span class='line'>$('input').keypress(function (e) { 
</span><span class='line'>  alert(e.charCode);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><code>.focus()和.blur()</code> 分别表示光标激活和丢失,事件触发时机是当前元素。而<code>.focusin() 和.focusout()</code> 也表示光标激活和丢失,但事件触发时机可以是子元素。</p>

<h2>二、复合事件</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').hover(function () {                    //mouseenter 效果
</span><span class='line'>      $(this).css('background', 'black'); 
</span><span class='line'>  }, function () {                            //mouseleave 效果  可省略
</span><span class='line'>      $(this).css('background', 'red');
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : <code>.hover()</code> 方法是结合了 <code>.mouseenter()</code> 方法和 <code>.mouseleva()</code> 方法,并非 <code>.mouseover()</code> 和 <code>.mouseout()</code> 方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 DOM节点操作]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/13/jquery-domjie-dian-cao-zuo/"/>
    <updated>2015-10-13T00:33:04+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/13/jquery-domjie-dian-cao-zuo</id>
    <content type="html"><![CDATA[<p>DOM 中有一个非常重要的功能,就是节点模型,也就是 DOM 中的“M”。</p>

<h3>一、创建节点</h3>

<p>为了使页面更加智能化,有时我们想动态的在 html 结构页面添加一个元素标签,那么在插入之前首先要做的动作就是:创建节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = $('&lt;div id="box"&gt;节点&lt;/div&gt;');         //创建一个节点 
</span><span class='line'>$('body').append(box);                           //将节点插入到&lt;body&gt;元素内部</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>二、插入节点</h2>

<h4>> 内部插入节点方法:</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').append('&lt;strong&gt;节点&lt;/strong&gt;');    //向 div 内部插入 strong 节点 
</span><span class='line'>$('div').append(function (index, html) {    //使用匿名函数插入节点,html 是原节点
</span><span class='line'>  return '&lt;strong&gt;节点&lt;/strong&gt;';
</span><span class='line'>￼￼});
</span><span class='line'>
</span><span class='line'>$('span').appendTo('div');                 //讲 span 节点移入 div 节点内
</span><span class='line'>$('span').appendTo($('div'));              //同上
</span><span class='line'>
</span><span class='line'>$('div').prepend('&lt;span&gt;节点&lt;/span&gt;');     //将 span 插入到 div 内部的前面 
</span><span class='line'>$('div').append(function (index, html) {  //使用匿名函数,同上
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;'; 
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>$('span').prependTo('div');               //将 span 移入 div 内部的前面
</span><span class='line'>$('span').prependTo($('div'));            //同上</span></code></pre></td></tr></table></div></figure>


<h4>> 外部插入节点方法:</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').after('&lt;span&gt;节点&lt;/span&gt;');           //向 div 的同级节点后面插入 span
</span><span class='line'>$('div').after(function (index, html) {       //使用匿名函数,同上
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;';
</span><span class='line'>  });
</span><span class='line'>$('div').before('&lt;span&gt;节点&lt;/span&gt;');         //向 div 的同级节点前面插入 span
</span><span class='line'>$('div').before(function (index, html) { 
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;';
</span><span class='line'>  }); 
</span><span class='line'>$('span').insertAfter('div');                //将 span 元素移到 div 元素外部的后面
</span><span class='line'>$('span').insertBefore('div');               //将 span 元素移到 div 元素外部的前面</span></code></pre></td></tr></table></div></figure>


<h4>> 包裹节点</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').wrap('&lt;strong&gt;&lt;/strong&gt;');                   //在 div 外层包裹一层 strong
</span><span class='line'>$('div').wrap('&lt;strong&gt;123&lt;/strong&gt;');                //包裹的元素可以带内容
</span><span class='line'>$('div').wrap('&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;');          //包裹多个元素
</span><span class='line'>$('div').wrap($('strong').get(0));                    //也可以包裹一个原生 DOM 
</span><span class='line'>$('div').wrap(document.createElement('strong'));      //临时的原生DOM
</span><span class='line'>$('div').wrap(function (index) {
</span><span class='line'>  return '&lt;strong&gt;&lt;/strong&gt;'; 
</span><span class='line'>  });
</span><span class='line'>$('div').unwrap();                                    //移除一层包裹内容,多个需移除多次
</span><span class='line'>$('div').wrapAll('&lt;strong&gt;&lt;/strong&gt;');                //所有 div 外面只包一层 strong
</span><span class='line'>$('div').wrapAll($('strong').get(0)); 
</span><span class='line'>$('div').wrapInner('&lt;strong&gt;&lt;/strong&gt;');              //向指定元素的子内容包裹一层 html 
</span><span class='line'>$('div').wrapInner($('strong').get(0));               //DOM 节点
</span><span class='line'>$('div').wrapInner(function () {
</span><span class='line'>  return '&lt;strong&gt;&lt;/strong&gt;'; 
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<h2>三、节点操作</h2>

<pre><code>$('body').append($('div').clone(true));     //复制一个节点添加到 HTML 中
</code></pre>

<p>注意 : <code>clone(true)</code> 参数可以为空,表示只复制元素和内容,不复制事件行为。而加上 <code>true</code> 参数的话,这个元素附带的事件处理行为也复制出来。</p>

<pre><code>$('div').remove(); //直接删除 div 元素
</code></pre>

<p>注意 : <code>.remove()</code> 不带参数时,删除前面对象选择器指定的元素。而<code>.remove()</code> 也可以 带选择符参数的,比如 :<code>$('div').remove('#box');</code> 只删除 <code>id=box</code>  的<code>div。</code></p>

<pre><code>$('div').detach(); //保留事件行为的删除
</code></pre>

<p>注意 : <code>.remove()</code> 和 <code>.detach()</code> 都是删除节点,而删除后本身方法可以返回当前被删除的节 点对象,但区别在于前者在恢复时不保留事件行为,后者则保留。</p>

<pre><code>$('div').empty();   //删除掉节点里的内容
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').replaceWith('&lt;span&gt;节点&lt;/span&gt;');      //将 div 替换成 span 元素
</span><span class='line'>$('&lt;span&gt;节点&lt;/span&gt;').replaceAll('div');        //同上</span></code></pre></td></tr></table></div></figure>


<p>注意 : 节点被替换后,所包含的事件行为就全部消失了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 基础DOM操作]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/10/jquery-zhi-ji-chu-domhe-csscao-zuo/"/>
    <updated>2015-10-10T21:00:03+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/10/jquery-zhi-ji-chu-domhe-csscao-zuo</id>
    <content type="html"><![CDATA[<h3>一、设置元素及内容</h3>

<p>在常规的 DOM 元素中,使用 html()和 text()方法获取内部的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('#box').html();                       //获取 html 内容 
</span><span class='line'>$('#box').text();                       //获取文本内容,会自动清理 html 标签
</span><span class='line'>$('#box').html('&lt;em&gt;www.li.cc&lt;/em&gt;');   //设置 html 内容 
</span><span class='line'>$('#box').text('&lt;em&gt;www.li.cc&lt;/em&gt;');   //设置文本内容,会自动转义 html 标签</span></code></pre></td></tr></table></div></figure>


<p>使用 html()或 text()设置元素里的内容时,会清空原来的数据。而我们期 望能够追加数据的话,需要先获取原本的数据。</p>

<pre><code>$('#box').html($('#box').html() + '&lt;em&gt;www.li.cc&lt;/em&gt;'); //追加数据
</code></pre>

<p>如果元素是表单的话,jQuery 提供了 <code>val()</code>方法进行获取或设置内部的文本数据。</p>

<pre><code>$('input').val(); //获取表单内容 
$('input').val('www.li.cc'); //设置表单内容
</code></pre>

<p>如果想设置多个选项的选定状态,比如下拉列表、单选复选框等等,可以通过数组传递 操作。</p>

<pre><code>$("input").val(["check1","check2", "radio1" ]); //value 值是这些的将被选定
</code></pre>

<!--more-->


<h2>二、元素属性操作</h2>

<p>除了对元素内容进行设置和获取,通过 jQuery 也可以对元素本身的属性进行操作,包 括获取属性的属性值、设置属性的属性值,并且可以删除掉属性。</p>

<pre><code>$('div').attr('title');                            //获取属性的属性值
$('div').attr('title', '我是域名');                 //设置属性及属性值 
$('div').attr('title', function () {               //通过匿名函数返回属性值
    return '我是域名';});
$('div').attr('title', function (index, value) {  
    return value + (index+1) + ',我是域名';          //可以接受两个参数
});
</code></pre>

<p>注意: <code>attr()</code>方法里的 <code>function() {},</code>可以不传参数。可以只传一个参数 index,表示当前 元素的索引(从 0 开始)。也可以传递两个参数 index、value,第二个参数表示属性原本的值。</p>

<p>注意: jQuery 中很多方法都可以使用 <code>function() {}</code>来返回出字符串,比如<code>html()、text()、 val()</code>和上一章刚学过的 <code>is()、filter()</code>方法。而如果又涉及到多个元素集合的话,还可以传递 <code>index</code> 参数来获取索引值,并且可以使用第二个参数 <code>value</code>(并不是所有方法都适合,有兴趣 可以自己逐个尝试)。</p>

<pre><code>$('div').html(function (index) { //通过匿名函数赋值,并传递 index 
    return '我是' + (index+1) + '号 div';
});
$('div').html(function (index, value) { //还可以实现追加内容
     return '我是' + (index+1) + '号 div:'+value ;
});
$('div').removeAttr('title'); //这个方法就不可以使用匿名函数,传递 index 和 value 均无效。
</code></pre>

<h2>三、元素样式操作</h2>

<p>元素样式操作包括了直接设置 CSS 样式、增加 CSS 类别、类别切换、删除类别这几种操作方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').css('color');                   //获取元素行内 CSS 样式的颜色 
</span><span class='line'>$('div').css('color', 'red');           //设置元素行内 CSS 样式颜色为红色</span></code></pre></td></tr></table></div></figure>


<p>也可以获取多个 CSS 样式,而获取到的是一个对象数组,如果用 传统方式进行解析需要使用 for in 遍历。</p>

<pre><code>var box = $('div').css(['color', 'height', 'width']);              //得到多个 CSS 样式的数组对象 
    for (var i in box) {                                           //逐个遍历出来
    alert(i + ':' + box[i]); }
</code></pre>

<p>jQuery 提供了一个遍历工具专门来处理这种对象数组,<code>$.each()</code>方法,这个方法可以轻 松的遍历对象数组。</p>

<pre><code>$.each(box, function (attr, value) { //遍历 JavaScript 原生态的对象数组 
    alert(attr + ':' + value);
});
</code></pre>

<p>使用<code>$.each()</code>可以遍历原生的 JavaScript 对象数组,如果是 jQuery 对象的数组怎么使 用<code>.each()</code>方法呢?</p>

<pre><code>$('div').each(function (index, element) { //index 为索引,element 为元素 DOM 
    alert(index + ':' + element);
});
</code></pre>

<p>在需要设置多个样式的时候,我们可以传递多个 CSS 样式的键值对即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $('div').css({
</span><span class='line'>      'background-color' : '#ccc', 
</span><span class='line'>      'color' : 'red',
</span><span class='line'>      font-size' : '20px' 
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<p> CSS 类的样式切换功能。</p>

<pre><code>$('div').click(function () { //当点击后触发
    $(this).toggleClass('red size'); //单个样式多个样式均可 
    });
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').click(function () { 
</span><span class='line'>  $(this).toggleClass(function () {
</span><span class='line'>      if ($(this).hasClass('red')) { 
</span><span class='line'>          $(this).removeClass('red'); 
</span><span class='line'>          return 'green';
</span><span class='line'>      } else { 
</span><span class='line'>          $(this).removeClass('green');
</span><span class='line'>          return 'red';
</span><span class='line'>      } 
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>四、CSS 方法</h2>

<p>jQuery 不但提供了 CSS 的核心操作方法,比如.css()、.addClass()等。还封装了一些特殊功能的 CSS 操作方法,我们分别来了解一下。</p>

<pre><code>$('div').width();                          //获取元素的长度,返回的类型为number 
$('div').width(500);                       //设置元素长度,直接传数值,默认加 px  
$('div').width('500pt');                   //同上,设置了 pt 单位
$('div').width(function (index, value) {   //index 是索引,value 是原本值 
    return value - 500;                    //无须调整类型,直接计算
});
</code></pre>

<p><code>height()</code>方法同上。</p>

<h4>内外边距和边框尺寸方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alert($('div').width());           //获取元素宽度 不包含
</span><span class='line'>alert($('div').innerWidth());      //包含内边距 padding
</span><span class='line'>alert($('div').outerWidth());      //包含内边距 padding+边框 border
</span><span class='line'>alert($('div').outerWidth(true));  //包含内边距 padding+边框 border+外边距 margin</span></code></pre></td></tr></table></div></figure>


<h4>元素偏移方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('strong').offset().left;       //获取某个元素相对于视口的偏移位置
</span><span class='line'>$('strong').position().left;     //相对于父元素的偏移
</span><span class='line'>$(window).scrollTop();           //获取当前滚动条的位置
</span><span class='line'>$(window).scrollTop(300);        //设置当前滚动条的位置</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 过滤选择器]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/09/jquery-guo-lu-xuan-ze-qi/"/>
    <updated>2015-10-09T21:54:41+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/09/jquery-guo-lu-xuan-ze-qi</id>
    <content type="html"><![CDATA[<p>过滤选择器简称:过滤器。它其实也是一种选择器,而这种选择器类似与 CSS3里的伪类,可以让不支持 CSS3 的低版本浏览器也能支持。</p>

<h2>一、基本过滤器</h2>

<p>通过特定的过滤规则来筛选所需的 DOM 元素,和CSS中的伪类的语法类似:使用冒号(:)开头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('li:first').css('background', '#ccc');       //第一个元素
</span><span class='line'>$('li:last).css('background', '#ccc');         //最后一个元素
</span><span class='line'>$('li:not(.red)).css('background', '#ccc');    //非 class 为 red 的元素 
</span><span class='line'>
</span><span class='line'>$('li:even').css('background', '#ccc');        //索引为偶数的元素
</span><span class='line'>$('li:odd).css('background', '#ccc');          //索引为奇数的元素
</span><span class='line'>$('li:eq(2)).css('background', '#ccc');        //指定索引值的元素 
</span><span class='line'>
</span><span class='line'>$('li:gt(2)').css('background', '#ccc');       //大于索引值的元素
</span><span class='line'>$('li:lt(2)').css('background', '#ccc');       //小于索引值的元素
</span><span class='line'>
</span><span class='line'>$(':header').css('background', '#ccc');        //页面所有 h1 ~ h6 元素</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<p>注意:<code>:focus</code>过滤器,必须是网页初始状态的已经被激活焦点的元素才能实现元素获取。 而不是鼠标点击或者 Tab 键盘敲击激活的。</p>

<pre><code>$('input').get(0).focus();                 //先初始化激活一个元素焦点 
$(':focus').css('background', 'red');      //被焦点的元素
</code></pre>

<p>jQuery 为最常用的过滤器提供了专用的方法,已达到提到性能和效率的作用:</p>

<pre><code>$('li').eq(2).css('background', '#ccc');         //元素 li 的第三个元素,负数从后开始
$('li').first().css('background', '#ccc');       //元素 li 的第一个元素
$('li').last().css('background', '#ccc');        //元素 li 的最后一个元素
$('li').not('.red').css('background', '#ccc');   //元素 li 不含 class 为 red 的元素
</code></pre>

<h2>二、内容过滤器</h2>

<p>内容过滤器的过滤规则主要是包含的子元素或文本内容上。</p>

<pre><code>$('div:contains("ycku.com")').css('background', '#ccc');   //选择元素文本节点含有 ycku.com 文本的元素
$('div:empty').css('background', '#ccc');                  //选择空元素
$('ul:has(.red)').css('background', '#ccc');               //选择子元素含有 class 是 red 的元素 
$(':parent').css('background', '#ccc');                    //选择非空元素  选取含有子元素或文本的元素
</code></pre>

<p>jQuery 提供了一个 has()方法来提高:has 过滤器的性能:</p>

<pre><code>$('ul').has('.red').css('background', '#ccc');         //选择子元素含有 class 是 red 的元素
</code></pre>

<p>jQuery 提供了一个名称和<code>:parent</code>相似的方法,但这个方法并不是选取含有子元素或文本 的元素,而是获取当前元素的父元素,返回的是元素集合。</p>

<pre><code>$('li').parent().css('background', '#ccc');               //选择当前元素的父元素 
$('li').parents().css('background', '#ccc');              //选择当前元素的父元素及祖先元素 
$('li').parentsUntil('div').css('background', '#ccc');    //选择当前元素遇到 div 父元素停止
</code></pre>

<h2>三、可见性过滤器</h2>

<pre><code>$('p:hidden).size(); //选取所有不可见元素
$('p:visible').size(); //元素 p 显示的元素
</code></pre>

<p>注意:<code>:hidden</code>过滤器一般是包含的内容为:CSS 样式为<code>display:none、</code>input 表单类型为 <code>type="hidden"</code>和 <code>visibility:hidden</code>的元素。</p>

<h2>四、子元素过滤器</h2>

<p>子元素过滤器的过滤规则是通过父元素和子元素的关系来获取相应的元素。</p>

<pre><code>$('li:first-child').css('background', '#ccc');       //每个父元素第一个 li 元素 
$('li:last-child').css('background', '#ccc');        //每个父元素最后一个 li 元素 
$('li:only-child').css('background', '#ccc');        //每个父元素只有一个 li 元素 
$('li:nth-child(odd)').css('background', '#ccc');    //每个父元素奇数 li 元素
$('li:nth-child(even)').css('background', '#ccc');   //每个父元素偶数 li 元素
$('li:nth-child(2)').css('background', '#ccc');      //每个父元素第三个 li 元素
</code></pre>

<h2>五、其他方法</h2>

<p>jQuery 在选择器和过滤器上,还提供了一些常用的方法,方便我们开发时灵活使用。</p>

<pre><code>$('.red').is('li');                             //true,选择器,检测 class 为是否为 red
$('.red').is($('li'));                          //true,jQuery 对象集合,同上
$('.red').is($('li').eq(2));                    //true,jQuery 对象集合,同上
$('.red').is($('li').get(2));                   //true,DOM 对象,同上
$('.red').is(function () {                      //true,方法,同上
    return $(this).attr('title') == '列表 3';    //可以自定义各种判断
}));   
$('li').eq(2).hasClass('red');                   //和 is 一样,只不过只能传递 class

$('li').slice(0,2).css('background', '#ccc');    //前三个变成色
</code></pre>

<p>注意:这个参数有多种传法和 JavaScript 的 slice 方法是一样的比如:slice(2);slice(2,4),第三和第四被选定;slice(0,-2),从倒数第三个位置,向前选定 所有;slice(2,-2),前两个和末尾两个未选定。</p>

<pre><code>$("div").find("p").end().get(0);        //返回 div 的原生 DOM
$('div').contents().size();             //返回子节点(包括文本)数量

$('li').filter('.red').css('background','#ccc');         //选择 li 的 class 为 red 的元素
$('li').filter('.red, :first, :last').css('background','#ccc');    //增加了首尾选择
</code></pre>

<p>特殊要求函数返回</p>

<pre><code>$('li').filter(function () {
        return $(this).attr('class') == 'red' &amp;&amp; $(this).attr('title') == '列表 3'; 
        }).css('background', '#ccc');
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 常规选择器]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/09/jquery-chang-gui-qi/"/>
    <updated>2015-10-09T20:49:48+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/09/jquery-chang-gui-qi</id>
    <content type="html"><![CDATA[<p>jQuery 最核心的组成部分就是：选择器引擎。它继承了 CSS 的语法,不必担心浏览器的兼容性。</p>

<h3>一、简单选择器</h3>

<pre><code>$('div').css('color', 'red');          //元素名选择器,返回多个元素 
$('#box').css('color', 'red');         //ID 选择器,返回单个元素
$('.box').css('color', 'red');         //类(class)选择器,返回多个元素
</code></pre>

<p>可以用 jQuery 核心自带的一个属性 length 或 size()方法来查看返回的元素个数。</p>

<h5>容错功能：</h5>

<pre><code>$('#pox').css('color', 'red');       //不存在 ID 为 pox 的元素,也不报错 
document.getElementById('pox').style.color = 'red';     //报错了
</code></pre>

<!--more-->


<p>原生方法可以这么判断解决这个问题:</p>

<pre><code>if (document.getElementById('pox')) { //先判断是否存在这个对象 
    document.getElementById('pox').style.color = 'red';
}
</code></pre>

<p>使用 jQuery 调用的话,怎么去判断是否存在呢?因 为本身返回的是 jQuery 对象,可能会导致不存在元素存在与否,都会返回 true。</p>

<pre><code>if ($('#pox').length &gt; 0) { //判断元素包含数量即可 
    $('#pox').css('color', 'red');
}
</code></pre>

<p>可以用转换为 DOM 对象的方式来判断,例如:</p>

<pre><code>if ($('#pox').get(0)) {} 或 if ($('#pox')[0]) {} //通过数组下标也可以获取 DOM 对象
</code></pre>

<h3>二、进阶选择器</h3>

<pre><code>$('span, em, .box').css('color', 'red');    //群组选择器 
$('ul li a').css('color', 'red');           //后代选择器
$('*').css('color', 'red');                 //通配选择器
</code></pre>

<h3>三、高级选择器</h3>

<h4>1、层次选择器</h4>

<pre><code>$('#box p').css('color', 'red');              //后代选择器
$('#box').find('p').css('color', 'red');      //和后代选择器等价

$('#box &gt; p').css('color', 'red');            //子选择器,孙子后失明
$('#box').children('p').css('color', 'red');  //和子选择器等价

$('#box+p').css('color', 'red');              //next 选择器(下一个同级节点)
$('#box').next('p').css('color', 'red');      //和 next 选择器等价

$('#box ~ p').css('color', 'red');            //nextAll 选择器(后面所有同级节点)
$('#box').nextAll('p').css('color', 'red');   //和 nextAll 选择器等价
</code></pre>

<p>在 <code>find()、next()、nextAll()和 children()</code>这四个方法中,如果不传递参数,就相当于传递 了“*”,我们不建议这么做,不但影响性能,而且由于精准度不佳可能产生怪异的结果。</p>

<p>补充：</p>

<pre><code>$('#box').prev('p').css('color', 'red'); //同级上一个元素 
$('#box').prevAll('p').css('color', 'red'); //同级所有上面的元素

$('#box').prevUntil('p').css('color', 'red'); //同级上非指定元素选定,遇到则停止 
$('#box').nextUntil('p').css('color', 'red'); //同级下非指定元素选定,遇到则停止
</code></pre>

<p>siblings()方法正好集成了 prevAll()和 nextAll()两个功能的效果,及上下相邻的所有元素 进行选定:</p>

<pre><code>$('#box').siblings('p').css('color', 'red'); //同级上下所有元素选定
</code></pre>

<p>选择器快慢分析:</p>

<p>最快的是 find()方法,最慢的是$(&lsquo;#box p&rsquo;)这种高级选择器。如果一开始将 $(&lsquo;#box&rsquo;)进行赋值,那么 jQuery 就对其变量进行缓存,那么速度会进一步提高。</p>

<pre><code>var box = $('#box'); 
var p = box.find('p');
</code></pre>

<h4>2、属性选择器</h4>

<pre><code>$('a[title]').css('color', 'red');           //选定这个属性的
$('a[title=num1]').css('color', 'red');      //选定具有这个属性=这个属性值的
$('a[title=^num]').css('color', 'red');      //选定具有这个属性且开头属性值匹配的
$('a[title|="num"]').css('color', 'red');    //选定具有这个属性且等于属性值或开头属性值匹配后面跟一个“-”号
$('a[title$=num]').css('color','red');       //选定具有这个属性且结尾属性值匹配的
$('a[title!=num1]').css('color','red');      //选定具有这个属性且属性值不想等的
$('a[title~=num1]').css('color','red');      //选定具有这个属性且属性值是以一个空格分割的列表,其中包含属性值的
$('a[title*=num]').css('color','red');       //选定具有这个属性且属性值含有一个指定字串的
$('a[bbb][title=num1]').css('color','red');  //选定具有多个属性且属性值匹配成功的
</code></pre>

<h2>四、表单选择器</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').val();                     //元素名定位,默认获取第一个
</span><span class='line'>$('input').eq(1).val();               //同上,获取第二个
</span><span class='line'>$('input[type=password]').val();      //选择 type 为 password 的字段
</span><span class='line'>$('input[name=user]').val();          //选择 name 为 user 的字段</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css3 Box-flex]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/07/css3-box-flexshu-xing/"/>
    <updated>2015-10-07T16:11:02+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/07/css3-box-flexshu-xing</id>
    <content type="html"><![CDATA[<p>CSS3中新的盒子模型——弹性盒子模型(Flexible Box Model)。”flex”一词中文有“收缩”之意。</p>

<h3>一、box-flex属性（和谐版）</h3>

<p>不过，从此属性实际上产生的效果来看，无论怎样用“收缩”一词解释都显得很牵强。所以，这里，直接抛开字面意思，我们可以将<code>”box-flex”</code>理解为”房子-分配”。box为“盒子”的意思，我们可以理解为当下价格巨高的“房子”，<code>”flex”</code>指兄弟几个“分配房子”。比如：</p>

<!--more-->


<pre><code>#老大 { 房子-分配: 2; }
#老二 { 房子-分配: 1; }
#老三 { 房子-分配: 1; }
</code></pre>

<p>换成CSS表示就是：</p>

<pre><code>#first_boy { box-flex: 2; }
#second_boy { box-flex: 1; }
#three_boy { box-flex: 1; }
</code></pre>

<p><code>box-flex</code>的值为至少为1的整数时起作用。但是，仅仅一个<code>box-flex</code>属性是不足以实现子元素间的空间分配，因为还要看其老爸的意思。只有老爸开口说：“这个房子现在你们随意分配。”其子女才能分配。</p>

<p>所以，父元素也是需要添加必要的声明的。此声明就是：</p>

<pre><code>#father { display: box; }
</code></pre>

<p>似乎也可以是：</p>

<pre><code>#father { display: inline-box; }
</code></pre>

<p><code>display: box;</code>的声明其实就是弹性盒子模型的声明，此声明下的子元素的行为与表现与CSS2中的传统盒子模型的表现是有显著的差异的。</p>

<p>毕竟属于CSS3的东西，目前而言，仅Firefox/Chrome/Safari浏览器支持弹性盒子模型（IE9不详，Opera尚未），且使用的时候，需要附带私有前缀。就是诸如<code>-moz-, -webkit-</code>之类。</p>

<h5>CSS实例代码如下：</h5>

<pre><code>.test_box {
    display: -moz-box; 
    display: -webkit-box; 
    display: box; 

    ...
 }
.list {
   ...
}
.list_one {
    -moz-box-flex: 1; 
    -webkit-box-flex: 1; 
    box-flex: 1;
}
.list_two{
    -moz-box-flex: 2; 
    -webkit-box-flex: 2; 
    box-flex: 2;
}
</code></pre>

<h5>HTML代码如下：</h5>

<pre><code>&lt;div class="test_box"&gt;
    &lt;div class="list list_two"&gt;1&lt;/div&gt;
    &lt;div class="list list_one"&gt;2&lt;/div&gt;
    &lt;div class="list list_one"&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<h3>二、CSS box-flex属性（不和谐版）</h3>

<p>改编成CSS剧本就是：</p>

<pre><code>#first_boy { box-flex: 2; }
#second_boy { box-flex: 1; }
#three_boy { width: 50px; }
</code></pre>

<p>新增CSS样式如下：</p>

<pre><code>.list_w300 { width: 300px; }
</code></pre>

<p>老三分得300像素的宽度，剩下的像素宽度老大和老二2:1比例分配。</p>

<h3>三、爸爸其实很厉害，的说~</h3>

<p>爸爸肚子中的货有：<code>box-orient, box-direction, box-align, box-pack, box-lines.</code>现在依次讲讲这里box打头的属性都是干嘛用的。</p>

<h5>box-orient</h5>

<p>待续。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css3 之 Transform]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/05/css3-zhi-transform/"/>
    <updated>2015-10-05T12:18:56+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/05/css3-zhi-transform</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Margin]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/05/css-zhi-margin/"/>
    <updated>2015-10-05T10:53:49+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/05/css-zhi-margin</id>
    <content type="html"><![CDATA[<p>你真的了解margin吗？你知道margin有什么特性吗？你知道什么是垂直外边距合并？&hellip; 我真的有点晕！！</p>

<h4>一、Margin是什么</h4>

<p>边界，元素周围生成额外的空白区。“空白区”通常是指其他元素不能出现且父元素背景可见的区域。——CSS权威指南<!--more--></p>

<h4>二、垂直外边距合并问题</h4>

<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距合并。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>

<p>垂直外边距合并问题常见于第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距，而且只在标准浏览器下(FirfFox、Chrome、Opera、Sarfi)产生问题，IE下反而表现良好。</p>

<p>如果你读过了上面W3Shcool的CSS外边距合并的文章后，就很容易讨论这个问题了。这个问题发生的原因是根据规范，一个盒子如果没有上补白<code>(padding-top)</code>和上边框<code>(border-top)</code>，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>

<p>再说了白点就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己“领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级。</p>

<p>个人认为：margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p>

<h4>三、 margin在块元素、内联元素中的区别</h4>

<p>HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。</p>

<p>顾名思义，block元素就是以”块”表现的元素<code>（block-like elements）</code>，inline元素即是以”行”表现的元素<code>（character level elements and text strings）</code>。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。</p>

<p>block元素（块元素）大致有：P|H1|H2|H3|H4|H5|H6|UL|OL|PRE| DL | DIV | NOSCRIPT | BLOCKQUOTE | FORM | HR | TABLE | FIELDSET | ADDRESS</p>

<p>inline元素（内联元素）大致有：#PCDATA（即文本）| TT | I | B | BIG | SMALL|EM | STRONG | DFN | CODE |SAMP | KBD | VAR | CITE | ABBR | ACRONYM|A | IMG | OBJECT | BR | SCRIPT | MAP | Q | SUB | SUP | SPAN | BDO|INPUT | SELECT | TEXTAREA | LABEL | BUTTON</p>

<p>其中有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。</p>

<p>置换元素（replaced element）主要是指<code>img, input, textarea, select, object</code>等这类默认就有 CSS 格式化外表范围的元素。进而可知，非置换元素（non-replaced element）就是除了<code>img, input, textarea, select, object</code>等置换元素以外的元素。</p>

<p><code>margin-top/margin-bottom</code>对内联元素没有多大实际效果，不过<code>margin-left/margin-right</code>还是能够对内联元素产生影响的。</p>

<h4>四、  负margin技术及其应用</h4>

<pre><code>margin:-10px 20px -30px 40px;
</code></pre>

<p><img src="http://www.planabc.net/wp-content/uploads/2008/02/margin_example.gif" alt="margin" /></p>

<p>物理大小指的是除去 margin，也就是包含 border 以内的 box 大小，而逻辑大小，则是 box 通过 margin 解析规则解析后得到的大小</p>

<p>box 的实际大小 = box 的物理大小 + 正的 margin</p>

<h5>结论：</h5>

<p>box 最后的显示大小等于 box 的 border 及 border 内的大小加上正的 margin 值。而负的 margin 值不会影响 box 的实际大小，如果是负的 top 或 left 值会引起 box 的向上或向左位置移动，如果是 bottom 或 right 只会影响下面 box 的显示的参考线。</p>

<h4>四、 常见的浏览器下margin出现的bug</h4>

<h5>IE6中双边距Bug</h5>

<ul>
<li>发生场合：当给父元素内第一个浮动元素设置<code>margin-left（元素float:left）</code>或<code>margin-right（元素float:right）</code>时margin加倍。</li>
</ul>


<p>解决方法：是给浮动元素加上<code>display:inline;</code>；或者用<code>padding-left</code>代替<code>margin-left</code>。</p>

<p>待整理。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 图片垂直居中]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/04/css-zhi-tu-pian-chui-zhi-ju-zhong/"/>
    <updated>2015-10-04T23:05:07+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/04/css-zhi-tu-pian-chui-zhi-ju-zhong</id>
    <content type="html"><![CDATA[<h3>大小不固定，图片的垂直居中</h3>

<h4>① 透明gif图片+背景定位</h4>

<p>这里利用了<code>background-position:center</code>实现图片居中显示。这是个很实用也是很聪明的办法，对于维护控制成本都很不错。微软必应图片搜索的图片排列就是使用的这种方法。 方法的原理很简单，使用一个透明的gif图片做覆盖层，高宽拉伸至所需要的大小，然后给这个gif图片一个<code>background-position:center center</code>的属性。而background-image建议写在页面上，因为实际项目中，这肯定是个动态的URL地址，css文件似乎不支持动态URL地址。下面就是此方法的实例表现。</p>

<!--more-->


<pre><code>&lt;ul class="zxx_align_box_3 fix"&gt;
    &lt;li&gt;
    &lt;img src="../image/pixel.gif" style="background-image:url(/image/study/s/s128/mm1.jpg);" /&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>css部分：</p>

<pre><code>.zxx_align_box_3 li{width:1em; height:1em; font-size:128px; float:left;}
.zxx_align_box_3 li img{display:block; width:100%; height:100%; background-repeat:no-repeat; background-position:center;}
</code></pre>

<h4>② display:inline-block和文字大小控制居中</h4>

<p>代码相当简洁，是个成本很低，效果惊人的方法，适用于多图显示的情况。只需要一层必须要的a标签就解决问题了！</p>

<pre><code>&lt;div class="zxx_align_box_5 fix"&gt;
    &lt;a href="#zhangxinxu"&gt;
        &lt;img src="http://image/study/s/s128/mm1.jpg" /&gt;
    &lt;/a&gt;
    &lt;a href="#zhangxinxu"&gt;
        &lt;img src="http://image/study/s/s128/mm2.jpg" /&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p>css:</p>

<pre><code>.zxx_align_box_5 a{display:inline-block; width:1.2em; font-size:128px; text-align:center; vertical-align:middle;}
.zxx_align_box_5 a img{vertical-align:middle; padding:2px; border:1px solid #beceeb;}
</code></pre>

<h6>需要说明的：</h6>

<p>1.img外的标签需是a标签或span这类inline属性的标签，div标签也可以，但是css代码多些:<code>display:inline; display:inline-block</code>先变成inline属性，再转变成inline-block属性，原因讲起来又是一篇长长的文章，放着。</p>

<p>2.此方法只需要两层标签即可，可谓代码超简洁，但是只适用于多图垂直居中对齐的情况。因为其对齐原理是相邻的图片居中对齐，如果只是一个图片，vertical-align:middle就只有与空格对齐了。</p>

<h4>③ 使用空白图片实现垂直对齐</h4>

<pre><code>&lt;ul class="zxx_align_box_6 fix"&gt;
    &lt;li&gt;
    &lt;img class="show_img" src="http://amy-liu.github.io/image/study/s/s128/mm1.jpg" /&gt;
    &lt;img class="alpha_img" src="../image/pixel.gif" /&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>css:</p>

<pre><code>.zxx_align_box_6 li{height:128px; width:150px;float:left;text-align:center; font-size:0;}
.zxx_align_box_6 li .alpha_img{height:100%; width:1px; vertical-align:middle;}
.zxx_align_box_6 li .show_img{vertical-align:middle;}
</code></pre>

<h6>原理简述：</h6>

<p>一句话，将要显示的图片与一张透明的高度100%，宽度1像素的透明图片<code>vertical-align:middle</code>对齐。</p>

<p>其核心原理其实与第二种利用font-size大小实现IE下图片垂直居中是一致的。将font-size设置得很大，目的是撑开IE下默认文字空间的高度，其性质类似于空格，然后通过<code>vertical-align:middle</code>属性让图片与这个高高的空白空格空间垂直居中对齐；</p>

<p>而这里将这个看不见的文字空间实例成一张透明的gif图片，高度可以轻松设置为外部标签的高度，然后通过<code>vertical-align:middle</code>对齐，就实现效果了，在各个浏览器下都是一样的表现，不需要担心什么兼容性的问题。而且代码很简单，很易懂，想出错都难！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Line-height]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/03/css-zhi-line-height/"/>
    <updated>2015-10-03T16:28:19+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/03/css-zhi-line-height</id>
    <content type="html"><![CDATA[<h3>一、字面意思</h3>

<p>“Line-height”顾名思意指一行文字的高度。具体来说是指两行文字间基线之间的距离。基线实在英文字母中用到的一个概念，我们刚学英语的时使用的那个英语本子每行有四条线，其中底部第二条线就是基线。</p>

<p><img src="http://amy-liu.github.io/images/base_line.jpg" alt="base_line" /></p>

<h3>二、line-height与line boxes高度</h3>

<p>css中起高度作用的应该就是height以及line-height了吧！如果一个标签没有定义height属性(包括百分比高度)，那么其最终表现的高度一定是由line-height起作用，即使是IE6下11像素左右默认高度bug也是如此。</p>

<!--more-->


<p>一个空的div，如果没有设置至少大于1像素高度height值时，该div的高度就是个0。如果该div里面打入了一个空格或是文字，则此div就会有一个高度。
深入理解inline模型后，会发现，不是文字撑开了div的高度，而是line-height！测试：</p>

<pre><code>.test1{font-size:20px; line-height:0; border:1px solid #cccccc; background:#eeeeee;}
.test2{font-size:0; line-height:20px; border:1px solid #cccccc; background:#eeeeee;}
</code></pre>

<p>在inline box模型中，有个line boxes，它是看不见的，它的工作就是包裹每行文字。一行文字一个line boxes。如果它们在一行显示，只有一个line boxe，但要是竖着写，一行一个，一个字罩着一个line boxes。line boxes什么特性也没有，就高度。所以一个没有设置height属性的div的高度就是由一个一个line boxes的高度堆积而成的。</p>

<p>line boxes的高度是由inline boxes决定的，inline boxes就是文字，图片啊，span之类的inline属性的标签。这些标签谁的实际line-height值最高，谁最高，line boxes就取谁的值，形成高度。</p>

<p>1、单行文字的垂直居中对齐</p>

<p>把<code>line-height</code>设置为需要的box的大小可以实现单行文字的垂直居中”。</p>

<p>2、多行文字的垂直居中</p>

<pre><code>.mulit_line{line-height:150px; border:1px dashed #cccccc; padding-left:5px;}
.mulit_line span{display:inline-block; line-height:1.4em; vertical-align:middle;}
</code></pre>

<p>html代码：</p>

<pre><code>&lt;p class="mulit_line"&gt;
&lt;span style="font-size:12px;"&gt;这里是高度为150像素的标签内的多行文字，文字大小为12像素。&lt;br /&gt;这里是第二行，用来测试多行的显示效果。&lt;/span&gt;&lt;/p&gt;
</code></pre>

<p>兼容性还未测 待后续补充</p>

<h3>三、行高在文章显示中的应用</h3>

<p>文章里面的文字是有大有小的，使用px定值，由于继承性，无法实现根据文字大小自动调整间距，会出现大号文字重叠的现象。一般文章显示最好是650像素的宽度，1.5倍的行距较好。</p>

<p>有个很搓的办法可以实现文字间距自动适应于文字的大小，那就是使用“*”通配符，例如：<code>.article_box *{line-height:150%;}</code>使用“*”通配符大大增加了css的渲染，效率低。</p>

<p>更好的方法，就是使用数值。150%和1.5在值上是一样的，但是它们也是有差别的，差别在于继承性，使用百分比会计算<code>line-height</code>的值，然后以px像素为单位继承下去，而1.5则是先继承1.5这个值，遍历到了该标签再计算<code>line-height</code>的像素值。所以同样的效果只需要.<code>article_box{line-height:1.5;}</code>就可以实现了。</p>

<h3>四、使用行高代替高度避免haslayout</h3>

<p>某些情形下，line-height可以和height互换，因为实现的效果一样。都能撑开一个高度，然而这两个css属性有一个较隐蔽的差异，就是使用height会使标签haslayout，而使用line-height则不会。以前只有IE6的时候曾流行使用height清除浮动，就是利用了IE下height使haslayout的属性。但有时候，haslayout并不需要，反而要避免。</p>

<p>有关自适应按钮使用了line-height代替了height，其原因在于：IE6，IE7下，类似inline-block属性的元素里如果有block属性的元素，如果该block haslayout，则该标签会冲破外部inline-block的显示而宽度100%显示，从使按钮自适应文字大小的效果失效，解决方法就是使用line-height代替height。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Inline-block]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/03/css-zhi-inline-block/"/>
    <updated>2015-10-03T15:10:13+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/03/css-zhi-inline-block</id>
    <content type="html"><![CDATA[<h3>替代float 的 inline-block列表布局</h3>

<p>浮动本身就是个魔鬼，所以，使用浮动布局还需要修复其带来的副作用——高度塌陷的问题，也就是常提到的“清除浮动”。</p>

<p>关于line box模型，就是每一行所有的inline元素和inline-block元素会共同形成一个line boxes，这个line box的高度由里面最高的元素决定。<code>inline-block</code>属性属于line box模型，其布局的列表元素高度异常时，撑开的是整个line boxes的高度，因而，不会与下一行的列表元素发生错位。</p>

<!--more-->


<h3>一、inline-block的兼容性</h3>

<p>对于IE8+以及现代浏览器，直接使用：</p>

<pre><code>{display:inline-block;}
</code></pre>

<p>对于不支持的IE6/7浏览器 如果是inline元素（如a标签，span标签之类）跟上面一样，直接：</p>

<pre><code>{display:inline-block;}
</code></pre>

<p>如果是block元素，如下所示：</p>

<pre><code>{display:inline-block; *display:inline；*zoom:1;}
</code></pre>

<h3>二、一点小阻挠：inline-block元素间的换行符空格间隙问题</h3>

<p>使用display:inline-block布局经常会遇到的“换行符/空格间隙问题”。</p>

<p>如果inline-block元素间有空格或是换行产生了间隙，那是正常的，真正的inline-block元素，就像个图片一样。例如，两个不在一行的img标签，形成的两个图片之间就会有间隙。要让这些空格不出现，最简单的最容易理解的就是让列表的结束标签与下一个列表的开始标签连在一起，这样代码的可读性很不好，不建议使用。</p>

<p>空格符本质上就是个字符，与a,b,c,d这些字符是个同一个属性的东西，只是他是空格，透明的看不见而已（但可以选中）。所以，只要我们使用让文字宽度为0的那些方法，是不是就可以解决inline-block元素间换行符间隙的问题呢！</p>

<pre><code>{font-size:0;}
</code></pre>

<p>结果IE7E和Safari 会有1像素空隙，Chrome下的空格对于<code>font-size:0</code>貌似很不屑一顾,置若罔闻，连同样内核的Safari都不会这样。</p>

<p>想到有个letter-spacing属性。可以控制文字间的水平距离的，支持负值，可以让文字水平方向上重叠（line-height是让文字垂直方向上重叠）。</p>

<pre><code>letter-spaceing:-4px;
</code></pre>

<p>既然IE6/7浏览器div,li 这些标签inline-block化后没有空格间隙，那么使用letter-spacing负值会不会让列表元素水平重叠呢？这个问题就不要担心了，如果元素间本身没有空格，使用letter-spacing属性是不会发生水平重叠的问题的。测试通过。
唯一有瑕疵的是在Opera浏览器下，两个inline-block元素间空白间隙使用letter-spacing去除的极限是1像素，当看上去要正好为0的时候，letter-spacing似乎失效，空白间距恢复成letter-spacing:0时的效果。</p>

<p>ok，整理一下：</p>

<p>» block水平的元素inline-block化后，IE6/7没有换行符间隙问题，其他浏览器均有；</p>

<p>» inline水平的元素inline-block后，所有主流浏览器都有换行符/空格间隙问题；</p>

<p>» font-size:0，去除换行符间隙，在IE6/7下残留1像素间隙，Chrome浏览器无效，其他浏览器都完美去除；</p>

<p>» letter-spacing负值可以去除所有浏览器的换行符间隙，但是，Opera浏览器下极限是间隙1像素，0像素会反弹，换行符间隙还原。</p>

<p>虽然font-size:0有缺陷，letter-spacing负值也有不足，但是一旦将它们同时出现，互补与整合，换行符间隙问题迎刃而解。</p>

<pre><code>letter-spacing:-3px; font-size:0
</code></pre>

<h6>所以，应用display:inline-block属性实现列表布局的几个关键字就是：block水平的标签，font-size:0和letter-spacing负值。</h6>

<h3>三、更进一步：更加灵活的inline-block列表布局</h3>

<p>使用white-space:nowrap;属性可以让列表不换行，你是否想到了列表元素的水平滚动切换</p>

<p>text-align:justify可以实现自动等宽水平排列的列表布局，而且是两端对齐的，不需要计算宽度，一切都是浏览器自动的，很方便很强大。尤其在自适应布局中。</p>

<pre><code>.box{width:50%; padding:20px; margin:20px auto; background-color:#f0f3f9; text-align:justify;}
.list{width:120px; display:inline-block; padding-bottom:20px; text-align:center; vertical-align:top;}
</code></pre>
]]></content>
  </entry>
  
</feed>
