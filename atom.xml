<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[云端笔记]]></title>
  <link href="http://amy-liu.github.io/atom.xml" rel="self"/>
  <link href="http://amy-liu.github.io/"/>
  <updated>2015-11-02T21:37:18+08:00</updated>
  <id>http://amy-liu.github.io/</id>
  <author>
    <name><![CDATA[amy-liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 面向对象与原型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/28/jaxiang-dui-xiang-yu-yuan-xing/"/>
    <updated>2015-10-28T23:46:09+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/28/jaxiang-dui-xiang-yu-yuan-xing</id>
    <content type="html"><![CDATA[<p>ECMAScript 有两种开发模式:1.函数式(过程化),2.面向对象(OOP)。面向对象的语言 有一个标志,那就是类的概念,而通过类可以创建任意多个具有相同属性和方法的对象 。但 是,ECMAScript 没有类的概念,因此它的对象也与基于类的语言中的对象有所不同。</p>

<h3>一、创建对象</h3>

<p>创建一个对象,然后给这个对象新建属性和方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = new Object();            //创建一个 Object 对象 
</span><span class='line'>box.name = 'Lee';                  //创建一个 name 属性并赋值
</span><span class='line'>box.age = 100;                     //创建一个 age 属性并赋值
</span><span class='line'>box.run = function () {            //创建一个 run()方法并返回值
</span><span class='line'>  return this.name + this.age + '运行中...'; 
</span><span class='line'>};
</span><span class='line'>alert(box.run()); //输出属性和方法的值</span></code></pre></td></tr></table></div></figure>


<p>上面创建了一个对象,并且创建属性和方法,在 run()方法里的 this,就是代表 box 对象 本身。这种是 JavaScript 创建对象最基本的方法,但有个缺点,想创建一个类似的对象 ,就 会产生大量的代码。</p>

<p>为了解决多个类似对象声明的问题 ,我们可以使用一种叫做 工厂模式的方法,这种方法 就是为了解决实例化对象产生大量重复的问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createObject(name, age) { //集中实例化的函数 var obj = new Object();
</span><span class='line'>  obj.name = name;
</span><span class='line'>  obj.age = age;
</span><span class='line'>  obj.run = function () {
</span><span class='line'>      return this.name + this.age + '运行中...';
</span><span class='line'>  };
</span><span class='line'>      return obj; 
</span><span class='line'>  }
</span><span class='line'>var box1 = createObject('Lee', 100); 
</span><span class='line'>var box2 = createObject('Jack', 200); 
</span><span class='line'>alert(box1.run());
</span><span class='line'>alert(box2.run());</span></code></pre></td></tr></table></div></figure>


<p>工厂模式解决了重复实例化的问题 ,但还有一个问题,那就是识别问题,因为根本无法 搞清楚他们到底是哪个对象的实例。</p>

<pre><code>alert(typeof box1);             //Object 
alert(box1 instanceof Object);  //true
</code></pre>

<!--more-->


<p>ECMAScript 中可以采用构造函数(构造方法)可用来创建特定的对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function Box(name, age) { //构造函数模式 
</span><span class='line'>  this.name = name;
</span><span class='line'>  this.age = age; 
</span><span class='line'>  this.run = function () {
</span><span class='line'>      return this.name + this.age + '运行中...'; };
</span><span class='line'>  }
</span><span class='line'>var box1 = new Box('Lee', 100); //new Box()即可 
</span><span class='line'>var box2 = new Box('Jack', 200);
</span><span class='line'>
</span><span class='line'>alert(box1.run());
</span><span class='line'>alert(box1 instanceof Box); //很清晰的识别他从属于 Box</span></code></pre></td></tr></table></div></figure>


<p>使用构造函数的方法 ,即解决了重复实例化的问题 ,又解决了对象识别的问题,构造函数的方法有一些规范:</p>

<ul>
<li>函数名和实例化构造名相同且大写, (PS:非强制,但这么写有助于区分构造函数和 普通函数);</li>
<li>通过构造函数创建对象,必须使用 new 运算符。</li>
</ul>


<p>既然通过构造函数可以创建对象,那么这个对象是哪里来的, <code>new Object()</code>在什么地方 执行了?执行的过程如下:</p>

<ul>
<li>当使用了构造函数,并且 new 构造函数(),那么就后台执行了 <code>new Object()</code>;</li>
<li>将构造函数的作用域给新对象 ,(即 <code>new Object()</code>创建出的对象),而函数体内的 <code>this</code> 就 代表 <code>new Object()</code>出来的对象。</li>
<li>执行构造函数内的代码;</li>
<li>返回新对象(后台直接返回)。</li>
</ul>


<p>关于 <code>this</code> 的使用,<code>this</code> 其实就是代表当前作用域对象的引用 。如果在全局范围 this 就代 表 window 对象,如果在构造函数体内,就代表当前的构造函数所声明的对象。</p>

<pre><code>var box = 2;
alert(this.box); //全局,代表 window
</code></pre>

<p>构造函数和普通函数的唯一区别 ,就是他们调用的方式不同 。只不过,构造函数也是函 数,必须用 new 运算符来调用,否则就是普通函数。</p>

<pre><code>var box = new Box('Lee', 100);           //构造模式调用
alert(box.run());

Box('Lee', 20);                          //普通模式调用,无效

var o = new Object(); 
Box.call(o, 'Jack', 200)                //对象冒充调用
alert(o.run());  
</code></pre>

<p>可以把构造函数里的方法(或函数)用 new Function()方法来代替,得到一样的效果,更加证明,他们最终判断的是引用地址,唯一性。</p>

<pre><code>function Box(name, age) { //new Function()唯一性
    this.name = name;
    this.age = age;
    this.run = new Function("return this.name + this.age + '运行中...'");
}
</code></pre>

<p>虽然使用了全局的函数 run()来解决了保证引用地址一致的问题,但这种方式又带来了 一个新的问题,全局中的 this 在对象调用的时候是 Box 本身,而当作普通函数调用的时候 , this 又代表 window。</p>

<h2>二、原型</h2>

<p>我们创建的每个函数都有一个 <code>prototype(原型)</code> 属性,这个属性是一个对象,它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解: <code>prototype</code> 通过 调用构造函数而创建的那个对象的原型对象 。使用原型的好处可以让所有对象实例共享它所 包含的属性和方法。也就是说,不必在构造函数中定义对象信息 ,而是可以直接将这些信息 添加到原型中。</p>

<pre><code>function Box() {}                   //声明一个构造函数
Box.prototype.name = 'Lee';         //在原型里添加属性
Box.prototype.age = 100; 
Box.prototype.run = function () {   //在原型里添加方法
    return this.name + this.age + '运行中...'; 
    };
</code></pre>

<p>比较一下原型内的方法地址是否一致:</p>

<pre><code>var box1 = new Box();
var box2 = new Box();
alert(box1.run == box2.run);   //true,方法的引用地址保持一致
</code></pre>

<p>为了更进一步了解构造函数的声明方式和原型模式的声明方式 ,我们通过图示来了解一 下:</p>

<p><img src="http://amy-liu.github.io/images/creat.jpg" alt="creat" /></p>

<p><img src="http://amy-liu.github.io/images/proto.png" alt="proto" /></p>

<p>在原型模式声明中,多了两个属性,这两个属性都是创建对象时自动生成的 。<code>__proto__</code> 属性是实例指向原型对象的一个指针,它的作用就是指向构造函数的原型属性 <code>constructor</code>。 通过这两个属性,就可以访问到原型里的属性和方法了。  <br/>
PS:IE 浏览器在脚本访问<code>__proto__</code> 会不能识别,火狐和谷歌浏览器及其他某些浏览器 均能识别。虽然可以输出,但无法获取内部信息。</p>

<pre><code>alert(box1.__proto__); //[object Object]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 基本包装类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/28/javascript-zhi-ji-ben-bao-zhuang-lei-xing/"/>
    <updated>2015-10-28T23:43:32+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/28/javascript-zhi-ji-ben-bao-zhuang-lei-xing</id>
    <content type="html"><![CDATA[<p>为了便于操作基本类型值 ,ECMAScript 提供了 3 个特殊的引用类型 : <code>Boolean</code> 、<code>Number</code> 和 <code>String</code>。这些类型与其他引用类型相似 ,但同时也具有与各自的基本类型相应的特殊行为 。 实际上,每当读取一个基本类型值的时候,后台就会创建一个对应的基本包装类型的对象 , 从而能够调用一些方法来操作这些数据。</p>

<h3>一、基本包装类型概述</h3>

<pre><code>var box = 'Mr. Lee';                     //定义一个字符串
var box2 = box.substring(2);             //截掉字符串前两位
alert(box2);
</code></pre>

<p>变量 box 是一个字符串类型,而 <code>box.substring(2)</code>又说明它是一个对象(<code>PS:只有对象才 会调用方法</code>),最后把处理结果赋值给 box2。<code>'Mr. Lee'</code>是一个字符串类型的值,按道理它不 应该是对象,不应该会有自己的方法,比如:</p>

<pre><code>alert('Mr. Lee'.substring(2));            //直接通过值来调用方法
</code></pre>

<p>1.字面量写法:</p>

<pre><code>var box = 'Mr. Lee';             //字面量 
box.name = 'Lee';                //无效属性
box.age = function () {          //无效方法
    return 100; 
};
alert(box);                      //Mr. Lee 
alert(box.substring(2));         //. Lee 
alert(typeof box);               //string
alert(box.name);                 //undefined
alert(box.age());                //错误
</code></pre>

<!--more-->


<p>2.new 运算符写法:</p>

<pre><code>var box = new String('Mr. Lee');      //new 运算符
box.name = 'Lee';                     //有效属性
box.age = function () {               //有效方法
    return 100;
};
alert(box);                          //Mr. Lee
alert(box.substring(2));             //. Lee
alert(typeof box);                   //object
alert(box.name);                     //Lee
alert(box.age());                    //100
</code></pre>

<p>以上字面量声明和 new 运算符声明很好的展示了他们之间的区别。但有一定还是可以 肯定的,那就是不管字面量形式还是 new 运算符形式,都可以使用它的内置方法。并 且 <code>Boolean</code> 和 <code>Number</code> 特性与 <code>String</code> 相同,三种类型可以成为基本包装类型。</p>

<p>PS:在使用 new 运算符创建以上三种类型的对象时,可以给自己添加属性和方法,但 我们建议不要这样使用,因为这样会导致根本分不清到底是基本类型值还是引用类型值。</p>

<h2>二、Boolean 类型</h2>

<p>Boolean 类型没有特定的属性或者方法。</p>

<h2>三、Number 类型</h2>

<p>Number 类型有一些静态属性(直接通过 <code>Number</code> 调用的属性,而无须 <code>new</code> 运算符)和方法。</p>

<p>Number 静态属性</p>

<pre><code>属性                   描述    
MAX_V ALUE            表示最大数    
MIN_V ALUE            表示最小值    
NaN                   非数值
NEGA TIVE_INFINITY    负无穷大,溢出返回该值
POSITIVE_INFINITY     无穷大,溢出返回该值
prototype             原型,用于增加新属性和方法
</code></pre>

<p>Number 对象的方法</p>

<pre><code>方法                    描述
toString()             将数值转化为字符串,并且可以转换进制
toLocaleString()       根据本地数字格式转换为字符串
toFixed()              将数字保留小数点后指定位数并转化为字符串
toExponential()        将数字以指数形式表示 ,保留小数点后指定位数并转化为 字符串
toPrecision()          指数形式或点形式表述数 ,保留小数点后面指定位数并转 化为字符串
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  var box = 1000.789;            
</span><span class='line'>  alert(box.toString());             //转换为字符串,传参可以转换进制 
</span><span class='line'>  alert(box.toLocaleString());       //本地形式, 1,000.789
</span><span class='line'>  alert(box.toFixed(2));             //小数点保留, 1000.78 
</span><span class='line'>  alert(box.toExponential());        //指数形式,传参会保留小数点
</span><span class='line'>  alert(box.toPrecision(3));         //指数或点形式,传参保留小数点</span></code></pre></td></tr></table></div></figure>


<h2>四、String 类型</h2>

<p><code>String</code> 类型包含了三个属性和大量的可用内置方法。</p>

<ul>
<li><p>String 对象属性</p>

<p>  属性                     描述
  length                  返回字符串的字符长度
  constructor             返回创建 String 对象的函数
  prototype               通过添加属性和方法扩展字符串定义</p></li>
</ul>


<p>String 也包含对象的通用方法,比如 <code>valueOf()</code>、<code>toLocaleString()</code>和 <code>toString()</code> 方法,但这 些方法都返回字符串的基本值。</p>

<ul>
<li><p>字符方法</p>

<p>  charAt(n)          返回指定索引位置的字符
  charCodeAt(n)      以 Unicode 编码形式返回指定索引位置的字符</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = 'Mr.Lee'; 
</span><span class='line'>alert(box.charAt(1));               //r
</span><span class='line'>alert(box.charCodeAt(1));           //114
</span><span class='line'>alert(box[1]);                      //r,通过数组方式截取</span></code></pre></td></tr></table></div></figure>


<p>PS: <code>box[1]</code> 在 IE 浏览器会显示 <code>undefined</code>,所以使用时要慎重。</p>

<ul>
<li><p>字符串操作方法</p>

<p>  concat(str1&hellip;str2)          将字符串参数串联到调用该方法的字符串
  slice(n,m)                   返回字符串 n 到 m 之间位置的字符串
  substring(n,m)               同上
  substr(n,m)                  返回字符串 n 开始的 m 个字符串</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = 'Mr.Lee';
</span><span class='line'>alert(box.concat(' is ', ' Teacher ', '!'));           //Mr.Lee is Teacher 
</span><span class='line'>alert(box.slice(3));                                   //Lee
</span><span class='line'>alert(box.slice(3,5));                                 //Le
</span><span class='line'>
</span><span class='line'>alert(box.substring(3));                               //Lee
</span><span class='line'>alert(box.substring(3,5));                             //Le
</span><span class='line'>alert(box.substr(3));                                  //Lee
</span><span class='line'>alert(box.substr(3,5));                                //Lee
</span><span class='line'>
</span><span class='line'>var box = 'Mr.Lee'; 
</span><span class='line'>alert(box.slice(-3));                //Lee,6+(-3)=3 位开始                          
</span><span class='line'>alert(box.substring(-3));            //Mr.Lee 负数返回全部
</span><span class='line'>alert(box.substr(-3));               //Lee,6+(-3)=3 位开始
</span><span class='line'>
</span><span class='line'>var box = 'Mr.Lee'; 
</span><span class='line'>alert(box.slice(3, -1));             //Le 6+(-1)=5, (3,5)
</span><span class='line'>alert(box.substring(3, -1));         //Mr. 第二参为负,直接转 0, 并且方法会把较小的数字提前, (0,3)
</span><span class='line'>alert(box.substr(3, -1));            //'' 第二参数为负,直接转 0 ,(3,0)
</span></code></pre></td></tr></table></div></figure>


<p>PS:IE 的 JavaScript 实现在处理向 substr()方法传递负值的情况下存在问题,它会返回 原始字符串,使用时要切记。</p>

<ul>
<li><p>字符串位置方法</p>

<p>  indexOf(str, n)        从 n 开始搜索的第一个 str,并将搜索的索引值返回
  lastIndexOf(str, n)    从 n 开始搜索的最后一个 str,并将搜索的索引值返回</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = 'Mr.Lee is Lee'; 
</span><span class='line'>alert(box.indexOf('L'));                  //3
</span><span class='line'>alert(box.indexOf('L', 5));               //10           
</span><span class='line'>alert(box.lastIndexOf('L'));              //10
</span><span class='line'>alert(box.lastIndexOf('L', 5));           //3,从指定的位置向前搜索</span></code></pre></td></tr></table></div></figure>


<p>PS:如果没有找到想要的字符串,则返回 -1。</p>

<p>示例:找出全部的 L</p>

<pre><code>var box = 'Mr.Lee is Lee';            //包含两个 L 的字符串
var boxarr = [];                      //存放 L 位置的数组 
var pos = box.indexOf('L');           //先获取第一个 L 的位置
while (pos &gt; -1) {                    //如果位置大于-1,说明还存在 L 
    boxarr.push(pos);                 //添加到数组
    pos = box.indexOf('L', pos + 1);  //从新赋值 pos 目前的位置
}
alert(boxarr);
</code></pre>

<ul>
<li><p>大小写转换方法</p>

<p>  var box = &lsquo;Mr.Lee is Lee&rsquo;;
  alert(box.toLowerCase());          //全部小写
  alert(box.toUpperCase());          //全部大写
  alert(box.toLocaleLowerCase());    //将字符串全部转换为小写,并且本地化
  alert(box.toLocaleUpperCase());    //将字符串全部转换为大写,并且本地化</p></li>
<li><p>字符串的模式匹配方法</p>

<p>  match(pattern)                    返回 pattern 中的子串或 null
  replace(pattern, replacement)     用 replacement 替换 pattern
  search(pattern)                   返回字符串中 pattern 开始位置
  split(pattern)                    返回字符串按指定 pattern 拆分的数组</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = 'Mr.Lee is Lee'; 
</span><span class='line'>alert(box.match('L'));             //找到 L,返回 L 否则返回 null 
</span><span class='line'>alert(box.search('L'));            //找到 L 的位置,和 indexOf 类型
</span><span class='line'>alert(box.replace('L', 'Q'));      //把 L 替换成 Q 
</span><span class='line'>alert(box.split(' '));             //以空格分割成字符串   </span></code></pre></td></tr></table></div></figure>


<ul>
<li>其他方法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 变量、作用域及内存]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/25/javascript-zhi-bian-liang-,-zuo-yong-yu-ji-nei-cun/"/>
    <updated>2015-10-25T00:40:04+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/25/javascript-zhi-bian-liang-,-zuo-yong-yu-ji-nei-cun</id>
    <content type="html"><![CDATA[<p>JavaScript 的变量与其他语言的变量有很大区别。 JavaScript 变量是松散型的 (不强制类 型)本质,决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个 变量必须要保存何种数据类型值的规则 ,变量的值及其数据类型可以在脚本的生命周期内改 变。</p>

<h3>一、变量及作用域</h3>

<p>1.基本类型和引用类型的值</p>

<p>ECMAScript 变量可能包含两种不同的数据类型的值:<code>基本类型值和引用类型值</code>。基本
类型值指的是那些保存在栈内存中的简单数据段,即这种值完全保存在内存中的一个位置 。 而引用类型值则是指那些保存在堆内存中的对象,意思是变量中保存的实际上只是一个指 针,这个指针指向内存中的另一个位置,该位置保存对象。</p>

<p>将一个值赋给变量时 ,解析器必须确定这个值是基本类型值 ,还是引用类型值 。基本类 型值有以下几种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>。这些类型在内存中分别占 有固定大小的空间,他们的值保存在栈空间,我们通过按值来访问的。</p>

<p>PS:在某些语言中,字符串以对象的形式来表示 ,因此被认为是引用类型 。ECMAScript 放弃这一传统。</p>

<p>如果赋值的是引用类型的值 ,则必须在堆内存中为这个值分配空间 。由于这种值的大小 不固定,因此不能把它们保存到栈内存中 。但内存地址大小的固定的 ,因此可以将内存地址 保存在栈内存中 。这样,当查询引用类型的变量时 ,先从栈中读取内存地址 ,然后再通过地 址找到堆中的值。对于这种,我们把它叫做<code>按引用访问</code>。</p>

<p>2.动态属性</p>

<p>定义基本类型值和引用类型值的方式是相似的:创建一个变量并为该变量赋值。但是 , 当这个值保存到变量中以后,对不同类型值可以执行的操作则大相径庭。</p>

<pre><code>var box = new Object();     //创建引用类型
box.name = 'Lee';           //新增一个属性 
alert(box.name);
</code></pre>

<p>如果是基本类型的值添加属性的话,就会出现问题了。</p>

<pre><code>var box = 'Lee';            //创建一个基本类型
box.age = 27;               //给基本类型添加属性
alert(box.age);             //undefined
</code></pre>

<!--more-->


<p>3.复制变量值</p>

<p>在变量复制方面 ,基本类型和引用类型也有所不同 。基本类型复制的是值本身 ,而引用 类型复制的是地址。</p>

<pre><code>var box = 'Lee';         //在栈内存生成一个 box 'Lee' 
var box2 = box;          //在栈内存再生成一个 box2 'Lee'
</code></pre>

<p>box2 是虽然是 box1 的一个副本,但从图示可以看出,它是完全独立的。也就是说 ,两 个变量分别操作时互不影响。</p>

<pre><code>var box = new Object();     //创建一个引用类型
box.name = 'Lee';           //新增一个属性
var box2 = box;             //把引用地址赋值给 box2
</code></pre>

<p>在引用类型中,box2 其实就是 box,因为他们指向的是同一个对象 。如果这个对象中的 name 属性被修改了,<code>box2.name</code> 和 <code>box.name</code>输出的值都会被相应修改掉了。</p>

<p>4.传递参数</p>

<p>ECMAScript 中所有函数的参数都是按值传递的,言下之意就是说,参数不会按引用传 递,虽然变量有基本类型和引用类型之分。</p>

<p>5.检测类型</p>

<p>要检测一个变量的类型,我们可以通过 typeof 运算符来判别。诸如:</p>

<pre><code>var box = 'Lee';
alert(typeof box);    //string
</code></pre>

<p>虽然 typeof 运算符在检查基本数据类型的时候非常好用 ,但检测引用类型的时候 ,它就 不是那么好用了 。通常,我们并不想知道它是不是对象 ,而是想知道它到底是什么类型的对 象。因为数组也是 object,null 也是 Object 等等。
这时我们应该采用 <code>instanceof</code> 运算符来查看。</p>

<p>PS:当使用 instanceof 检查基本类型的值时,它会返回 false。</p>

<p>待。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 Function类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/22/javascript-zhi-functionlei-xing/"/>
    <updated>2015-10-22T00:29:29+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/22/javascript-zhi-functionlei-xing</id>
    <content type="html"><![CDATA[<p>在 ECMAScript 中,Function(函数)类型实际上是对象。每个函数都是Function类型的实例,而且都与其他引用类型一样具有属性和方法 。由于函数是对象,因此函数名实际上也 是一个指向函数对象的指针。</p>

<h3>一、函数的声明方式</h3>

<ul>
<li>普通的函数声明</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box(num1, num2) { 
</span><span class='line'>  return num1+ num2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用变量初始化函数</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box= function(num1, num2) {
</span><span class='line'>  return num1 + num2; 
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用 Function 构造函数</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box= new Function('num1', 'num2' ,'return num1 + num2');</span></code></pre></td></tr></table></div></figure>


<p>PS: 第三种方式我们不推荐,因为这种语法会导致解析两次代码(第一次解析常 规 ECMAScript 代码,第二次是解析传入构造函数中的字符串 ),从而影响性能。但我们可以通 过这种语法来理解 &ldquo;函数是对象,函数名是指针 "的概念。</p>

<!--more-->


<h2>二、作为值的函数</h2>

<p>ECMAScript 中的函数名本身就是变量,所以函数也可以作为值来使用。也就是说,不 仅可以像传递参数一样把一个函数传递给另一个函数 ,而且可以将一个函数作为另一个函数 的结果返回。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box(sumFunction, num) { 
</span><span class='line'>  return sumFunction(num);              //Function
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function sum(num) { 
</span><span class='line'>  return num + 10;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var result = box(sum, 10);            //传递函数到另一个函数里</span></code></pre></td></tr></table></div></figure>


<h2>三、函数内部属性</h2>

<p>在函数内部,有两个特殊的对象: <code>arguments</code> 和 <code>this</code>. <code>arguments</code> 是一个类数组对象,包
含着传入函数中的所有参数 ,主要用途是保存函数参数 。但这个对象还有一个名叫 <code>callee</code> 的 属性,该属性是一个指针,指向拥有这个 <code>arguments</code> 对象的函数。</p>

<pre><code>function box(num) { 
    if (num &lt;= 1) {
        return 1; 
        } else {
            return num * box(num-1);          //一个简单的的递归
        } 
}
</code></pre>

<p>对于阶乘函数一般要用到递归算法 ,所以函数内部一定会调用自身 ;如果函数名不改变 是没有问题的,但一旦改变函数名,内部的自身调用需要逐一修改。为了解决这个问题 ,我 们可以使用 arguments.callee 来代替。</p>

<pre><code>function box(num) { 
    if (num &lt;= 1) {
        return 1; 
        } else {
            return num * arguments.callee(num-1);         //使用 callee 来执行自身 
        }
}
</code></pre>

<p>函数内部另一个特殊对象是 <code>this</code>, 其行为与 Java 和 C#中的 this 大致相似。换句话说, this 引用的是函数据以执行操作的对象 ,或者说函数调用语句所处的那个作用域 。PS:当在 全局作用域中调用函数时, <code>this</code> 对象引用的就是 <code>window。</code></p>

<p>//便于理解的改写例子</p>

<pre><code>window.color = '红色的';            //全局的,或者 var color = '红色的';也行 
    alert(this.color);             //打印全局的 color
var box = {
    color : '蓝色的',               //局部的 color
    sayColor : function () { 
    alert(this.color);             //此时的 this 只能 box 里的 color
    } 
};
box.sayColor();                    //打印局部的 color
alert(this.color);                  //还是全局的
</code></pre>

<h2>四、函数属性和方法</h2>

<p>ECMAScript 中的函数是对象,因此函数也有属性和方法。每个函数都包含两个属性 : <code>length</code> 和 <code>prototype</code>。其中,<code>length</code>属性表示函数希望接收的命名参数的个数。</p>

<pre><code>function box(name, age) { 
    alert(name + age);
}
alert(box.length);     //2
</code></pre>

<p>PS:对于 <code>prototype</code> 属性,它是保存所有实例方法的真正所在 ,也就是原型。这个属性, 我们将在面向对象一章详细介绍 。而 <code>prototype</code> 下有两个方法:<code>apply()</code>和 <code>call()</code>,每个函数都 包含这两个非继承而来的方法 。这两个方法的用途都在特定的作用域中调用函数 ,实际上等 于设置函数体内 <code>this</code> 对象的值。</p>

<pre><code>function box(num1, num2) {           //原函数
    return num1 + num2;
}

function sayBox(num1, num2) {
    return box.apply(this, [num1, num2]);          //this 表示作用域,这里是 window ,[]表示 box 所需要的参数
}

function sayBox2(num1, num2) { 
    return box.apply(this, arguments);             //arguments 对象表示 box 所需要的参数
}

alert(sayBox(10,10));                             //20
alert(sayBox2(10,10));                            //20
</code></pre>

<p><code>call()</code> 方法于 <code>apply()</code> 方法相同,他们的区别仅仅在于接收参数的方式不同 。对于 <code>call()</code> 方 法而言,第一个参数是作用域,没有变化,变化只是其余的参数都是直接传递给函数的。</p>

<p>待续</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 对象和数组]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu/"/>
    <updated>2015-10-20T22:19:20+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu</id>
    <content type="html"><![CDATA[<p>什么是对象,其实就是一种类型,即引用类型。而对象的值就是引用类型的实例。 在 ECMAScript 中引用类型是一种数据结构,用于将数据和功能组织在一起。它也常被称做为 类,但 ECMAScript 中却没有这种东西。虽然 ECMAScript 是一门面向对象的语言,却不具 备传统面向对象语言所支持的类和接口等基本结构。</p>

<h3>一、Object 类型</h3>

<p>到目前为止,我们使用的引用类型最多的可能就是 Object 类型了。虽然 Object 的实例
不具备多少功能,但对于在应用程序中的存储和传输数据而言,它确实是非常理想的选择 。 创建 Object 类型有两种。一种是使用 new 运算符,一种是字面量表示法。</p>

<p>1.使用 new 运算符创建 Object</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = new Object();     //new 方式    new 关键字可以省略
</span><span class='line'>box.name = 'amy';           //创建属性字段 
</span><span class='line'>box.age = 28;               //创建属性字段</span></code></pre></td></tr></table></div></figure>


<p>2.使用字面量方式创建 Object</p>

<pre><code>var box = {              //字面量方式
    name : '李',         //创建属性字段
    age : 28 
};
</code></pre>

<!--more-->


<p>3.属性字段也可以使用字符串形式</p>

<pre><code>var box = {
    'name' : '李炎恢',             //也可以用字符串形式
    'age' : 28 
};
</code></pre>

<p>4.使用字面量及传统附值方式</p>

<pre><code>var box = {};                     //字面量方式声明空的对象
box.name = '李炎恢';               //点符号给属性付值
box.age = 28;
</code></pre>

<p>5.两种属性输出方式</p>

<pre><code>alert(box.age);                   //点 表示法输出
alert(box['age']);                //中括号表示法输出,注意引号不能省
</code></pre>

<p>6.给对象创建方法</p>

<pre><code>var box = {
    run : function () {           //对象中的方法
    return '运行';
    } 
}
alert(box.run());                 //调用对象中的方法
</code></pre>

<p>7.使用 delete 删除对象属性</p>

<pre><code>delete box.name;                 //删除属性
</code></pre>

<p>在实际开发过程中,一般我们更加喜欢字面量的声明方式。因为它清晰,语法代码少 , 而且还给人一种封装的感觉。字面量也是向函数传递大量可选参数的首选方式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box(obj) {                                 //参数是一个对象
</span><span class='line'>  if (obj.name != undefined) alert(obj.name);     //判断属性是否存在
</span><span class='line'>  if (obj.age != undefined) alert(obj.age);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>box({                                    //调用函数传递一个对象
</span><span class='line'>  name : '李炎恢',
</span><span class='line'>  age : 28 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>二、Array 类型</h2>

<p>除了 Object 类型之外,Array 类型是 ECMAScript 最常用的类型。而且 ECMAScript 中
的 Array 类型和其他语言中的数组有着很大的区别 。虽然数组都是有序排列 ,但 ECMAScript 中的数组每个元素可以保存任何类型。 ECMAScript 中数组的大小也是可以调整的。</p>

<p>创建 Array 类型有两种方式:第一种是 new 运算符,第二种是字面量。</p>

<p>1.使用 new 关键字创建数组</p>

<pre><code>var box = new Array();                              //创建了一个数组           
var box = new Array(10);                            //创建一个包含 10 个元素的数组
var box = new Array('李',28,'教师','盐城');          //创建一个数组并分配好了元素   都可以省略 new 关键字
</code></pre>

<p>2.使用字面量方式创建数组</p>

<pre><code>var box = [];                           //创建一个空的数组
var box = ['李',28,'教师','盐城'];       //创建包含元素的数组
var box = [1,2,];                      //禁止这么做,IE 会识别 3 个元素   最后的逗号要删掉
var box = [,,,,,];                     //同样,IE 的会有识别问题
</code></pre>

<p>3.使用索引下标来读取数组的值</p>

<pre><code>alert(box[2]);              //获取第三个元素
box[2] = '学生';             //修改第三个元素 
box[4] = '计算机编程';        //增加第五个元素
</code></pre>

<p>4.使用 <code>length</code> 属性获取数组元素量</p>

<pre><code>alert(box.length)               //获取元素个数
box.length = 10;                //强制给元素个数
box[box.length] = 'JS 技术';     //通过 length 给数组最后面增加一个元素
</code></pre>

<p>5.创建一个稍微复杂一点的数组</p>

<pre><code>var box = [             

            {                                     //第一个元素是一个对象
            name : '李炎恢', age : 28,
            run : function () {
            return 'run 了'; 
                }
            },
            ['马云','李彦宏',new Object()],        //第二个元素是数组
            '江苏',                               //第三个元素是字符串 
            25+25,                               //第四个元素是数值
            new Array(1,2,3)                     //第五个元素是数组

        ]; 

    alert(box);
</code></pre>

<p>PS:数组最多可包含 4294967295 个元素,超出即会发生异常。</p>

<h2>三、对象中的方法</h2>

<p>转换方法</p>

<p>对象或数组都具有 <code>toLocaleString()</code> <code>toString()</code>和 <code>valueOf()</code> 方法。其中 <code>toString()</code> 和 <code>valueOf()</code> 重写了谁,都会返回相同的值。数组会将每个值进行字符串形式的拼接以逗号隔开 。</p>

<pre><code>var box = ['李',28,'计算机编程'];             //字面量数组 
alert(box);                                    //隐式调用了 toString() 
alert(box.toString());                         //和 valueOf()返回一致
alert(box.toLocaleString());                   //返回值和上面两种一致
</code></pre>

<p>默认情况下,数组字符串都会以逗号隔开。如果使用 <code>join()</code> 方法,则可以使用不同的分 隔符来构建这个字符串。</p>

<pre><code>var box = ['李', 28, '计算机编程'];
alert(box.join('|'));                       //李炎恢|28|计算机编程
</code></pre>

<p>栈方法</p>

<p>ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法。也就是说,可以让数组像栈一样,可以限制插入和删除项的数据结构。栈是一种数据结构 (后进先出),也 就是说最新添加的元素最早被移除。而栈中元素的插入 (或叫推入)和移除(或叫弹出),只发 生在一个位置——栈的顶部。ECMAScript 为数组专门提供了 <code>push()</code>和 <code>pop()</code> 方法。</p>

<p><code>push()</code> 方法可以接收任意数量的参数 ,把它们逐个添加到数组的末尾 ,并返回修改后数 组的长度。而 <code>pop()</code> 方法则从数组末尾移除最后一个元素,减少数组的 <code>length</code> 值,然后返回 移除的元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = ['李', 28, '计算机编程'];               //字面量声明
</span><span class='line'>alert(box.push(' 盐城'));                           //数组末尾添加一个元素 ,并且返回长度 
</span><span class='line'>alert(box);                                        //查看数组
</span><span class='line'>box.pop();                                         //移除数组末尾元素 ,并返回移除的元素 
</span><span class='line'>alert(box);                                        //查看元素</span></code></pre></td></tr></table></div></figure>


<p>队列方法</p>

<p>栈方法是后进先出 ,而列队方法就是先进先出 。列队在数组的末端添加元素 ,从数组的 前端移除元素。通过 <code>push()</code>向数组末端添加一个元素,然后通过 <code>shift()</code> 方法从数组前端移除 一个元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = ['李', 28, '计算机编程'];                    //字面量声明
</span><span class='line'>alert(box.push(' 盐城'));                             //数组末尾添加一个元素 ,并且返回长度
</span><span class='line'>alert(box);
</span><span class='line'>alert(box.shift());                                  //移除数组开头元素 ,并返回移除的元素 
</span><span class='line'>alert(box);</span></code></pre></td></tr></table></div></figure>


<p>ECMAScript 还为数组提供了一个 <code>unshift()</code> 方法,它和 <code>shift()</code> 方法的功能完全相反。 <code>unshift()</code>方法为数组的前端添加一个元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = ['李炎恢', 28, '计算机编程'];            //字面量声明
</span><span class='line'>alert(box.unshift('盐城','江苏'));                //数组开头添加两个元素
</span><span class='line'>alert(box);
</span><span class='line'>alert(box.pop());                                //移除数组末尾元素 ,并返回移除的元素 /
</span><span class='line'>alert(box);</span></code></pre></td></tr></table></div></figure>


<p>PS:IE 浏览器对 unshift()方法总是返回 undefined 而不是数组的新长度。</p>

<p>重排序方法</p>

<p>数组中已经存在两个可以直接用来排序的方法: <code>reverse()</code> 和 <code>sort()</code> 。</p>

<p><code>reverse()</code> 逆向排序</p>

<pre><code>var box = [1,2,3,4,5];              //数组 
alert(box.reverse());               //逆向排序方法,返回排序后的数组 
alert(box);                         //源数组也被逆向排序了,说明是引用
</code></pre>

<p>sort() 从小到大排序</p>

<pre><code>var box = [4,1,7,3,9,2];               //数组
alert(box.sort());                     //从小到大排序,返回排序后的数组 
alert(box);                             //源数组也被从小到大排序了
</code></pre>

<p>sort 方法的默认排序在数字排序上有些问题 ,因为数字排序和数字字符串排序的算法是 一样的。我们必须修改这一特征,修改的方式,就是给 sort(参数)方法传递一个函数参数。 这点可以参考手册说明。</p>

<pre><code>function compare(value1, value2) {            //数字排序的函数参数 
    if (value1 &lt; value2) {                    //小于,返回负数
            return -1;
        } else if (value1 &gt; value2) {         //大于,返回正数
        return 1; } else {
            return 0;                         //其他,返回 0
        }
        }
var box = [0,1,5,10,15];                      //验证数字字符串,和数字的区别
alert(box.sort(compare));                     //传参
</code></pre>

<p>操作方法</p>

<p>ECMAScript 为操作已经包含在数组中的元素提供了很多方法 。<code>concat()</code>方法可以基于当 前数组创建一个新数组。<code>slice()</code>方法可以基于当前数组获取指定区域元素并创建一个新数组 。 <code>splice()</code>主要用途是向数组的中部插入元素。</p>

<pre><code>var box = ['李', 28, '盐城'];                       //当前数组 
var box2 = box.concat('计算机编程');                //创建新数组,并添加新元素 
alert(box2);                                      //输出新数组 
alert(box);                                       //当前数组没有任何变化

var box = ['李', 28, '盐城'];                      //当前数组
var box2 = box.slice(1);                          //box.slice(1,3) ,2-4 之间的元素
alert(box2);                                      //28,盐城
alert(box);                                       //当前数组
</code></pre>

<p> splice 中的删除功能:</p>

<pre><code>var box = ['李', 28, '盐城'];                  //当前数组
var box2 = box.splice(0,2);                      //截取前两个元素 
alert(box2);                                     //返回截取的元素 
alert(box);                                      //当前数组被截取的元素被删除
</code></pre>

<p>splice 中的插入功能:</p>

<pre><code>var box = ['李', 28, '盐城'];
var box2 = box.splice(1,0,'计算机编程','江苏');         //没有截取,但插入了两条    
alert(box2);                                          //在第 2 个位置插入两条
alert(box);
</code></pre>

<p>splice 中的替换功能:</p>

<pre><code>var box = ['李', 28, '盐城']; 
var box2 = box.splice(1,1,100);                  //截取了第 2 条,替换成 100
alert(box2);                                     //输出截取的 28
alert(box);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 函数]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/18/javascrhan-shu/"/>
    <updated>2015-10-18T21:15:57+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/18/javascrhan-shu</id>
    <content type="html"><![CDATA[<h3>一、函数声明</h3>

<p>函数对任何语言来说都是一个核心的概念 。通过函数可以封装任意多条语句 ,而且可以 在任何地方、任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明,后跟 一组参数以及函数体。</p>

<pre><code>function box() {                              //没有参数的函数 
    alert('只有函数被调用,我才会被之执行 ');
} box();                                      //直接调用函数

function box(name, age) {                     //带参数的函数
    alert('你的姓名:'+name+',年龄:'+age);
}
box('李',28);                                 //调用函数,并传参
</code></pre>

<h2>二、return 返回值</h2>

<p>带参和不带参的函数 ,都没有定义返回值 ,而是调用后直接执行的 。实际上,任何函数 都可以通过 return 语句跟后面的要返回的值来实现返回值。</p>

<!--more-->


<pre><code>function box() {                     //没有参数的函数
    return '我被返回了!';             //通过 return 把函数的最终值返回
} 
alert(box());                       //调用函数会得到返回值 ,然后外面输出


function box(name, age) {                      //有参数的函数
    return '你的姓名:'+name+',年龄:'+age;        //通过 return 把函数的最终值返回
}
alert(box('李炎恢', 28));                       /调用函数得到返回值,然后外面输出
</code></pre>

<p>我们还可以把函数的返回值赋给一个变量,然后通过变量进行操作。</p>

<pre><code>function box(num1, num2) { 
    return num1 * num2;
}
var num = box(10, 5); //函数得到的返回值赋给变量 
alert(num);
</code></pre>

<p><code>return</code> 语句还有一个功能就是退出当前函数 ,注意和 <code>break</code> 的区别。PS: <code>break</code> 用在循环 和 <code>switch</code> 分支语句里。</p>

<pre><code>function box(num) {
    if (num &lt; 5) return num;            //满足条件,就返回 num
    return 100;                         //返回之后,就不执行下面的语句了
} alert(box(10));
</code></pre>

<h2>三、arguments 对象</h2>

<p>ECMAScript 函数不介意传递进来多少参数,也不会因为参数不统一而错误。实际上, 函数体内可以通过 arguments 对象来接收传递进来的参数。</p>

<pre><code>function box() {
    return arguments[0]+' | '+arguments[1];           //得到每次参数的值
}
alert(box(1,2,3,4,5,6));                              //传递参数
</code></pre>

<p>arguments 对象的 length 属性可以得到参数的数量。</p>

<pre><code>function box() {
    return arguments.length;            //得到 6
    }
alert(box(1,2,3,4,5,6));
</code></pre>

<p>我们可以利用 <code>length</code> 这个属性,来智能的判断有多少参数 ,然后把参数进行合理的应用 。 比如,要实现一个加法运算,将所有传进来的数字累加,而数字的个数又不确定。</p>

<pre><code>function box() { 
var sum = 0;
    if (arguments.length == 0) return sum;                //如果没有参数,退出
    for(var i = 0;i &lt; arguments.length; i++) {            //如果有,就累加
    sum = sum + arguments[i]; 
    }
return sum;                                               //返回累加结果
}
alert(box(5,9,12));
</code></pre>

<p>ECMAScript 中的函数,没有像其他高级语言那种函数重载功能。</p>

<pre><code>function box(num) {
    return num + 100; 
}

function box (num) {              //会执行这个函数
    return num + 200;             //返回结果
} 
alert(box(50));
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 流程控制语句]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/18/javascript-zhi-liu-cheng-kong-zhi-yu-ju/"/>
    <updated>2015-10-18T20:41:18+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/18/javascript-zhi-liu-cheng-kong-zhi-yu-ju</id>
    <content type="html"><![CDATA[<h3>一、语句的定义</h3>

<p>语句的种类</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>声明语句   变量声明语句   var box = 100;
</span><span class='line'>          标签声明语句   label : box;
</span><span class='line'>
</span><span class='line'>达式语句   变量赋值语句    box = 100;
</span><span class='line'>          函数调用语句    box();
</span><span class='line'>          属性赋值语句    box.property = 100;
</span><span class='line'>          方法调用语句    box.method();
</span><span class='line'>
</span><span class='line'>分支语句   条件分支语句    if () {} else {}
</span><span class='line'>          多重分支语句    switch () { case n : ...};</span></code></pre></td></tr></table></div></figure>


<p>语句的种类 (续)</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>循环语句       for            for (;;;) {}
</span><span class='line'>              for ... in     for ( x in x) {}
</span><span class='line'>              while          while () {};
</span><span class='line'>              do ... while   do {} while ();
</span><span class='line'>
</span><span class='line'>控制结构       继续执行子句     continue ;
</span><span class='line'>              终断执行子句     break ;
</span><span class='line'>              函数返回子句     return ;
</span><span class='line'>              异常触发子句     throw ;
</span><span class='line'>              异常捕获与处理    try {} catch () {} finally {}
</span><span class='line'>
</span><span class='line'>其他           空语句          ;
</span><span class='line'>               with 语句      with () {}</span></code></pre></td></tr></table></div></figure>


<h3>二、if 语句</h3>

<p>略</p>

<h2>三、switch 语句</h2>

<p>switch 语句是多重条件判断,用于多个值相等的比较。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = 1;
</span><span class='line'>switch (box) {                        //用于判断 box 相等的多个值
</span><span class='line'>  case 1 : 
</span><span class='line'>      alert('one');
</span><span class='line'>      break;                        //break;用于防止语句的穿透
</span><span class='line'>  case 2 :
</span><span class='line'>      alert('two');
</span><span class='line'>      break; 
</span><span class='line'>  case 3 :
</span><span class='line'>      alert('three'); 
</span><span class='line'>      break;
</span><span class='line'>      default :                    //相当于 if 语句里的 else,否则的意思 
</span><span class='line'>      alert('error');
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>四、do&hellip;while 语句</h2>

<p>do&hellip;while 语句是一种先运行,后判断的循环语句。也就是说,不管条件是否满足,至少先运行一次循环体。</p>

<pre><code>var box = 1;       //如果是 1,执行五次,如果是 10,执行 1 次     
do {
    alert(box);
    box++;
} while (box &lt;= 5);   //先运行一次,再判断
</code></pre>

<h2>五、while 语句</h2>

<p>while 语句是一种先判断,后运行的循环语句。也就是说,必须满足条件了之后,方可运行循环体。</p>

<pre><code>var box = 1;        //如果是 1,执行五次,如果是 10,不执行 
while (box &lt;= 5) {  //先判断,再执行
    alert(box);
    box++; 
}
</code></pre>

<h2>六、for 语句</h2>

<p>for 语句也是一种先判断,后运行的循环语句。但它具有在执行循环之前初始变量和定义循环后要执行代码的能力。</p>

<pre><code>for (var box = 1; box &lt;= 5 ; box++) {     //第一步,声明变量 var box = 1;
    alert(box);                           //第二步,判断 box &lt;=5
}                                         //第三步,alert(box)
                                          //第四步,box++ //第五步,从第二步再来,直到判断为 false
</code></pre>

<h2>七、 for&hellip;in 语句</h2>

<p>for&hellip;in 语句是一种精准的迭代语句,可以用来枚举对象的属性。</p>

<pre><code>var box = {                         //创建一个对象 
    'name' : '李炎恢',               //键值对,左边是属性名,右边是值
    'age' : 28,
    'height' : 178 };
for (var p in box) {                //列举出对象的所有属性
    alert(p);
</code></pre>

<h2>八、break 和 continue 语句</h2>

<p>break 和 continue 语句用于在循环中精确地控制代码的执行 。其中,break 语句会立即退出循环,强制继续执行循环体后面的语句 。而 continue 语句退出当前循环,继续后面的循环。</p>

<pre><code>for (var box = 1; box &lt;= 10; box++) {
    if (box == 5) break;                //如果 box 是 5,就退出循环
    document.write(box); 
    document.write('&lt;br /&gt;');
}
</code></pre>

<p>continue</p>

<pre><code>for (var box = 1; box &lt;= 10; box++) { 
    if (box == 5) continue;      //如果 box 是 5,就退出当前循环
    document.write(box); 
    document.write('&lt;br /&gt;');
}
</code></pre>

<h2>九、with 语句</h2>

<p>with 语句的作用是将代码的作用域设置到一个特定的对象中。</p>

<pre><code>var box = {                  //创建一个对象 
    'name' : '李炎恢',        //键值对
    'age' : 28,
    'height' : 178 
};
var n = box.name;            //从对象里取值赋给变量
var a = box.age; 
var h = box.height;
</code></pre>

<p>可以将上面的三段赋值操作改写成:</p>

<pre><code>with (box) {                 //省略了 box 对象名   
    var n = name;           
    var a = age;            
    var h = height;         
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 运算符]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-yun-suan-fu/"/>
    <updated>2015-10-17T23:31:08+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-yun-suan-fu</id>
    <content type="html"><![CDATA[<h3>一、什么是表达式</h3>

<p>表达式是 ECMAScript 中的一个“短语”,解释器会通过计算把它转换成一个值。最简 单的表达式是字面量或者变量名。例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5.96                           //数值字面量
</span><span class='line'>'Lee'                          //字符串字面量
</span><span class='line'>true                           //布尔值字面量 
</span><span class='line'>null                           //空值字面量
</span><span class='line'>/Java/                         //正则表达式字面量
</span><span class='line'>{x:1, y:2}                     //对象字面量、对象表达式
</span><span class='line'>[1,2,3]                        //数组字面量、数组表达式
</span><span class='line'>function(n) {return x+y;}      //函数字面量、函数表达式
</span><span class='line'>box                            //变量</span></code></pre></td></tr></table></div></figure>


<p>    <br/>
当然,还可以通过合并简单的表达式来创建复杂的表达式。比如:</p>

<pre><code>box + 5.96      //加法运算的表达式
typeof(box)     //查看数据类型的表达式
box &gt; 8         //逻辑运算表达式
</code></pre>

<p>通过上面的叙述,我们得知,单一的字面量和组合字面量的运算符都可称为表达式。</p>

<h2>二、一元运算符</h2>

<p>只能操作一个值的运算符叫做一元运算符。</p>

<p>1.递增++和递减- -</p>

<pre><code>var box = 100;
++box; //把 box 累加一个 1,相当于 box = box+1 
--box; //把 box 累减一个 1,相当于 box = box-1
box++; //同上
box--; //同上
</code></pre>

<!--more-->


<p>2.前置和后置的区别</p>

<p>在没有赋值操作 ,前置和后置是一样的 。但在赋值操作时 ,如果递增或递减运算符前置 , 那么前置的运算符会先累加或累减再赋值,如果是后置运算符则先赋值再累加或累减。</p>

<pre><code>var box = 100;
var age = ++box;     //age 值为 101 
var height = box++;  //height 值为 100
</code></pre>

<p>3.其他类型应用一元运算符的规则</p>

<pre><code>var box = '89'; box++;                 //90,数值字符串自动转换成数值              
var box = 'ab'; box++;                 //NaN,字符串包含非数值转成 NaN
var box = false; box++;                //1,false 转成数值是 0,累加就是 1
var box = 2.3; box++;                  //3.3,直接加 1
var box = {                            //1,不设置 toString 或 valueOf 即为 NaN
    toString : function() { 
    return 1;
}
box++;
}
</code></pre>

<p>4.加和减运算符</p>

<p>加运算规则如下:(其实就是取正)</p>

<pre><code>var box = 100; +box;              //100,对于数值,不会产生任何影响 
var box = '89'; +box;             //89,数值字符串转换成数值
var box = 'ab'; +box;             //NaN,字符串包含非数值转成 NaN 
var box = false; +box;            //0,布尔值转换成相应数值 
var box = 2.3; +box;              //2.3,没有变化
var box = {                       //1,不设置 toString 或 valueOf 即为 NaN
    toString : function() { 
    return 1;
};
};
+box;
</code></pre>

<p>减运算规则如下:(其实就是取负)</p>

<pre><code>var box = 100; －box;              //－100,对于数值,不会产生任何影响 
var box = '89'; －box;             //－89,数值字符串转换成数值
var box = 'ab'; －box;             //NaN,字符串包含非数值转成 NaN 
var box = false; －box;            //0,布尔值转换成相应数值 
var box = 2.3; －box;              //－2.3,没有变化
var box = {                       //－1,不设置 toString 或 valueOf 即为 NaN
    toString : function() { 
    return 1;
};
};
－box;
</code></pre>

<p>加法和减法运算符一般用于算术运算,也可向上面进行类型转换。</p>

<h2>三、算术运算符</h2>

<p>ECMAScript 定义了 5 个算术运算符,加减乘除求模 (取余)。如果在算术运算的值不是 数值,那么后台会先使用 Number()转型函数将其转换为数值(隐式转换)。</p>

<pre><code>var box = 1 + 2;                              //等于 3
var box = 1 + NaN;                            //NaN,只要有一个 NaN 就为 NaN
var box = Infinity + -Infinity;               //NaN,正无穷和负无穷相加等 NaN
var box = 100 + '100';                        //100100,字符串连接符,有字符串就不是加法
var box = '您的年龄是:' + 10 + 20;             //您的年龄是:1020,被转换成字符串
var box = 10 + 20 + '是您的年龄';              //30 是您的年龄,没有被转成字符串
var box = '您的年龄是:' + (10 + 20);           //您的年龄是:30,没有被转成字符串
varbox=10+ 对象                //10[object Object],如果有 toString()或 valueOf() 则返回 10+返回数的值

var box = 100 - true;             //99,true 转成数值为 1 
var box = 100 - '';               //100,''转成了 0
var box = 100 - null;             //100,null 转成了 0
var box = 100 - 'Lee';            //NaN,Lee 转成了 NaN
varbox=100- 对象                   //NaN,如果有 toString()或 valueOf()则返回 10-返回数的值

...
</code></pre>

<h2>四、关系运算符</h2>

<p>用于进行比较的运算符称作为关系运算符:小于 (&lt;)、大于(>)、小于等于(&lt;=)、大于等于(>=)、相等(==)、不等(!=)、全等(恒等)(===)、不全等(不恒等)(!==)</p>

<p>和其他运算符一样,当关系运算符操作非数值时要遵循一下规则:</p>

<p>1.两个操作数都是数值,则数值比较;<br/>
2.两个操作数都是字符串,则比较两个字符串对应的字符编码值; <br/>
3.两个操作数有一个是数值,则将另一个转换为数值,再进行数值比较; <br/>
4.两个操作数有一个是对象,则先调用 valueOf()方法或 toString()方法,再用结果比较;</p>

<pre><code>var box = 3 &gt; 2;          //true
var box = 3 &gt; 22;         //false
var box = '3' &gt; 22;       //false
var box = '3' &gt; '22';     //true
var box = 'a' &gt; 'b';      //false
var box = 'a' &gt; 'B';      //true B=66
var box = 1 &gt; 对象;        //false,如果有 toString()或 valueOf()则返回 1 &gt; 返回数的值
</code></pre>

<p>在相等和不等的比较上,如果操作数是非数值,则遵循一下规则:</p>

<p>1.一个操作数是布尔值,则比较之前将其转换为数值, <code>false</code> 转成 <code>0</code> , <code>true</code> 转成 <code>1</code> ; <br/>
2.一个操作数是字符串,则比较之前将其转成为数值再比较; <br/>
3.一个操作数是对象,则先调用 <code>valueOf()</code> 或 <code>toString()</code> 方法后再和返回值比较; <br/>
4.不需要任何转换的情况下, <code>null</code> 和 <code>undefined</code> 是相等的;<br/>
5.一个操作数是 NaN,则==返回 false,!=返回 true;并且 NaN 和自身不等;<br/>
6.两个操作数都是对象 ,则比较他们是否是同一个对象 ,如果都指向同一个对象 ,则返 回 <code>true</code> ,否则返回 <code>false</code> 。<br/>
7.在全等和全不等的判断上,比如值和类型都相等,才返回 <code>true</code> ,否则返回 <code>false</code>。</p>

<h2>五、逻辑运算符</h2>

<p>逻辑运算符通常用于布尔值的操作,一般和关系运算符配合使用,有三个逻辑运算符 :
逻辑与 &amp;&amp; (AND)、逻辑或 || (OR)、逻辑非 ! (NOT)。</p>

<p>1.逻辑与(AND) :&amp;&amp;</p>

<pre><code>var box = (5 &gt; 4) &amp;&amp; (4 &gt; 3) //true,两边都为 true,返回 
</code></pre>

<p>如果两边的操作数有一个操作数不是布尔值的情况下,与运算就不一定返回布尔值 ,此 时,遵循已下规则:</p>

<p>1.第一个操作数是对象,则返回第二个操作数; <br/>
2.第二个操作数是对象,则第一个操作数返回 true,才返回第二个操作数,否则返回 false; <br/>
3.有一个操作数是 null,则返回 null;<br/>
4.有一个操作数是 undefined,则返回 undefined。</p>

<pre><code>var box = 对象 &amp;&amp; (5 &gt; 4);      //true,返回第二个操作数
var box = (5 &gt; 4) &amp;&amp; 对象;      //[object Object]
var box = (3 &gt; 4) &amp;&amp; 对象;      //false
var box = (5 &gt; 4) &amp;&amp; null;     //null
</code></pre>

<p>逻辑与运算符属于短路操作,顾名思义,如果第一个操作数返回是 false,第二个数不 管是 true 还是 false 都返回的 false。</p>

<pre><code>var box = true &amp;&amp; age;            //出错,age 未定义 
var box = false &amp;&amp; age;           //false,不执行 age 了
</code></pre>

<p>2.逻辑或(OR):||</p>

<p>如果两边的操作数有一个操作数不是布尔值的情况下,逻辑与运算就不一定返回布尔 值,此时,遵循已下规则:</p>

<p>1.第一个操作数是对象,则返回第一个操作数;<br/>
2.第一个操作数的求值结果为 false,则返回第二个操作数;<br/>
3.两个操作数都是对象,则返回第一个操作数; <br/>
4.两个操作数都是 null,则返回 null;<br/>
5.两个操作数都是 NaN,则返回 NaN; <br/>
6.两个操作数都是 undefined,则返回 undefined;</p>

<pre><code>var box = 对象 || (5 &gt; 3);          //[object Object]
varbox=(5&gt;3)|| 对象;                //true
var box = 对象 1 || 对象 2;          //[object Object]1
var box = null || null;             //null
var box = NaN || NaN;               //NaN
var box = undefined || undefined;   //undefined
</code></pre>

<p>3.逻辑非(NOT):!</p>

<p>逻辑非运算符可以用于任何值 。无论这个值是什么数据类型 ,这个运算符都会返回一个 布尔值。它的流程是:先将这个值转换成布尔值,然后取反,规则如下:</p>

<p>1.操作数是一个对象,返回 false;  <br/>
2.操作数是一个空字符串,返回 true; <br/>
3.操作数是一个非空字符串,返回 false; <br/>
4.操作数是数值 0,返回 true; <br/>
5.操作数是任意非 0 数值(包括 Infinity),false; <br/>
6.操作数是 null,返回 true;
7.操作数是 NaN,返回 true; <br/>
8.操作数是 <code>undefined</code>,返回 <code>true</code>;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = !(5 &gt; 4);       //false
</span><span class='line'>var box = !{};            //false
</span><span class='line'>var box = !'';            //true
</span><span class='line'>var box = !'Lee';         //false
</span><span class='line'>var box = !0;             //true
</span><span class='line'>var box = !8;             //false
</span><span class='line'>var box = !null;          //true      
</span><span class='line'>var box = !NaN;           //true
</span><span class='line'>var box = !undefined;     //true</span></code></pre></td></tr></table></div></figure>


<p>三元条件运算符</p>

<p>三元条件运算符其实就是后面将要学到的 if 语句的简写形式。</p>

<pre><code>var box = 5 &gt; 4 ? '对' : '错';       //对,5&gt;4 返回 true 则把'对'赋值给 box,反之。
</code></pre>

<p>相当于:</p>

<pre><code>var box = ''; 
if (5 &gt; 4) {
    box = '对'; 
} else {
    box = '错';
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 数据类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-shu-ju-lei-xing/"/>
    <updated>2015-10-17T23:23:46+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/17/javascript-zhi-shu-ju-lei-xing</id>
    <content type="html"><![CDATA[<p>ECMAScript 中有 5 种简单数据类型:<code>Undefined、Null、Boolean、Number 和 String。</code> 还有一种复杂数据类型——<code>Object</code>。ECMAScript 不支持任何创建自定义类型的机制,所有 值都成为以上 6 中数据类型之一。</p>

<h3>一、typeof 操作符</h3>

<p><code>typeof</code> 操作符是用来检测变量的数据类型 。对于值或变量使用 <code>typeof</code> 操作符会返回如下字符串。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>undefined  未定义
</span><span class='line'>boolean    布尔值
</span><span class='line'>string     字符串
</span><span class='line'>number     数值
</span><span class='line'>object     对象或 null
</span><span class='line'>function   函数</span></code></pre></td></tr></table></div></figure>


<p>typeof 操作符可以操作变量,也可以操作字面量。虽然也可以这样使用: typeof(box), 但,typeof 是操作符而非内置函数。PS:函数在 ECMAScript 中是对象,不是一种数据类型。 所以,使用 typeof 来区分 function 和 object 是非常有必要的。</p>

<pre><code>alert(typeof box);
</code></pre>

<!--more-->


<h2>二、Undefined 类型</h2>

<p><code>Undefined</code> 类型只有一个值,即特殊的 undefined。在使用 var 声明变量,但没有对其初 始化时,这个变量的值就是 <code>undefined</code> 。</p>

<pre><code>var box; 
alert(box);
</code></pre>

<p>PS:我们没有必要显式的给一个变量赋值为 <code>undefined</code> ,因为没有赋值的变量会隐式的 (自动的)赋值为 <code>undefined</code> ;而 <code>undefined</code> 主要的目的是为了用于比较 ,ECMAScript 第 3 版之 前并没有引入这个值,引入之后为了正式区分空对象与未经初始化的变量。</p>

<p>未初始化的变量与根本不存在的变量 (未声明的变量)也是不一样的。</p>

<pre><code>var box;
alert(age); //age is not defined
</code></pre>

<p>PS : 如果 <code>typeof box,typeof age</code> 都返回的 undefined。从逻辑上思考,他们的值,一个 是 undefined,一个报错;他们的类型,却都是 undefined。所以,我们在定义变量的时候, 尽可能的不要只声明,不赋值。</p>

<h2>三、Null 类型</h2>

<p>Null 类型是一个只有一个值的数据类型,即特殊的值 null。它表示一个空对象引用(指 针),而 typeof 操作符检测 null 会返回 object。</p>

<pre><code>var box = null; 
alert(typeof box);
</code></pre>

<p>如果定义的变量准备在将来用于保存对象,那么最好将该变量初始化为 null。这样,当 检查 null 值就知道是否已经变量是否已经分配了对象引用了。</p>

<pre><code>var box = null; 
if (box != null) {
    alert('box 对象已存在!'); 
}
</code></pre>

<p>有个要说明的是:undefined 是派生自 null 的,因此 ECMA-262 规定对它们的相等性测 试返回 true。</p>

<p>alert(undefined == null);</p>

<p>由于 <code>undefined</code> 和 <code>null</code> 两个值的比较是相等的,所以,未初始化的变量和赋值为 null 的 变量会相等。这时,可以采用 typeof 变量的类型进行比较。但,建议还是养成编码的规范, 不要忘记初始化变量。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box;
</span><span class='line'>var car = null;
</span><span class='line'>alert(typeof box == typeof car)</span></code></pre></td></tr></table></div></figure>


<h2>四、Boolean</h2>

<p>Boolean 类型有两个值(字面量):<code>true</code> 和 <code>false</code>。而 <code>true</code> 不一定等于 1,<code>false</code> 不一定等于 0。 JavaScript 是区分大小写的,True 和 False 或者其他都不是 Boolean 类型的值。</p>

<pre><code>var box = true; 
alert(typeof box);
</code></pre>

<p>虽然 Boolean 类型的字面量只有 true 和 false 两种,但 ECMAScript 中所有类型的值都有 与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值,可以使用转型函数 <code>Boolean()</code>。</p>

<pre><code>var hello = 'Hello World!'; 
var hello2 = Boolean(hello); 
alert(typeof hello);
</code></pre>

<p>上面是一种显示转换 ,属于强制性转换 。而实际应用中 ,还有一种隐式转换 。比如,在 if 条件语句里面的条件判断,就存在隐式转换。</p>

<pre><code>var hello = 'Hello World!';
if (hello) {
    alert('如果条件为 true,就执行我这条!'); 
    } else {
    alert('如果条件为 false,就执行我这条!'); 
    }
</code></pre>

<p>以下是其他类型转换成 Boolean 类型规则</p>

<pre><code>数据类型      转换为 true 的值             转换为 false 的值
Boolean     true                         false
String      任何非空字符串                 空字符串
Number      任何非零数字值 (包括无穷大 )     0 和 NaN
Object      任何对象                       null
Undefined                                 undefined
</code></pre>

<h2>五、Number 类型</h2>

<p>Number 类型包含两种数值:整型和浮点型。为了支持各种数值类型, ECMA-262 定义了不同的数值字面量格式。
最基本的数值字面量是十进制整数。</p>

<pre><code>var box = 100; //十进制整数
</code></pre>

<h2>六、String 类型</h2>

<p>String 类型用于表示由于零或多个 16 位 Unicode 字符组成的字符序列,即字符串。字 符串可以由双引号(&ldquo;)或单引号(&lsquo;)表示。</p>

<pre><code>var box = 'Lee'; 
var box = "Lee";
</code></pre>

<p>PS:在某些其他语言(PHP)中,单引号和双引号表示的字符串解析方式不同, 而 ECMAScript 中,这两种表示方法没有任何区别。但要记住的是,必须成对出现,不能穿插 使用,否则会出错。</p>

<p>String 类型包含了一些特殊的字符字面量,也叫转义序列。</p>

<pre><code>\n  换行
\t  制表
\b  空格
\r  回车
\f  进纸
\\  斜杠
\'  单引号
\"  双引号
\xnn    以十六进制代码 nn 表示的一个字符(0~F)。例:\x41
\unnn   以十六进制代码 nnn 表示的一个 Unicode 字符(0~F)。例:\u03a3
</code></pre>

<p>字符串一旦创建,它们的值就不能改 变。要改变某个变量保存的字符串 ,首先要销毁原来的字符串 ,然后再用另一个包含新值的 字符串填充该变量。</p>

<pre><code>var box = 'Mr.'; 
box = box + ' Lee';
</code></pre>

<p><code>toString()</code>方法可以把值转换成字符串。</p>

<pre><code>var box = 11;
var box = true;
alert(typeof box.toString());
</code></pre>

<p><code>toString()</code>方法一般是不需要传参的,但在数值转成字符串的时候,可以传递进制参数 。</p>

<pre><code>var box = 10;
alert(box.toString());   //10,默认输出 
alert(box.toString(2));   //1010,二进制输出
alert(box.toString(8));    //12,八进制输出
alert(box.toString(10));   //10,十进制输出
alert(box.toString(16));   //a,十六进制输出
</code></pre>

<p>如果在转型之前不知道变量是否是 null 或者 undefined 的情况下,我们还可以使用转型 函数 <code>String()</code> ,这个函数能够将任何类型的值转换为字符串。</p>

<p>var box = null;
alert(String(box));</p>

<p>PS:如果值有 <code>toString()</code> 方法,则调用该方法并返回相应的结果;如果是 null 或者 undefined,则返回"null"或者"undeinfed"。</p>

<h2>七、Object 类型</h2>

<p>ECMAScript 中的对象其实就是一组数据和功能的集合 。对象可以通过执行 new 操作符 后跟要创建的对象类型的名称来创建。</p>

<pre><code>var box = new Object();
</code></pre>

<p><code>Object()</code>是对象构造,如果对象初始化时不需要传递参数,可以不用写括号,但这种方 式我们是不推荐的。</p>

<pre><code>var box = new Object;
</code></pre>

<p>Object()里可以任意传参,可以传数值、字符串、布尔值等。而且,还可以进行相应的 计算。</p>

<pre><code>var box = new Object(2);             //Object 类型,值是 2
var age = box + 2;                  //可以和普通变量运算 
alert(age);                        //输出结果,转型成 Number 类型了
</code></pre>

<p>既然可以使用 new Object()来表示一个对象,那么我们也可以使用这种 new 操作符来创 建其他类型的对象。</p>

<pre><code>var box = new Number(5); //new String('Lee')、new Boolean(true) 
alert(typeof box); //Object 类型
</code></pre>

<p>PS:面向对象是 JavaScript 课程的重点,这里我们只是简单做个介绍 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 Ajax]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/15/jquery-ajax/"/>
    <updated>2015-10-15T21:41:51+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/15/jquery-ajax</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 动画效果]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/15/jquery-zhi-dong-hua-xiao-guo/"/>
    <updated>2015-10-15T21:40:46+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/15/jquery-zhi-dong-hua-xiao-guo</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 高级事件]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-gao-ji-jian/"/>
    <updated>2015-10-14T22:34:16+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-gao-ji-jian</id>
    <content type="html"><![CDATA[<h3>一、模拟操作</h3>

<p>在事件触发的时候,有时我们需要一些模拟用户行为的操作。例如:当网页加载完毕后 自行点击一个按钮触发一个事件,而不是用户去点击。</p>

<p>点击按钮事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function () {
</span><span class='line'>  alert('我的第一次点击来自模拟!'); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>模拟用户点击行为</p>

<pre><code>$('input').trigger('click');
</code></pre>

<!--more-->


<p>可以合并两个方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function () {
</span><span class='line'>  alert('我的第一次点击来自模拟!'); 
</span><span class='line'>}).trigger('click');</span></code></pre></td></tr></table></div></figure>


<p>有时在模拟用户行为的时候,我们需要给事件执行传递参数,这个参数类似与 <code>event.data</code> 的额外数据,可以可以是数字、字符串、数组、对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e, data1, data2) { 
</span><span class='line'>  alert(data1 + ',' + data2);
</span><span class='line'>}).trigger('click', ['abc', '123']);</span></code></pre></td></tr></table></div></figure>


<p>jQuery 还提供了另外一个模拟用户行为的方法 : <code>.triggerHandler();</code>这个方法的使用 和 <code>.trigger()</code> 方法一样。</p>

<pre><code>$('input').click(function () { 
    alert('我的第一次点击来自模拟!');
}).triggerHandler('click');
</code></pre>

<p>1 <code>.triggerHandler()</code> 方法并不会触发事件的默认行为,而 <code>.trigger()</code> 会。</p>

<pre><code>$('form').trigger('submit');         //模拟用户执行提交,并跳转到执行页面 
$('form').triggerHandler('submit');  //模拟用户执行提交,并阻止的默认行为
</code></pre>

<p>如果我们希望使用 <code>.trigger()</code> 来模拟用户提交,并且阻止事件的默认行为,则需要这么写:</p>

<pre><code>$('form').submit(function (e) {
    e.preventDefault(); //阻止默认行为 
}).trigger('submit');
</code></pre>

<p>2 <code>.triggerHandler()</code> 方法只会影响第一个匹配到的元素,而 <code>.trigger()</code> 会影响所有。</p>

<p>3 <code>.triggerHandler()</code> 方法会返回当前事件执行的返回值,如果没有返回值,则返回 <code>undefined;</code> 而 <code>.trigger()</code> 则返回当前包含事件触发元素的 jQuery 对象(方便链式连缀调用)。</p>

<pre><code>alert($('input').click(function () { 
    return 123;
}).triggerHandler('click')); //返回 123,没有 return 返回
</code></pre>

<p>4 <code>.trigger()</code> 在创建事件的时候,会冒泡。但这种冒泡是自定义事件才能体现出来,是 jQuery 扩展于 DOM 的机制,并非 DOM 特性。而 <code>.triggerHandler()</code>不会冒泡。</p>

<pre><code>var index = 1; 
$('div').bind('myEvent',function(){
    alert('自定义事件' + index);
    index++; });
$('.div3').trigger("myEvent");
</code></pre>

<h2>二、命名空间</h2>

<p>有时,我们想对事件进行移除。但对于同名同元素绑定的事件移除往往比较麻烦,这个 时候,可以使用事件的命名空间解决。</p>

<pre><code>$('input').bind('click.abc', function () { 
    alert('abc');
});
$('input').bind('click.xyz', function () { 
    alert('xyz');
});
$('input').unbind('click.abc');    //移除 click 实践中命名空间为 abc 的
</code></pre>

<p>注意 : 也可以直接使用(&lsquo;.abc&rsquo;),这样的话,可以移除相同命名空间的不同事件。对于模拟操作 <code>.trigger()</code> 和 <code>.triggerHandler(),</code>用法也是一样的。</p>

<pre><code>$('input').trigger('click.abc');
</code></pre>

<h2>三、事件委托</h2>

<p>使用 <code>.bind()</code> 不具备动态绑定功能,只有点击原始按钮才能生成</p>

<pre><code>$('.button').bind('click', function () {
    $(this).clone().appendTo('#box'); 
});
</code></pre>

<p>使用 <code>.live()</code> 具备动态绑定功能,jQuery1.3 使用,jQuery1.7 之后废弃,jQuery1.9 删除</p>

<pre><code>$('.button').live('click', function () {
    $(this).clone().appendTo('#box'); 
});
</code></pre>

<p><code>.live()</code> 原理就是把 <code>click</code> 事件绑定到祖先元素 <code>$(document)</code> 上,而只需要给 <code>$(document)</code> 绑 定一次即可。
然后就可以处理后续动态加载的按钮的单击事件。在接受任何 事件时, <code>$(document)</code> 对象都会检查事件类型 <code>(event.type)</code> 和事件目标 <code>(event.target),</code> 如果 click 事件是 <code>.button,</code> 那么就执行委托给它的处理程序。.live()方法已经被删除,无法使用了。需 要测试使用的话,需要引入向下兼容插件。</p>

<p>当我们需要停止事件委托的时候,可以使用.die()来取消掉。</p>

<pre><code>$('.button').die('click');
</code></pre>

<p>由于.live()和.die()在 jQuery1.4.3 版本中废弃了,之后推出语义清晰、减少冒泡传播层次、 又支持链接连缀调用方式的方法:<code>.delegate()</code>和.<code>undelegate()。</code>但这个方法在 jQuery1.7 版本中 被 <code>.on()</code> 方法整合替代了。</p>

<pre><code>$('#box').delegate('.button', 'click', function () { 
    $(this).clone().appendTo('#box');
});

$('#box').undelegate('.button','click');
</code></pre>

<p>注意 : .live()和.delegate()和.bind()方法一样都是事件绑定,那么区别也很明显,用途上 遵循两个规则:</p>

<p>1.在 DOM 中很多元素绑定相同事件时;</p>

<p>2.在 DOM 中尚不存在即将生成的 元素绑定事件时;我们推荐使用事件委托的绑定方式,否则推荐使用.bind()的普通绑定。</p>

<h2>四、on、off 和 one</h2>

<p>目前绑定事件和解绑的方法有三组共六个。由于这三组的共存可能会造成一定的混乱,为此 jQuery1.7 以后推出了 <code>.on()</code> 和 <code>.off()</code>方法彻底摒弃前面三组。</p>

<p>替代.bind()方式,并使用额外数据和事件对象</p>

<pre><code>$('.button').on('click', {user : 'Lee'}, function (e) {
    alert('替代.bind()' + e.data.user); 
});
</code></pre>

<p>替代.bind()方式,并绑定多个事件</p>

<pre><code>$('.button').on('mouseover mouseout', function () {
    alert('替代.bind()移入移出!'); 
});
</code></pre>

<p>代.bind()方式,以对象模式绑定多个事件</p>

<pre><code>$('.button').on({
    mouseover : function () { 
        alert('替代.bind()移入!');
        },
    mouseout : function () {
        alert('替代.bind()移出!'); 
        }
    });
</code></pre>

<p>替代.bind()方式,阻止默认行为并取消冒泡</p>

<pre><code>$('form').on('submit', function () {
    return false; 
});
</code></pre>

<p>或</p>

<pre><code>$('form').on('submit', false);
</code></pre>

<p>替代.unbind()方式,移除事件</p>

<pre><code>$('.button').off('click'); 
$('.button').off('click', fn); 
$('.button').off('click.abc');
</code></pre>

<p>替代.live()和.delegate(),事件委托</p>

<pre><code>$('#box').on('click', '.button', function () {
    $(this).clone().appendTo('#box'); 
});
</code></pre>

<p>替代.die()和.undelegate(),取消事件委托</p>

<pre><code>$('#box').off('click', '.button');
</code></pre>

<p>不管是.bind()还是.on(),绑定事件后都不是自动移除事件的,需要通过.unbind()和.off() 来手工移除。jQuery 提供了 <code>.one()</code> 方法,绑定元素执行完毕后自动移除事件,可以方法仅触 发一次的事件。</p>

<p>类似于.bind()只触发一次</p>

<pre><code>$('.button').one('click', function () {
    alert('one 仅触发一次!'); 
});
</code></pre>

<p>类似于.delegate()只触发一次</p>

<pre><code>$('#box).one('click', 'click', function () {
    alert('one 仅触发一次!'); 
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 事件对象]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-shi-jian-dui-xiang/"/>
    <updated>2015-10-14T21:58:43+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-shi-jian-dui-xiang</id>
    <content type="html"><![CDATA[<p>事件对象就是 <code>event</code> 对象,通过处理函数默认传递接受。之前处理函数的 <code>e</code> 就是 <code>event</code> 事件对象。</p>

<h3>一、事件对象</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', function (e) {       //接受事件对象参数
</span><span class='line'>  alert(e); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>通过 event.type 属性获取触发事件名</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert(e.type); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>通过 event.target 获取绑定的 DOM 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert(e.target); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>通过 event.data 获取额外数据,可以是数字、字符串、数组、对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', 123, function () {          //传递 data 数据 
</span><span class='line'>  alert(e.data);                                   //获取数字数据
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 如果字符串就传递:<code>'123'</code>、如果是数组就传递: <code>[123,'abc']</code> ,如果是对象就传递: <code>{user : 'Lee', age : 100}</code> 。数组的调用方式是: <code>e.data[1],</code> 对象的调用方式是: <code>e.data.user。</code></p>

<p>event.data 获取额外数据,对于封装的简写事件也可以使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click({user : 'Lee', age : 100},function (e) {
</span><span class='line'>  alert(e.data.user); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 键值对的键可以加上引号,也可以不加;在调用的时候也可以使用数组的方式: <code>alert(e.data['user']);</code></p>

<p>获取移入到 div 之前的那个 DOM 元素</p>

<pre><code>$('div').mouseover(function (e) {
    alert(e.relatedTarget); 
});
</code></pre>

<p>获取移出 div 之后到达最近的那个 DOM 元素</p>

<pre><code>$('div').mouseout(function (e) {
    alert(e.relatedTarget);
 });
</code></pre>

<p>获取绑定的那个 DOM 元素,相当于 this,区别与 <code>event.target</code></p>

<pre><code>$('div').click(function (e) {
    alert(e.currentTarget); 
});
</code></pre>

<p>注意 : <code>event.target</code> 得到的是触发元素的 DOM,<code>event.currentTarget</code> 得到的是监听元素的 DOM。而 <code>this</code>也是得到监听元素的 DOM。</p>

<p>获取上一次事件的返回值</p>

<pre><code>$('div').click(function (e) {
    return '123'; 
});
$('div').click(function (e) { 
    alert(e.result);
});
</code></pre>

<p>获取当前的时间戳</p>

<pre><code>$('div').click(function (e) {
    alert(e.timeStamp); 
});
</code></pre>

<p>获取触发元素鼠标当前的位置</p>

<pre><code>$(document).click(function (e) {
    alert(e.screenY+ ',' + e.pageY + ',' + e.clientY); 
});
</code></pre>

<h3>二、冒泡和默认行为</h3>

<p>如果在页面中重叠了多个元素,并且重叠的这些元素都绑定了同一个事件,那么就会出 现冒泡问题。</p>

<p>jQuery 提供了一个事件对象的方法: <code>event.stopPropagation();</code> 这个方法设置到需要触发 的事件上时,所有上层的冒泡行为都将被取消。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) { 
</span><span class='line'>  alert('按钮被触发了!'); 
</span><span class='line'>  e.stopPropagation();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>默认行为</p>

<p>网页中的元素,在操作的时候会有自己的默认行为。比如:右击文本框输入区域,会弹 出系统菜单、点击超链接会跳转到指定页面、点击提交按钮会提交数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('a').click(function (e) { 
</span><span class='line'>  e.preventDefault();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>禁止提交表单跳转</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('form').submit(function (e) {
</span><span class='line'>  e.preventDefault(); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 如果想让上面的超链接同时阻止默认行为且禁止冒泡行为,可以把两个方法同时 写上: <code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code> 。这两个方法如果需要同时启用的时候, 还有一种简写方案代替,就是直接 <code>return false。</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('a').click(function (e) { 
</span><span class='line'>  return false;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>冒泡和默认行为的一些方法</h2>

<p>判断是否取消了元素的默认行为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $('input').keyup(function (e) {
</span><span class='line'>  e.preventDefault();
</span><span class='line'>  alert(e.isDefaultPrevented()); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>取消冒泡并取消后续事件处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert('input');
</span><span class='line'>  e.stopImmediatePropagation();
</span><span class='line'> });
</span><span class='line'>
</span><span class='line'>$('input').click(function () { 
</span><span class='line'>  alert('input2');
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>$(document).click(function () { 
</span><span class='line'>  alert('document');
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>判断是否调用了 <code>stopPropagation()</code> 方法</p>

<pre><code>$('input').click(function (e) {
    e.stopPropagation();
    alert(e.isPropagationStopped()); 
});
</code></pre>

<p>判断是否执行了 <code>stopImmediatePropagation()</code> 方法</p>

<pre><code>$('input').click(function (e) {
    e.stopImmediatePropagation();
    alert(e.isImmediatePropagationStopped());
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 基础事件]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/13/jquery-zhi-ji-chu-shi-jian/"/>
    <updated>2015-10-13T21:42:16+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/13/jquery-zhi-ji-chu-shi-jian</id>
    <content type="html"><![CDATA[<p>在 JavaScript 课程的学习中,我们掌握了很多使用的事件,常用的事件有:<code>click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、change、select、submit、keydown、 keypress、keyup、blur、focus、load、resize、scroll、error。</code>那么,还有更多的事件可以参考 手册中的事件部分。</p>

<h3>一、绑定事件</h3>

<p>jQuery 通过 <code>.bind()</code> 方法来为元素绑定这些事件。可以传递三个参数<code>bind(type, [data], fn),</code>  <code>type</code> 表示一个或多个类型的事件名字符串; <code>[data]</code> 是可选的,作为 <code>event.data</code> 属性值传递一个 额外的数据,这个数据是一个字符串、一个数字、一个数组或一个对象;fn 表示绑定到指 定元素的处理函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', function () {    //点击按钮后执行匿名函数
</span><span class='line'>  alert('点击!'); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>普通处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', fn);       //执行普通函数式无须圆括号
</span><span class='line'>  function fn() {
</span><span class='line'>  alert('点击!'); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以同时绑定多个事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('mouseout mouseover', function () {    //移入和移出分别执行一次
</span><span class='line'>  $('div').html(function (index, value) { 
</span><span class='line'>      return value + '1';
</span><span class='line'>  }); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>通过对象键值对绑定多个参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind({             传递一个对象 
</span><span class='line'>  'mouseout' : function () {     //事件名的引号可以省略
</span><span class='line'>      alert('移出');
</span><span class='line'>  },
</span><span class='line'>  'mouseover' : function () {
</span><span class='line'>      alert('移入'); 
</span><span class='line'>  }
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>使用 unbind 删除绑定的事件</p>

<pre><code> $('input').unbind();
</code></pre>

<p>使用 unbind 参数删除指定类型事件</p>

<pre><code>$('input').unbind('click');
</code></pre>

<p><code>.mouseover()和.mouseout()</code> 表示鼠标移入和移出的时候触发。<code>.mouseenter()和.mouseleave()</code> 这组穿过,子元素不会触发。</p>

<p><code>.keydown()、.keyup()</code>返回的是键码,而 <code>.keypress</code>  返回的是字符编码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').keydown(function (e) {
</span><span class='line'>  alert(e.keyCode);
</span><span class='line'>});
</span><span class='line'>$('input').keypress(function (e) { 
</span><span class='line'>  alert(e.charCode);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><code>.focus()和.blur()</code> 分别表示光标激活和丢失,事件触发时机是当前元素。而<code>.focusin() 和.focusout()</code> 也表示光标激活和丢失,但事件触发时机可以是子元素。</p>

<h2>二、复合事件</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').hover(function () {                    //mouseenter 效果
</span><span class='line'>      $(this).css('background', 'black'); 
</span><span class='line'>  }, function () {                            //mouseleave 效果  可省略
</span><span class='line'>      $(this).css('background', 'red');
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : <code>.hover()</code> 方法是结合了 <code>.mouseenter()</code> 方法和 <code>.mouseleva()</code> 方法,并非 <code>.mouseover()</code> 和 <code>.mouseout()</code> 方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 DOM节点操作]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/13/jquery-domjie-dian-cao-zuo/"/>
    <updated>2015-10-13T00:33:04+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/13/jquery-domjie-dian-cao-zuo</id>
    <content type="html"><![CDATA[<p>DOM 中有一个非常重要的功能,就是节点模型,也就是 DOM 中的“M”。</p>

<h3>一、创建节点</h3>

<p>为了使页面更加智能化,有时我们想动态的在 html 结构页面添加一个元素标签,那么在插入之前首先要做的动作就是:创建节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = $('&lt;div id="box"&gt;节点&lt;/div&gt;');         //创建一个节点 
</span><span class='line'>$('body').append(box);                           //将节点插入到&lt;body&gt;元素内部</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>二、插入节点</h2>

<h4>> 内部插入节点方法:</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').append('&lt;strong&gt;节点&lt;/strong&gt;');    //向 div 内部插入 strong 节点 
</span><span class='line'>$('div').append(function (index, html) {    //使用匿名函数插入节点,html 是原节点
</span><span class='line'>  return '&lt;strong&gt;节点&lt;/strong&gt;';
</span><span class='line'>￼￼});
</span><span class='line'>
</span><span class='line'>$('span').appendTo('div');                 //讲 span 节点移入 div 节点内
</span><span class='line'>$('span').appendTo($('div'));              //同上
</span><span class='line'>
</span><span class='line'>$('div').prepend('&lt;span&gt;节点&lt;/span&gt;');     //将 span 插入到 div 内部的前面 
</span><span class='line'>$('div').append(function (index, html) {  //使用匿名函数,同上
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;'; 
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>$('span').prependTo('div');               //将 span 移入 div 内部的前面
</span><span class='line'>$('span').prependTo($('div'));            //同上</span></code></pre></td></tr></table></div></figure>


<h4>> 外部插入节点方法:</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').after('&lt;span&gt;节点&lt;/span&gt;');           //向 div 的同级节点后面插入 span
</span><span class='line'>$('div').after(function (index, html) {       //使用匿名函数,同上
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;';
</span><span class='line'>  });
</span><span class='line'>$('div').before('&lt;span&gt;节点&lt;/span&gt;');         //向 div 的同级节点前面插入 span
</span><span class='line'>$('div').before(function (index, html) { 
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;';
</span><span class='line'>  }); 
</span><span class='line'>$('span').insertAfter('div');                //将 span 元素移到 div 元素外部的后面
</span><span class='line'>$('span').insertBefore('div');               //将 span 元素移到 div 元素外部的前面</span></code></pre></td></tr></table></div></figure>


<h4>> 包裹节点</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').wrap('&lt;strong&gt;&lt;/strong&gt;');                   //在 div 外层包裹一层 strong
</span><span class='line'>$('div').wrap('&lt;strong&gt;123&lt;/strong&gt;');                //包裹的元素可以带内容
</span><span class='line'>$('div').wrap('&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;');          //包裹多个元素
</span><span class='line'>$('div').wrap($('strong').get(0));                    //也可以包裹一个原生 DOM 
</span><span class='line'>$('div').wrap(document.createElement('strong'));      //临时的原生DOM
</span><span class='line'>$('div').wrap(function (index) {
</span><span class='line'>  return '&lt;strong&gt;&lt;/strong&gt;'; 
</span><span class='line'>  });
</span><span class='line'>$('div').unwrap();                                    //移除一层包裹内容,多个需移除多次
</span><span class='line'>$('div').wrapAll('&lt;strong&gt;&lt;/strong&gt;');                //所有 div 外面只包一层 strong
</span><span class='line'>$('div').wrapAll($('strong').get(0)); 
</span><span class='line'>$('div').wrapInner('&lt;strong&gt;&lt;/strong&gt;');              //向指定元素的子内容包裹一层 html 
</span><span class='line'>$('div').wrapInner($('strong').get(0));               //DOM 节点
</span><span class='line'>$('div').wrapInner(function () {
</span><span class='line'>  return '&lt;strong&gt;&lt;/strong&gt;'; 
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<h2>三、节点操作</h2>

<pre><code>$('body').append($('div').clone(true));     //复制一个节点添加到 HTML 中
</code></pre>

<p>注意 : <code>clone(true)</code> 参数可以为空,表示只复制元素和内容,不复制事件行为。而加上 <code>true</code> 参数的话,这个元素附带的事件处理行为也复制出来。</p>

<pre><code>$('div').remove(); //直接删除 div 元素
</code></pre>

<p>注意 : <code>.remove()</code> 不带参数时,删除前面对象选择器指定的元素。而<code>.remove()</code> 也可以 带选择符参数的,比如 :<code>$('div').remove('#box');</code> 只删除 <code>id=box</code>  的<code>div。</code></p>

<pre><code>$('div').detach(); //保留事件行为的删除
</code></pre>

<p>注意 : <code>.remove()</code> 和 <code>.detach()</code> 都是删除节点,而删除后本身方法可以返回当前被删除的节 点对象,但区别在于前者在恢复时不保留事件行为,后者则保留。</p>

<pre><code>$('div').empty();   //删除掉节点里的内容
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').replaceWith('&lt;span&gt;节点&lt;/span&gt;');      //将 div 替换成 span 元素
</span><span class='line'>$('&lt;span&gt;节点&lt;/span&gt;').replaceAll('div');        //同上</span></code></pre></td></tr></table></div></figure>


<p>注意 : 节点被替换后,所包含的事件行为就全部消失了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 基础DOM操作]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/10/jquery-zhi-ji-chu-domhe-csscao-zuo/"/>
    <updated>2015-10-10T21:00:03+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/10/jquery-zhi-ji-chu-domhe-csscao-zuo</id>
    <content type="html"><![CDATA[<h3>一、设置元素及内容</h3>

<p>在常规的 DOM 元素中,使用 html()和 text()方法获取内部的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('#box').html();                       //获取 html 内容 
</span><span class='line'>$('#box').text();                       //获取文本内容,会自动清理 html 标签
</span><span class='line'>$('#box').html('&lt;em&gt;www.li.cc&lt;/em&gt;');   //设置 html 内容 
</span><span class='line'>$('#box').text('&lt;em&gt;www.li.cc&lt;/em&gt;');   //设置文本内容,会自动转义 html 标签</span></code></pre></td></tr></table></div></figure>


<p>使用 html()或 text()设置元素里的内容时,会清空原来的数据。而我们期 望能够追加数据的话,需要先获取原本的数据。</p>

<pre><code>$('#box').html($('#box').html() + '&lt;em&gt;www.li.cc&lt;/em&gt;'); //追加数据
</code></pre>

<p>如果元素是表单的话,jQuery 提供了 <code>val()</code>方法进行获取或设置内部的文本数据。</p>

<pre><code>$('input').val(); //获取表单内容 
$('input').val('www.li.cc'); //设置表单内容
</code></pre>

<p>如果想设置多个选项的选定状态,比如下拉列表、单选复选框等等,可以通过数组传递 操作。</p>

<pre><code>$("input").val(["check1","check2", "radio1" ]); //value 值是这些的将被选定
</code></pre>

<!--more-->


<h2>二、元素属性操作</h2>

<p>除了对元素内容进行设置和获取,通过 jQuery 也可以对元素本身的属性进行操作,包 括获取属性的属性值、设置属性的属性值,并且可以删除掉属性。</p>

<pre><code>$('div').attr('title');                            //获取属性的属性值
$('div').attr('title', '我是域名');                 //设置属性及属性值 
$('div').attr('title', function () {               //通过匿名函数返回属性值
    return '我是域名';});
$('div').attr('title', function (index, value) {  
    return value + (index+1) + ',我是域名';          //可以接受两个参数
});
</code></pre>

<p>注意: <code>attr()</code>方法里的 <code>function() {},</code>可以不传参数。可以只传一个参数 index,表示当前 元素的索引(从 0 开始)。也可以传递两个参数 index、value,第二个参数表示属性原本的值。</p>

<p>注意: jQuery 中很多方法都可以使用 <code>function() {}</code>来返回出字符串,比如<code>html()、text()、 val()</code>和上一章刚学过的 <code>is()、filter()</code>方法。而如果又涉及到多个元素集合的话,还可以传递 <code>index</code> 参数来获取索引值,并且可以使用第二个参数 <code>value</code>(并不是所有方法都适合,有兴趣 可以自己逐个尝试)。</p>

<pre><code>$('div').html(function (index) { //通过匿名函数赋值,并传递 index 
    return '我是' + (index+1) + '号 div';
});
$('div').html(function (index, value) { //还可以实现追加内容
     return '我是' + (index+1) + '号 div:'+value ;
});
$('div').removeAttr('title'); //这个方法就不可以使用匿名函数,传递 index 和 value 均无效。
</code></pre>

<h2>三、元素样式操作</h2>

<p>元素样式操作包括了直接设置 CSS 样式、增加 CSS 类别、类别切换、删除类别这几种操作方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').css('color');                   //获取元素行内 CSS 样式的颜色 
</span><span class='line'>$('div').css('color', 'red');           //设置元素行内 CSS 样式颜色为红色</span></code></pre></td></tr></table></div></figure>


<p>也可以获取多个 CSS 样式,而获取到的是一个对象数组,如果用 传统方式进行解析需要使用 for in 遍历。</p>

<pre><code>var box = $('div').css(['color', 'height', 'width']);              //得到多个 CSS 样式的数组对象 
    for (var i in box) {                                           //逐个遍历出来
    alert(i + ':' + box[i]); }
</code></pre>

<p>jQuery 提供了一个遍历工具专门来处理这种对象数组,<code>$.each()</code>方法,这个方法可以轻 松的遍历对象数组。</p>

<pre><code>$.each(box, function (attr, value) { //遍历 JavaScript 原生态的对象数组 
    alert(attr + ':' + value);
});
</code></pre>

<p>使用<code>$.each()</code>可以遍历原生的 JavaScript 对象数组,如果是 jQuery 对象的数组怎么使 用<code>.each()</code>方法呢?</p>

<pre><code>$('div').each(function (index, element) { //index 为索引,element 为元素 DOM 
    alert(index + ':' + element);
});
</code></pre>

<p>在需要设置多个样式的时候,我们可以传递多个 CSS 样式的键值对即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $('div').css({
</span><span class='line'>      'background-color' : '#ccc', 
</span><span class='line'>      'color' : 'red',
</span><span class='line'>      font-size' : '20px' 
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<p> CSS 类的样式切换功能。</p>

<pre><code>$('div').click(function () { //当点击后触发
    $(this).toggleClass('red size'); //单个样式多个样式均可 
    });
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').click(function () { 
</span><span class='line'>  $(this).toggleClass(function () {
</span><span class='line'>      if ($(this).hasClass('red')) { 
</span><span class='line'>          $(this).removeClass('red'); 
</span><span class='line'>          return 'green';
</span><span class='line'>      } else { 
</span><span class='line'>          $(this).removeClass('green');
</span><span class='line'>          return 'red';
</span><span class='line'>      } 
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>四、CSS 方法</h2>

<p>jQuery 不但提供了 CSS 的核心操作方法,比如.css()、.addClass()等。还封装了一些特殊功能的 CSS 操作方法,我们分别来了解一下。</p>

<pre><code>$('div').width();                          //获取元素的长度,返回的类型为number 
$('div').width(500);                       //设置元素长度,直接传数值,默认加 px  
$('div').width('500pt');                   //同上,设置了 pt 单位
$('div').width(function (index, value) {   //index 是索引,value 是原本值 
    return value - 500;                    //无须调整类型,直接计算
});
</code></pre>

<p><code>height()</code>方法同上。</p>

<h4>内外边距和边框尺寸方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alert($('div').width());           //获取元素宽度 不包含
</span><span class='line'>alert($('div').innerWidth());      //包含内边距 padding
</span><span class='line'>alert($('div').outerWidth());      //包含内边距 padding+边框 border
</span><span class='line'>alert($('div').outerWidth(true));  //包含内边距 padding+边框 border+外边距 margin</span></code></pre></td></tr></table></div></figure>


<h4>元素偏移方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('strong').offset().left;       //获取某个元素相对于视口的偏移位置
</span><span class='line'>$('strong').position().left;     //相对于父元素的偏移
</span><span class='line'>$(window).scrollTop();           //获取当前滚动条的位置
</span><span class='line'>$(window).scrollTop(300);        //设置当前滚动条的位置</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 过滤选择器]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/09/jquery-guo-lu-xuan-ze-qi/"/>
    <updated>2015-10-09T21:54:41+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/09/jquery-guo-lu-xuan-ze-qi</id>
    <content type="html"><![CDATA[<p>过滤选择器简称:过滤器。它其实也是一种选择器,而这种选择器类似与 CSS3里的伪类,可以让不支持 CSS3 的低版本浏览器也能支持。</p>

<h2>一、基本过滤器</h2>

<p>通过特定的过滤规则来筛选所需的 DOM 元素,和CSS中的伪类的语法类似:使用冒号(:)开头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('li:first').css('background', '#ccc');       //第一个元素
</span><span class='line'>$('li:last).css('background', '#ccc');         //最后一个元素
</span><span class='line'>$('li:not(.red)).css('background', '#ccc');    //非 class 为 red 的元素 
</span><span class='line'>
</span><span class='line'>$('li:even').css('background', '#ccc');        //索引为偶数的元素
</span><span class='line'>$('li:odd).css('background', '#ccc');          //索引为奇数的元素
</span><span class='line'>$('li:eq(2)).css('background', '#ccc');        //指定索引值的元素 
</span><span class='line'>
</span><span class='line'>$('li:gt(2)').css('background', '#ccc');       //大于索引值的元素
</span><span class='line'>$('li:lt(2)').css('background', '#ccc');       //小于索引值的元素
</span><span class='line'>
</span><span class='line'>$(':header').css('background', '#ccc');        //页面所有 h1 ~ h6 元素</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<p>注意:<code>:focus</code>过滤器,必须是网页初始状态的已经被激活焦点的元素才能实现元素获取。 而不是鼠标点击或者 Tab 键盘敲击激活的。</p>

<pre><code>$('input').get(0).focus();                 //先初始化激活一个元素焦点 
$(':focus').css('background', 'red');      //被焦点的元素
</code></pre>

<p>jQuery 为最常用的过滤器提供了专用的方法,已达到提到性能和效率的作用:</p>

<pre><code>$('li').eq(2).css('background', '#ccc');         //元素 li 的第三个元素,负数从后开始
$('li').first().css('background', '#ccc');       //元素 li 的第一个元素
$('li').last().css('background', '#ccc');        //元素 li 的最后一个元素
$('li').not('.red').css('background', '#ccc');   //元素 li 不含 class 为 red 的元素
</code></pre>

<h2>二、内容过滤器</h2>

<p>内容过滤器的过滤规则主要是包含的子元素或文本内容上。</p>

<pre><code>$('div:contains("ycku.com")').css('background', '#ccc');   //选择元素文本节点含有 ycku.com 文本的元素
$('div:empty').css('background', '#ccc');                  //选择空元素
$('ul:has(.red)').css('background', '#ccc');               //选择子元素含有 class 是 red 的元素 
$(':parent').css('background', '#ccc');                    //选择非空元素  选取含有子元素或文本的元素
</code></pre>

<p>jQuery 提供了一个 has()方法来提高:has 过滤器的性能:</p>

<pre><code>$('ul').has('.red').css('background', '#ccc');         //选择子元素含有 class 是 red 的元素
</code></pre>

<p>jQuery 提供了一个名称和<code>:parent</code>相似的方法,但这个方法并不是选取含有子元素或文本 的元素,而是获取当前元素的父元素,返回的是元素集合。</p>

<pre><code>$('li').parent().css('background', '#ccc');               //选择当前元素的父元素 
$('li').parents().css('background', '#ccc');              //选择当前元素的父元素及祖先元素 
$('li').parentsUntil('div').css('background', '#ccc');    //选择当前元素遇到 div 父元素停止
</code></pre>

<h2>三、可见性过滤器</h2>

<pre><code>$('p:hidden).size(); //选取所有不可见元素
$('p:visible').size(); //元素 p 显示的元素
</code></pre>

<p>注意:<code>:hidden</code>过滤器一般是包含的内容为:CSS 样式为<code>display:none、</code>input 表单类型为 <code>type="hidden"</code>和 <code>visibility:hidden</code>的元素。</p>

<h2>四、子元素过滤器</h2>

<p>子元素过滤器的过滤规则是通过父元素和子元素的关系来获取相应的元素。</p>

<pre><code>$('li:first-child').css('background', '#ccc');       //每个父元素第一个 li 元素 
$('li:last-child').css('background', '#ccc');        //每个父元素最后一个 li 元素 
$('li:only-child').css('background', '#ccc');        //每个父元素只有一个 li 元素 
$('li:nth-child(odd)').css('background', '#ccc');    //每个父元素奇数 li 元素
$('li:nth-child(even)').css('background', '#ccc');   //每个父元素偶数 li 元素
$('li:nth-child(2)').css('background', '#ccc');      //每个父元素第三个 li 元素
</code></pre>

<h2>五、其他方法</h2>

<p>jQuery 在选择器和过滤器上,还提供了一些常用的方法,方便我们开发时灵活使用。</p>

<pre><code>$('.red').is('li');                             //true,选择器,检测 class 为是否为 red
$('.red').is($('li'));                          //true,jQuery 对象集合,同上
$('.red').is($('li').eq(2));                    //true,jQuery 对象集合,同上
$('.red').is($('li').get(2));                   //true,DOM 对象,同上
$('.red').is(function () {                      //true,方法,同上
    return $(this).attr('title') == '列表 3';    //可以自定义各种判断
}));   
$('li').eq(2).hasClass('red');                   //和 is 一样,只不过只能传递 class

$('li').slice(0,2).css('background', '#ccc');    //前三个变成色
</code></pre>

<p>注意:这个参数有多种传法和 JavaScript 的 slice 方法是一样的比如:slice(2);slice(2,4),第三和第四被选定;slice(0,-2),从倒数第三个位置,向前选定 所有;slice(2,-2),前两个和末尾两个未选定。</p>

<pre><code>$("div").find("p").end().get(0);        //返回 div 的原生 DOM
$('div').contents().size();             //返回子节点(包括文本)数量

$('li').filter('.red').css('background','#ccc');         //选择 li 的 class 为 red 的元素
$('li').filter('.red, :first, :last').css('background','#ccc');    //增加了首尾选择
</code></pre>

<p>特殊要求函数返回</p>

<pre><code>$('li').filter(function () {
        return $(this).attr('class') == 'red' &amp;&amp; $(this).attr('title') == '列表 3'; 
        }).css('background', '#ccc');
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 常规选择器]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/09/jquery-chang-gui-qi/"/>
    <updated>2015-10-09T20:49:48+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/09/jquery-chang-gui-qi</id>
    <content type="html"><![CDATA[<p>jQuery 最核心的组成部分就是：选择器引擎。它继承了 CSS 的语法,不必担心浏览器的兼容性。</p>

<h3>一、简单选择器</h3>

<pre><code>$('div').css('color', 'red');          //元素名选择器,返回多个元素 
$('#box').css('color', 'red');         //ID 选择器,返回单个元素
$('.box').css('color', 'red');         //类(class)选择器,返回多个元素
</code></pre>

<p>可以用 jQuery 核心自带的一个属性 length 或 size()方法来查看返回的元素个数。</p>

<h5>容错功能：</h5>

<pre><code>$('#pox').css('color', 'red');       //不存在 ID 为 pox 的元素,也不报错 
document.getElementById('pox').style.color = 'red';     //报错了
</code></pre>

<!--more-->


<p>原生方法可以这么判断解决这个问题:</p>

<pre><code>if (document.getElementById('pox')) { //先判断是否存在这个对象 
    document.getElementById('pox').style.color = 'red';
}
</code></pre>

<p>使用 jQuery 调用的话,怎么去判断是否存在呢?因 为本身返回的是 jQuery 对象,可能会导致不存在元素存在与否,都会返回 true。</p>

<pre><code>if ($('#pox').length &gt; 0) { //判断元素包含数量即可 
    $('#pox').css('color', 'red');
}
</code></pre>

<p>可以用转换为 DOM 对象的方式来判断,例如:</p>

<pre><code>if ($('#pox').get(0)) {} 或 if ($('#pox')[0]) {} //通过数组下标也可以获取 DOM 对象
</code></pre>

<h3>二、进阶选择器</h3>

<pre><code>$('span, em, .box').css('color', 'red');    //群组选择器 
$('ul li a').css('color', 'red');           //后代选择器
$('*').css('color', 'red');                 //通配选择器
</code></pre>

<h3>三、高级选择器</h3>

<h4>1、层次选择器</h4>

<pre><code>$('#box p').css('color', 'red');              //后代选择器
$('#box').find('p').css('color', 'red');      //和后代选择器等价

$('#box &gt; p').css('color', 'red');            //子选择器,孙子后失明
$('#box').children('p').css('color', 'red');  //和子选择器等价

$('#box+p').css('color', 'red');              //next 选择器(下一个同级节点)
$('#box').next('p').css('color', 'red');      //和 next 选择器等价

$('#box ~ p').css('color', 'red');            //nextAll 选择器(后面所有同级节点)
$('#box').nextAll('p').css('color', 'red');   //和 nextAll 选择器等价
</code></pre>

<p>在 <code>find()、next()、nextAll()和 children()</code>这四个方法中,如果不传递参数,就相当于传递 了“*”,我们不建议这么做,不但影响性能,而且由于精准度不佳可能产生怪异的结果。</p>

<p>补充：</p>

<pre><code>$('#box').prev('p').css('color', 'red'); //同级上一个元素 
$('#box').prevAll('p').css('color', 'red'); //同级所有上面的元素

$('#box').prevUntil('p').css('color', 'red'); //同级上非指定元素选定,遇到则停止 
$('#box').nextUntil('p').css('color', 'red'); //同级下非指定元素选定,遇到则停止
</code></pre>

<p>siblings()方法正好集成了 prevAll()和 nextAll()两个功能的效果,及上下相邻的所有元素 进行选定:</p>

<pre><code>$('#box').siblings('p').css('color', 'red'); //同级上下所有元素选定
</code></pre>

<p>选择器快慢分析:</p>

<p>最快的是 find()方法,最慢的是$(&lsquo;#box p&rsquo;)这种高级选择器。如果一开始将 $(&lsquo;#box&rsquo;)进行赋值,那么 jQuery 就对其变量进行缓存,那么速度会进一步提高。</p>

<pre><code>var box = $('#box'); 
var p = box.find('p');
</code></pre>

<h4>2、属性选择器</h4>

<pre><code>$('a[title]').css('color', 'red');           //选定这个属性的
$('a[title=num1]').css('color', 'red');      //选定具有这个属性=这个属性值的
$('a[title=^num]').css('color', 'red');      //选定具有这个属性且开头属性值匹配的
$('a[title|="num"]').css('color', 'red');    //选定具有这个属性且等于属性值或开头属性值匹配后面跟一个“-”号
$('a[title$=num]').css('color','red');       //选定具有这个属性且结尾属性值匹配的
$('a[title!=num1]').css('color','red');      //选定具有这个属性且属性值不想等的
$('a[title~=num1]').css('color','red');      //选定具有这个属性且属性值是以一个空格分割的列表,其中包含属性值的
$('a[title*=num]').css('color','red');       //选定具有这个属性且属性值含有一个指定字串的
$('a[bbb][title=num1]').css('color','red');  //选定具有多个属性且属性值匹配成功的
</code></pre>

<h2>四、表单选择器</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').val();                     //元素名定位,默认获取第一个
</span><span class='line'>$('input').eq(1).val();               //同上,获取第二个
</span><span class='line'>$('input[type=password]').val();      //选择 type 为 password 的字段
</span><span class='line'>$('input[name=user]').val();          //选择 name 为 user 的字段</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css3 - Box-flex]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/07/css3-box-flexshu-xing/"/>
    <updated>2015-10-07T16:11:02+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/07/css3-box-flexshu-xing</id>
    <content type="html"><![CDATA[<p>CSS3中新的盒子模型——弹性盒子模型(Flexible Box Model)。”flex”一词中文有“收缩”之意。</p>

<h3>一、box-flex属性（和谐版）</h3>

<p>不过，从此属性实际上产生的效果来看，无论怎样用“收缩”一词解释都显得很牵强。所以，这里，直接抛开字面意思，我们可以将<code>”box-flex”</code>理解为”房子-分配”。box为“盒子”的意思，我们可以理解为当下价格巨高的“房子”，<code>”flex”</code>指兄弟几个“分配房子”。比如：</p>

<!--more-->


<pre><code>#老大 { 房子-分配: 2; }
#老二 { 房子-分配: 1; }
#老三 { 房子-分配: 1; }
</code></pre>

<p>换成CSS表示就是：</p>

<pre><code>#first_boy { box-flex: 2; }
#second_boy { box-flex: 1; }
#three_boy { box-flex: 1; }
</code></pre>

<p><code>box-flex</code>的值为至少为1的整数时起作用。但是，仅仅一个<code>box-flex</code>属性是不足以实现子元素间的空间分配，因为还要看其老爸的意思。只有老爸开口说：“这个房子现在你们随意分配。”其子女才能分配。</p>

<p>所以，父元素也是需要添加必要的声明的。此声明就是：</p>

<pre><code>#father { display: box; }
</code></pre>

<p>似乎也可以是：</p>

<pre><code>#father { display: inline-box; }
</code></pre>

<p><code>display: box;</code>的声明其实就是弹性盒子模型的声明，此声明下的子元素的行为与表现与CSS2中的传统盒子模型的表现是有显著的差异的。</p>

<p>毕竟属于CSS3的东西，目前而言，仅Firefox/Chrome/Safari浏览器支持弹性盒子模型（IE9不详，Opera尚未），且使用的时候，需要附带私有前缀。就是诸如<code>-moz-, -webkit-</code>之类。</p>

<h5>CSS实例代码如下：</h5>

<pre><code>.test_box {
    display: -moz-box; 
    display: -webkit-box; 
    display: box; 

    ...
 }
.list {
   ...
}
.list_one {
    -moz-box-flex: 1; 
    -webkit-box-flex: 1; 
    box-flex: 1;
}
.list_two{
    -moz-box-flex: 2; 
    -webkit-box-flex: 2; 
    box-flex: 2;
}
</code></pre>

<h5>HTML代码如下：</h5>

<pre><code>&lt;div class="test_box"&gt;
    &lt;div class="list list_two"&gt;1&lt;/div&gt;
    &lt;div class="list list_one"&gt;2&lt;/div&gt;
    &lt;div class="list list_one"&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<h3>二、CSS box-flex属性（不和谐版）</h3>

<p>改编成CSS剧本就是：</p>

<pre><code>#first_boy { box-flex: 2; }
#second_boy { box-flex: 1; }
#three_boy { width: 50px; }
</code></pre>

<p>新增CSS样式如下：</p>

<pre><code>.list_w300 { width: 300px; }
</code></pre>

<p>老三分得300像素的宽度，剩下的像素宽度老大和老二2:1比例分配。</p>

<h3>三、爸爸其实很厉害，的说~</h3>

<p>爸爸肚子中的货有：<code>box-orient, box-direction, box-align, box-pack, box-lines.</code>现在依次讲讲这里box打头的属性都是干嘛用的。</p>

<h5>box-orient</h5>

<p>待续。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css3 之 Transform]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/05/css3-zhi-transform/"/>
    <updated>2015-10-05T12:18:56+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/05/css3-zhi-transform</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
