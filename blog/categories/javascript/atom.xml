<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | 云端笔记]]></title>
  <link href="http://amy-liu.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://amy-liu.github.io/"/>
  <updated>2015-10-25T00:41:10+08:00</updated>
  <id>http://amy-liu.github.io/</id>
  <author>
    <name><![CDATA[amy-liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 变量、作用域及内存]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/25/javascript-zhi-bian-liang-,-zuo-yong-yu-ji-nei-cun/"/>
    <updated>2015-10-25T00:40:04+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/25/javascript-zhi-bian-liang-,-zuo-yong-yu-ji-nei-cun</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 Function类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/22/javascript-zhi-functionlei-xing/"/>
    <updated>2015-10-22T00:29:29+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/22/javascript-zhi-functionlei-xing</id>
    <content type="html"><![CDATA[<p>在 ECMAScript 中,Function(函数)类型实际上是对象。每个函数都是Function类型的实例,而且都与其他引用类型一样具有属性和方法 。由于函数是对象,因此函数名实际上也 是一个指向函数对象的指针。</p>

<h3>一、函数的声明方式</h3>

<ul>
<li>普通的函数声明
<code>
  function box(num1, num2) {
      return num1+ num2;
  }
</code></li>
<li>使用变量初始化函数
<code>
  var box= function(num1, num2) {
      return num1 + num2;
  };
</code></li>
<li>使用 Function 构造函数
<code>
  var box= new Function('num1', 'num2' ,'return num1 + num2');
</code>
PS: 第三种方式我们不推荐,因为这种语法会导致解析两次代码(第一次解析常 规 ECMAScript 代码,第二次是解析传入构造函数中的字符串 ),从而影响性能。但我们可以通 过这种语法来理解 &ldquo;函数是对象,函数名是指针 "的概念。</li>
</ul>


<!--more-->


<h2>二、作为值的函数</h2>

<p>ECMAScript 中的函数名本身就是变量,所以函数也可以作为值来使用。也就是说,不 仅可以像传递参数一样把一个函数传递给另一个函数 ,而且可以将一个函数作为另一个函数 的结果返回。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box(sumFunction, num) {
</span><span class='line'>    return sumFunction(num);              //Function
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function sum(num) { 
</span><span class='line'>return num + 10;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var result = box(sum, 10);            //传递函数到另一个函数里
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;三、函数内部属性&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在函数内部,有两个特殊的对象: &lt;code&gt;arguments&lt;/code&gt; 和 &lt;code&gt;this&lt;/code&gt;. &lt;code&gt;arguments&lt;/code&gt; 是一个类数组对象,包
</span><span class='line'>含着传入函数中的所有参数 ,主要用途是保存函数参数 。但这个对象还有一个名叫 &lt;code&gt;callee&lt;/code&gt; 的 属性,该属性是一个指针,指向拥有这个 &lt;code&gt;arguments&lt;/code&gt; 对象的函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(num) { 
</span><span class='line'>if (num &lt;= 1) {
</span><span class='line'>    return 1; 
</span><span class='line'>    } else {
</span><span class='line'>        return num * box(num-1);          //一个简单的的递归
</span><span class='line'>    } 
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于阶乘函数一般要用到递归算法 ,所以函数内部一定会调用自身 ;如果函数名不改变 是没有问题的,但一旦改变函数名,内部的自身调用需要逐一修改。为了解决这个问题 ,我 们可以使用 arguments.callee 来代替。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(num) { 
</span><span class='line'>if (num &lt;= 1) {
</span><span class='line'>    return 1; 
</span><span class='line'>    } else {
</span><span class='line'>        return num * arguments.callee(num-1);         //使用 callee 来执行自身 
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;函数内部另一个特殊对象是 &lt;code&gt;this&lt;/code&gt;, 其行为与 Java 和 C#中的 this 大致相似。换句话说, this 引用的是函数据以执行操作的对象 ,或者说函数调用语句所处的那个作用域 。PS:当在 全局作用域中调用函数时, &lt;code&gt;this&lt;/code&gt; 对象引用的就是 &lt;code&gt;window。&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//便于理解的改写例子&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;window.color = '红色的';            //全局的,或者 var color = '红色的';也行 
</span><span class='line'>alert(this.color);             //打印全局的 color
</span><span class='line'>var box = {
</span><span class='line'>color : '蓝色的',               //局部的 color
</span><span class='line'>sayColor : function () { 
</span><span class='line'>alert(this.color);             //此时的 this 只能 box 里的 color
</span><span class='line'>} 
</span><span class='line'>};
</span><span class='line'>box.sayColor();                    //打印局部的 color
</span><span class='line'>alert(this.color);                  //还是全局的
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;四、函数属性和方法&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ECMAScript 中的函数是对象,因此函数也有属性和方法。每个函数都包含两个属性 : &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;prototype&lt;/code&gt;。其中,&lt;code&gt;length&lt;/code&gt;属性表示函数希望接收的命名参数的个数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(name, age) { 
</span><span class='line'>alert(name + age);
</span><span class='line'>}
</span><span class='line'>alert(box.length);     //2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;PS:对于 &lt;code&gt;prototype&lt;/code&gt; 属性,它是保存所有实例方法的真正所在 ,也就是原型。这个属性, 我们将在面向对象一章详细介绍 。而 &lt;code&gt;prototype&lt;/code&gt; 下有两个方法:&lt;code&gt;apply()&lt;/code&gt;和 &lt;code&gt;call()&lt;/code&gt;,每个函数都 包含这两个非继承而来的方法 。这两个方法的用途都在特定的作用域中调用函数 ,实际上等 于设置函数体内 &lt;code&gt;this&lt;/code&gt; 对象的值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(num1, num2) {           //原函数
</span><span class='line'>return num1 + num2;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function sayBox(num1, num2) {
</span><span class='line'>return box.apply(this, [num1, num2]);          //this 表示作用域,这里是 window ,[]表示 box 所需要的参数
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function sayBox2(num1, num2) { 
</span><span class='line'>return box.apply(this, arguments);             //arguments 对象表示 box 所需要的参数
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>alert(sayBox(10,10));                             //20
</span><span class='line'>alert(sayBox2(10,10));                            //20
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;call()&lt;/code&gt; 方法于 &lt;code&gt;apply()&lt;/code&gt; 方法相同,他们的区别仅仅在于接收参数的方式不同 。对于 &lt;code&gt;call()&lt;/code&gt; 方 法而言,第一个参数是作用域,没有变化,变化只是其余的参数都是直接传递给函数的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;待续&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[JavaScript 之 对象和数组]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-10-20T22:19:20+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;什么是对象,其实就是一种类型,即引用类型。而对象的值就是引用类型的实例。 在 ECMAScript 中引用类型是一种数据结构,用于将数据和功能组织在一起。它也常被称做为 类,但 ECMAScript 中却没有这种东西。虽然 ECMAScript 是一门面向对象的语言,却不具 备传统面向对象语言所支持的类和接口等基本结构。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;一、Object 类型&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;到目前为止,我们使用的引用类型最多的可能就是 Object 类型了。虽然 Object 的实例
</span><span class='line'>不具备多少功能,但对于在应用程序中的存储和传输数据而言,它确实是非常理想的选择 。 创建 Object 类型有两种。一种是使用 new 运算符,一种是字面量表示法。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1.使用 new 运算符创建 Object
</span><span class='line'>&lt;code&gt;
</span><span class='line'>var box = new Object();     //new 方式    new 关键字可以省略
</span><span class='line'>box.name = 'amy';           //创建属性字段
</span><span class='line'>box.age = 28;               //创建属性字段
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2.使用字面量方式创建 Object&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {              //字面量方式
</span><span class='line'>name : '李',         //创建属性字段
</span><span class='line'>age : 28 
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;!--more--&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3.属性字段也可以使用字符串形式&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {
</span><span class='line'>'name' : '李炎恢',             //也可以用字符串形式
</span><span class='line'>'age' : 28 
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4.使用字面量及传统附值方式&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {};                     //字面量方式声明空的对象
</span><span class='line'>box.name = '李炎恢';               //点符号给属性付值
</span><span class='line'>box.age = 28;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;5.两种属性输出方式&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;alert(box.age);                   //点 表示法输出
</span><span class='line'>alert(box['age']);                //中括号表示法输出,注意引号不能省
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;6.给对象创建方法&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {
</span><span class='line'>run : function () {           //对象中的方法
</span><span class='line'>return '运行';
</span><span class='line'>} 
</span><span class='line'>}
</span><span class='line'>alert(box.run());                 //调用对象中的方法
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;7.使用 delete 删除对象属性&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;delete box.name;                 //删除属性
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在实际开发过程中,一般我们更加喜欢字面量的声明方式。因为它清晰,语法代码少 , 而且还给人一种封装的感觉。字面量也是向函数传递大量可选参数的首选方式。</span></code></pre></td></tr></table></div></figure>
    function box(obj) {                                 //参数是一个对象
        if (obj.name != undefined) alert(obj.name);     //判断属性是否存在
        if (obj.age != undefined) alert(obj.age);
    }</p>

<pre><code>box({                                    //调用函数传递一个对象
    name : '李炎恢',
    age : 28 
});
</code></pre>

<pre><code class="">
## 二、Array 类型

除了 Object 类型之外,Array 类型是 ECMAScript 最常用的类型。而且 ECMAScript 中
的 Array 类型和其他语言中的数组有着很大的区别 。虽然数组都是有序排列 ,但 ECMAScript 中的数组每个元素可以保存任何类型。 ECMAScript 中数组的大小也是可以调整的。

创建 Array 类型有两种方式:第一种是 new 运算符,第二种是字面量。

1.使用 new 关键字创建数组

    var box = new Array();                              //创建了一个数组           
    var box = new Array(10);                            //创建一个包含 10 个元素的数组
    var box = new Array('李',28,'教师','盐城');          //创建一个数组并分配好了元素   都可以省略 new 关键字


2.使用字面量方式创建数组

    var box = [];                           //创建一个空的数组
    var box = ['李',28,'教师','盐城'];       //创建包含元素的数组
    var box = [1,2,];                      //禁止这么做,IE 会识别 3 个元素   最后的逗号要删掉
    var box = [,,,,,];                     //同样,IE 的会有识别问题

3.使用索引下标来读取数组的值 

    alert(box[2]);              //获取第三个元素
    box[2] = '学生';             //修改第三个元素 
    box[4] = '计算机编程';        //增加第五个元素

4.使用 `length` 属性获取数组元素量 

    alert(box.length)               //获取元素个数
    box.length = 10;                //强制给元素个数
    box[box.length] = 'JS 技术';     //通过 length 给数组最后面增加一个元素


5.创建一个稍微复杂一点的数组 

    var box = [             

                {                                     //第一个元素是一个对象
                name : '李炎恢', age : 28,
                run : function () {
                return 'run 了'; 
                    }
                },
                ['马云','李彦宏',new Object()],        //第二个元素是数组
                '江苏',                               //第三个元素是字符串 
                25+25,                               //第四个元素是数值
                new Array(1,2,3)                     //第五个元素是数组

            ]; 

        alert(box);

PS:数组最多可包含 4294967295 个元素,超出即会发生异常。

## 三、对象中的方法

转换方法

对象或数组都具有 `toLocaleString()` `toString()`和 `valueOf()` 方法。其中 `toString()` 和 `valueOf()` 重写了谁,都会返回相同的值。数组会将每个值进行字符串形式的拼接以逗号隔开 。

    var box = ['李',28,'计算机编程'];             //字面量数组 
    alert(box);                                    //隐式调用了 toString() 
    alert(box.toString());                         //和 valueOf()返回一致
    alert(box.toLocaleString());                   //返回值和上面两种一致

默认情况下,数组字符串都会以逗号隔开。如果使用 `join()` 方法,则可以使用不同的分 隔符来构建这个字符串。

    var box = ['李', 28, '计算机编程'];
    alert(box.join('|'));                       //李炎恢|28|计算机编程

栈方法

ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法。也就是说,可以让数组像栈一样,可以限制插入和删除项的数据结构。栈是一种数据结构 (后进先出),也 就是说最新添加的元素最早被移除。而栈中元素的插入 (或叫推入)和移除(或叫弹出),只发 生在一个位置——栈的顶部。ECMAScript 为数组专门提供了 `push()`和 `pop()` 方法。

`push()` 方法可以接收任意数量的参数 ,把它们逐个添加到数组的末尾 ,并返回修改后数 组的长度。而 `pop()` 方法则从数组末尾移除最后一个元素,减少数组的 `length` 值,然后返回 移除的元素。
</code></pre>

<pre><code>var box = ['李', 28, '计算机编程'];               //字面量声明
alert(box.push(' 盐城'));                           //数组末尾添加一个元素 ,并且返回长度 
alert(box);                                        //查看数组
box.pop();                                         //移除数组末尾元素 ,并返回移除的元素 
alert(box);                                        //查看元素
</code></pre>

<pre><code>
队列方法

栈方法是后进先出 ,而列队方法就是先进先出 。列队在数组的末端添加元素 ,从数组的 前端移除元素。通过 `push()`向数组末端添加一个元素,然后通过 `shift()` 方法从数组前端移除 一个元素。
</code></pre>

<pre><code>var box = ['李', 28, '计算机编程'];                    //字面量声明
alert(box.push(' 盐城'));                             //数组末尾添加一个元素 ,并且返回长度
alert(box);
alert(box.shift());                                  //移除数组开头元素 ,并返回移除的元素 
alert(box);
</code></pre>

<pre><code>
ECMAScript 还为数组提供了一个 `unshift()` 方法,它和 `shift()` 方法的功能完全相反。 `unshift()`方法为数组的前端添加一个元素。
</code></pre>

<pre><code>var box = ['李炎恢', 28, '计算机编程'];            //字面量声明
alert(box.unshift('盐城','江苏'));                //数组开头添加两个元素
alert(box);
alert(box.pop());                                //移除数组末尾元素 ,并返回移除的元素 /
alert(box);
</code></pre>

<p>```
PS:IE 浏览器对 unshift()方法总是返回 undefined 而不是数组的新长度。</p>

<p>重排序方法</p>

<p>数组中已经存在两个可以直接用来排序的方法: <code>reverse()</code> 和 <code>sort()</code> 。</p>

<p><code>reverse()</code> 逆向排序</p>

<pre><code>var box = [1,2,3,4,5];              //数组 
alert(box.reverse());               //逆向排序方法,返回排序后的数组 
alert(box);                         //源数组也被逆向排序了,说明是引用
</code></pre>

<p>sort() 从小到大排序</p>

<pre><code>var box = [4,1,7,3,9,2];               //数组
alert(box.sort());                     //从小到大排序,返回排序后的数组 
alert(box);                             //源数组也被从小到大排序了
</code></pre>

<p>sort 方法的默认排序在数字排序上有些问题 ,因为数字排序和数字字符串排序的算法是 一样的。我们必须修改这一特征,修改的方式,就是给 sort(参数)方法传递一个函数参数。 这点可以参考手册说明。</p>

<pre><code>function compare(value1, value2) {            //数字排序的函数参数 
    if (value1 &lt; value2) {                    //小于,返回负数
            return -1;
        } else if (value1 &gt; value2) {         //大于,返回正数
        return 1; } else {
            return 0;                         //其他,返回 0
        }
        }
var box = [0,1,5,10,15];                      //验证数字字符串,和数字的区别
alert(box.sort(compare));                     //传参
</code></pre>

<p>操作方法</p>

<p>ECMAScript 为操作已经包含在数组中的元素提供了很多方法 。<code>concat()</code>方法可以基于当 前数组创建一个新数组。<code>slice()</code>方法可以基于当前数组获取指定区域元素并创建一个新数组 。 <code>splice()</code>主要用途是向数组的中部插入元素。</p>

<pre><code>var box = ['李', 28, '盐城'];                       //当前数组 
var box2 = box.concat('计算机编程');                //创建新数组,并添加新元素 
alert(box2);                                      //输出新数组 
alert(box);                                       //当前数组没有任何变化

var box = ['李', 28, '盐城'];                      //当前数组
var box2 = box.slice(1);                          //box.slice(1,3) ,2-4 之间的元素
alert(box2);                                      //28,盐城
alert(box);                                       //当前数组
</code></pre>

<p> splice 中的删除功能:</p>

<pre><code>var box = ['李', 28, '盐城'];                  //当前数组
var box2 = box.splice(0,2);                      //截取前两个元素 
alert(box2);                                     //返回截取的元素 
alert(box);                                      //当前数组被截取的元素被删除
</code></pre>

<p>splice 中的插入功能:</p>

<pre><code>var box = ['李', 28, '盐城'];
var box2 = box.splice(1,0,'计算机编程','江苏');         //没有截取,但插入了两条    
alert(box2);                                          //在第 2 个位置插入两条
alert(box);
</code></pre>

<p>splice 中的替换功能:</p>

<pre><code>var box = ['李', 28, '盐城']; 
var box2 = box.splice(1,1,100);                  //截取了第 2 条,替换成 100
alert(box2);                                     //输出截取的 28
alert(box);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 函数]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/18/javascrhan-shu/"/>
    <updated>2015-10-18T21:15:57+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/18/javascrhan-shu</id>
    <content type="html"><![CDATA[<h3>一、函数声明</h3>

<p>函数对任何语言来说都是一个核心的概念 。通过函数可以封装任意多条语句 ,而且可以 在任何地方、任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明,后跟 一组参数以及函数体。</p>

<pre><code>function box() {                              //没有参数的函数 
    alert('只有函数被调用,我才会被之执行 ');
} box();                                      //直接调用函数

function box(name, age) {                     //带参数的函数
    alert('你的姓名:'+name+',年龄:'+age);
}
box('李',28);                                 //调用函数,并传参
</code></pre>

<h2>二、return 返回值</h2>

<p>带参和不带参的函数 ,都没有定义返回值 ,而是调用后直接执行的 。实际上,任何函数 都可以通过 return 语句跟后面的要返回的值来实现返回值。</p>

<!--more-->


<pre><code>function box() {                     //没有参数的函数
    return '我被返回了!';             //通过 return 把函数的最终值返回
} 
alert(box());                       //调用函数会得到返回值 ,然后外面输出


function box(name, age) {                      //有参数的函数
    return '你的姓名:'+name+',年龄:'+age;        //通过 return 把函数的最终值返回
}
alert(box('李炎恢', 28));                       /调用函数得到返回值,然后外面输出
</code></pre>

<p>我们还可以把函数的返回值赋给一个变量,然后通过变量进行操作。</p>

<pre><code>function box(num1, num2) { 
    return num1 * num2;
}
var num = box(10, 5); //函数得到的返回值赋给变量 
alert(num);
</code></pre>

<p><code>return</code> 语句还有一个功能就是退出当前函数 ,注意和 <code>break</code> 的区别。PS: <code>break</code> 用在循环 和 <code>switch</code> 分支语句里。</p>

<pre><code>function box(num) {
    if (num &lt; 5) return num;            //满足条件,就返回 num
    return 100;                         //返回之后,就不执行下面的语句了
} alert(box(10));
</code></pre>

<h2>三、arguments 对象</h2>

<p>ECMAScript 函数不介意传递进来多少参数,也不会因为参数不统一而错误。实际上, 函数体内可以通过 arguments 对象来接收传递进来的参数。</p>

<pre><code>function box() {
    return arguments[0]+' | '+arguments[1];           //得到每次参数的值
}
alert(box(1,2,3,4,5,6));                              //传递参数
</code></pre>

<p>arguments 对象的 length 属性可以得到参数的数量。</p>

<pre><code>function box() {
    return arguments.length;            //得到 6
    }
alert(box(1,2,3,4,5,6));
</code></pre>

<p>我们可以利用 <code>length</code> 这个属性,来智能的判断有多少参数 ,然后把参数进行合理的应用 。 比如,要实现一个加法运算,将所有传进来的数字累加,而数字的个数又不确定。</p>

<pre><code>function box() { 
var sum = 0;
    if (arguments.length == 0) return sum;                //如果没有参数,退出
    for(var i = 0;i &lt; arguments.length; i++) {            //如果有,就累加
    sum = sum + arguments[i]; 
    }
return sum;                                               //返回累加结果
}
alert(box(5,9,12));
</code></pre>

<p>ECMAScript 中的函数,没有像其他高级语言那种函数重载功能。</p>

<pre><code>function box(num) {
    return num + 100; 
}

function box (num) {              //会执行这个函数
    return num + 200;             //返回结果
} 
alert(box(50));
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 流程控制语句]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/18/javascript-zhi-liu-cheng-kong-zhi-yu-ju/"/>
    <updated>2015-10-18T20:41:18+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/18/javascript-zhi-liu-cheng-kong-zhi-yu-ju</id>
    <content type="html"><![CDATA[<h3>一、语句的定义</h3>

<p>语句的种类
```
    声明语句   变量声明语句   var box = 100;
              标签声明语句   label : box;</p>

<pre><code>达式语句   变量赋值语句    box = 100;
          函数调用语句    box();
          属性赋值语句    box.property = 100;
          方法调用语句    box.method();

分支语句   条件分支语句    if () {} else {}
          多重分支语句    switch () { case n : ...};
</code></pre>

<p>```
语句的种类 (续)</p>

<!--more-->


<pre><code>    循环语句       for            for (;;;) {}
                  for ... in     for ( x in x) {}
                  while          while () {};
                  do ... while   do {} while ();

    控制结构       继续执行子句     continue ;
                  终断执行子句     break ;
                  函数返回子句     return ;
                  异常触发子句     throw ;
                  异常捕获与处理    try {} catch () {} finally {}

    其他           空语句          ;
                   with 语句      with () {}
</code></pre>

<h3>二、if 语句</h3>

<p>略</p>

<h2>三、switch 语句</h2>

<p>switch 语句是多重条件判断,用于多个值相等的比较。
<code>
    var box = 1;
    switch (box) {                        //用于判断 box 相等的多个值
        case 1 :
            alert('one');
            break;                        //break;用于防止语句的穿透
        case 2 :
            alert('two');
            break;
        case 3 :
            alert('three');
            break;
            default :                    //相当于 if 语句里的 else,否则的意思
            alert('error');
    }
</code></p>

<h2>四、do&hellip;while 语句</h2>

<p>do&hellip;while 语句是一种先运行,后判断的循环语句。也就是说,不管条件是否满足,至少先运行一次循环体。</p>

<pre><code>var box = 1;       //如果是 1,执行五次,如果是 10,执行 1 次     
do {
    alert(box);
    box++;
} while (box &lt;= 5);   //先运行一次,再判断
</code></pre>

<h2>五、while 语句</h2>

<p>while 语句是一种先判断,后运行的循环语句。也就是说,必须满足条件了之后,方可运行循环体。</p>

<pre><code>var box = 1;        //如果是 1,执行五次,如果是 10,不执行 
while (box &lt;= 5) {  //先判断,再执行
    alert(box);
    box++; 
}
</code></pre>

<h2>六、for 语句</h2>

<p>for 语句也是一种先判断,后运行的循环语句。但它具有在执行循环之前初始变量和定义循环后要执行代码的能力。</p>

<pre><code>for (var box = 1; box &lt;= 5 ; box++) {     //第一步,声明变量 var box = 1;
    alert(box);                           //第二步,判断 box &lt;=5
}                                         //第三步,alert(box)
                                          //第四步,box++ //第五步,从第二步再来,直到判断为 false
</code></pre>

<h2>七、 for&hellip;in 语句</h2>

<p>for&hellip;in 语句是一种精准的迭代语句,可以用来枚举对象的属性。</p>

<pre><code>var box = {                         //创建一个对象 
    'name' : '李炎恢',               //键值对,左边是属性名,右边是值
    'age' : 28,
    'height' : 178 };
for (var p in box) {                //列举出对象的所有属性
    alert(p);
</code></pre>

<h2>八、break 和 continue 语句</h2>

<p>break 和 continue 语句用于在循环中精确地控制代码的执行 。其中,break 语句会立即退出循环,强制继续执行循环体后面的语句 。而 continue 语句退出当前循环,继续后面的循环。</p>

<pre><code>for (var box = 1; box &lt;= 10; box++) {
    if (box == 5) break;                //如果 box 是 5,就退出循环
    document.write(box); 
    document.write('&lt;br /&gt;');
}
</code></pre>

<p>continue</p>

<pre><code>for (var box = 1; box &lt;= 10; box++) { 
    if (box == 5) continue;      //如果 box 是 5,就退出当前循环
    document.write(box); 
    document.write('&lt;br /&gt;');
}
</code></pre>

<h2>九、with 语句</h2>

<p>with 语句的作用是将代码的作用域设置到一个特定的对象中。</p>

<pre><code>var box = {                  //创建一个对象 
    'name' : '李炎恢',        //键值对
    'age' : 28,
    'height' : 178 
};
var n = box.name;            //从对象里取值赋给变量
var a = box.age; 
var h = box.height;
</code></pre>

<p>可以将上面的三段赋值操作改写成:</p>

<pre><code>with (box) {                 //省略了 box 对象名   
    var n = name;           
    var a = age;            
    var h = height;         
}
</code></pre>
]]></content>
  </entry>
  
</feed>
