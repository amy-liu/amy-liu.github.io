<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[云端笔记]]></title>
  <link href="http://amy-liu.github.io/atom.xml" rel="self"/>
  <link href="http://amy-liu.github.io/"/>
  <updated>2015-10-14T22:44:28+08:00</updated>
  <id>http://amy-liu.github.io/</id>
  <author>
    <name><![CDATA[amy-liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jQuery 之 高级事件]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-gao-ji-jian/"/>
    <updated>2015-10-14T22:34:16+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-gao-ji-jian</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 事件对象]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-shi-jian-dui-xiang/"/>
    <updated>2015-10-14T21:58:43+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/14/jquery-zhi-shi-jian-dui-xiang</id>
    <content type="html"><![CDATA[<p>事件对象就是 <code>event</code> 对象,通过处理函数默认传递接受。之前处理函数的 <code>e</code> 就是 <code>event</code> 事件对象。</p>

<h3>一、事件对象</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', function (e) {       //接受事件对象参数
</span><span class='line'>  alert(e); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>通过 event.type 属性获取触发事件名</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert(e.type); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>通过 event.target 获取绑定的 DOM 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert(e.target); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>通过 event.data 获取额外数据,可以是数字、字符串、数组、对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', 123, function () {          //传递 data 数据 
</span><span class='line'>  alert(e.data);                                   //获取数字数据
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 如果字符串就传递:<code>'123'</code>、如果是数组就传递: <code>[123,'abc']</code> ,如果是对象就传递: <code>{user : 'Lee', age : 100}</code> 。数组的调用方式是: <code>e.data[1],</code> 对象的调用方式是: <code>e.data.user。</code></p>

<p>event.data 获取额外数据,对于封装的简写事件也可以使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click({user : 'Lee', age : 100},function (e) {
</span><span class='line'>  alert(e.data.user); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 键值对的键可以加上引号,也可以不加;在调用的时候也可以使用数组的方式: <code>alert(e.data['user']);</code></p>

<p>获取移入到 div 之前的那个 DOM 元素</p>

<pre><code>$('div').mouseover(function (e) {
    alert(e.relatedTarget); 
});
</code></pre>

<p>获取移出 div 之后到达最近的那个 DOM 元素</p>

<pre><code>$('div').mouseout(function (e) {
    alert(e.relatedTarget);
 });
</code></pre>

<p>获取绑定的那个 DOM 元素,相当于 this,区别与 <code>event.target</code></p>

<pre><code>$('div').click(function (e) {
    alert(e.currentTarget); 
});
</code></pre>

<p>注意 : <code>event.target</code> 得到的是触发元素的 DOM,<code>event.currentTarget</code> 得到的是监听元素的 DOM。而 <code>this</code>也是得到监听元素的 DOM。</p>

<p>获取上一次事件的返回值</p>

<pre><code>$('div').click(function (e) {
    return '123'; 
});
$('div').click(function (e) { 
    alert(e.result);
});
</code></pre>

<p>获取当前的时间戳</p>

<pre><code>$('div').click(function (e) {
    alert(e.timeStamp); 
});
</code></pre>

<p>获取触发元素鼠标当前的位置</p>

<pre><code>$(document).click(function (e) {
    alert(e.screenY+ ',' + e.pageY + ',' + e.clientY); 
});
</code></pre>

<h3>二、冒泡和默认行为</h3>

<p>如果在页面中重叠了多个元素,并且重叠的这些元素都绑定了同一个事件,那么就会出 现冒泡问题。</p>

<p>jQuery 提供了一个事件对象的方法: <code>event.stopPropagation();</code> 这个方法设置到需要触发 的事件上时,所有上层的冒泡行为都将被取消。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) { 
</span><span class='line'>  alert('按钮被触发了!'); 
</span><span class='line'>  e.stopPropagation();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>默认行为</p>

<p>网页中的元素,在操作的时候会有自己的默认行为。比如:右击文本框输入区域,会弹 出系统菜单、点击超链接会跳转到指定页面、点击提交按钮会提交数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('a').click(function (e) { 
</span><span class='line'>  e.preventDefault();
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>禁止提交表单跳转</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('form').submit(function (e) {
</span><span class='line'>  e.preventDefault(); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : 如果想让上面的超链接同时阻止默认行为且禁止冒泡行为,可以把两个方法同时 写上: <code>event.stopPropagation()</code> 和 <code>event.preventDefault()</code> 。这两个方法如果需要同时启用的时候, 还有一种简写方案代替,就是直接 <code>return false。</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('a').click(function (e) { 
</span><span class='line'>  return false;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>冒泡和默认行为的一些方法</h2>

<p>判断是否取消了元素的默认行为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $('input').keyup(function (e) {
</span><span class='line'>  e.preventDefault();
</span><span class='line'>  alert(e.isDefaultPrevented()); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>取消冒泡并取消后续事件处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').click(function (e) {
</span><span class='line'>  alert('input');
</span><span class='line'>  e.stopImmediatePropagation();
</span><span class='line'> });
</span><span class='line'>
</span><span class='line'>$('input').click(function () { 
</span><span class='line'>  alert('input2');
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>$(document).click(function () { 
</span><span class='line'>  alert('document');
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>判断是否调用了 <code>stopPropagation()</code> 方法</p>

<pre><code>$('input').click(function (e) {
    e.stopPropagation();
    alert(e.isPropagationStopped()); 
});
</code></pre>

<p>判断是否执行了 <code>stopImmediatePropagation()</code> 方法</p>

<pre><code>$('input').click(function (e) {
    e.stopImmediatePropagation();
    alert(e.isImmediatePropagationStopped());
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 基础事件]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/13/jquery-zhi-ji-chu-shi-jian/"/>
    <updated>2015-10-13T21:42:16+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/13/jquery-zhi-ji-chu-shi-jian</id>
    <content type="html"><![CDATA[<p>在 JavaScript 课程的学习中,我们掌握了很多使用的事件,常用的事件有:<code>click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、change、select、submit、keydown、 keypress、keyup、blur、focus、load、resize、scroll、error。</code>那么,还有更多的事件可以参考 手册中的事件部分。</p>

<h3>一、绑定事件</h3>

<p>jQuery 通过 <code>.bind()</code> 方法来为元素绑定这些事件。可以传递三个参数<code>bind(type, [data], fn),</code>  <code>type</code> 表示一个或多个类型的事件名字符串; <code>[data]</code> 是可选的,作为 <code>event.data</code> 属性值传递一个 额外的数据,这个数据是一个字符串、一个数字、一个数组或一个对象;fn 表示绑定到指 定元素的处理函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', function () {    //点击按钮后执行匿名函数
</span><span class='line'>  alert('点击!'); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>普通处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('click', fn);       //执行普通函数式无须圆括号
</span><span class='line'>  function fn() {
</span><span class='line'>  alert('点击!'); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以同时绑定多个事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind('mouseout mouseover', function () {    //移入和移出分别执行一次
</span><span class='line'>  $('div').html(function (index, value) { 
</span><span class='line'>      return value + '1';
</span><span class='line'>  }); 
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>通过对象键值对绑定多个参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').bind({             传递一个对象 
</span><span class='line'>  'mouseout' : function () {     //事件名的引号可以省略
</span><span class='line'>      alert('移出');
</span><span class='line'>  },
</span><span class='line'>  'mouseover' : function () {
</span><span class='line'>      alert('移入'); 
</span><span class='line'>  }
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>使用 unbind 删除绑定的事件</p>

<pre><code> $('input').unbind();
</code></pre>

<p>使用 unbind 参数删除指定类型事件</p>

<pre><code>$('input').unbind('click');
</code></pre>

<p><code>.mouseover()和.mouseout()</code> 表示鼠标移入和移出的时候触发。<code>.mouseenter()和.mouseleave()</code> 这组穿过,子元素不会触发。</p>

<p><code>.keydown()、.keyup()</code>返回的是键码,而 <code>.keypress</code>  返回的是字符编码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').keydown(function (e) {
</span><span class='line'>  alert(e.keyCode);
</span><span class='line'>});
</span><span class='line'>$('input').keypress(function (e) { 
</span><span class='line'>  alert(e.charCode);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><code>.focus()和.blur()</code> 分别表示光标激活和丢失,事件触发时机是当前元素。而<code>.focusin() 和.focusout()</code> 也表示光标激活和丢失,但事件触发时机可以是子元素。</p>

<h2>二、复合事件</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').hover(function () {                    //mouseenter 效果
</span><span class='line'>      $(this).css('background', 'black'); 
</span><span class='line'>  }, function () {                            //mouseleave 效果  可省略
</span><span class='line'>      $(this).css('background', 'red');
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>注意 : <code>.hover()</code> 方法是结合了 <code>.mouseenter()</code> 方法和 <code>.mouseleva()</code> 方法,并非 <code>.mouseover()</code> 和 <code>.mouseout()</code> 方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 DOM节点操作]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/13/jquery-domjie-dian-cao-zuo/"/>
    <updated>2015-10-13T00:33:04+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/13/jquery-domjie-dian-cao-zuo</id>
    <content type="html"><![CDATA[<p>DOM 中有一个非常重要的功能,就是节点模型,也就是 DOM 中的“M”。</p>

<h3>一、创建节点</h3>

<p>为了使页面更加智能化,有时我们想动态的在 html 结构页面添加一个元素标签,那么在插入之前首先要做的动作就是:创建节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var box = $('&lt;div id="box"&gt;节点&lt;/div&gt;');         //创建一个节点 
</span><span class='line'>$('body').append(box);                           //将节点插入到&lt;body&gt;元素内部</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>二、插入节点</h2>

<h4>> 内部插入节点方法:</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').append('&lt;strong&gt;节点&lt;/strong&gt;');    //向 div 内部插入 strong 节点 
</span><span class='line'>$('div').append(function (index, html) {    //使用匿名函数插入节点,html 是原节点
</span><span class='line'>  return '&lt;strong&gt;节点&lt;/strong&gt;';
</span><span class='line'>￼￼});
</span><span class='line'>
</span><span class='line'>$('span').appendTo('div');                 //讲 span 节点移入 div 节点内
</span><span class='line'>$('span').appendTo($('div'));              //同上
</span><span class='line'>
</span><span class='line'>$('div').prepend('&lt;span&gt;节点&lt;/span&gt;');     //将 span 插入到 div 内部的前面 
</span><span class='line'>$('div').append(function (index, html) {  //使用匿名函数,同上
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;'; 
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>$('span').prependTo('div');               //将 span 移入 div 内部的前面
</span><span class='line'>$('span').prependTo($('div'));            //同上</span></code></pre></td></tr></table></div></figure>


<h4>> 外部插入节点方法:</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').after('&lt;span&gt;节点&lt;/span&gt;');           //向 div 的同级节点后面插入 span
</span><span class='line'>$('div').after(function (index, html) {       //使用匿名函数,同上
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;';
</span><span class='line'>  });
</span><span class='line'>$('div').before('&lt;span&gt;节点&lt;/span&gt;');         //向 div 的同级节点前面插入 span
</span><span class='line'>$('div').before(function (index, html) { 
</span><span class='line'>  return '&lt;span&gt;节点&lt;/span&gt;';
</span><span class='line'>  }); 
</span><span class='line'>$('span').insertAfter('div');                //将 span 元素移到 div 元素外部的后面
</span><span class='line'>$('span').insertBefore('div');               //将 span 元素移到 div 元素外部的前面</span></code></pre></td></tr></table></div></figure>


<h4>> 包裹节点</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').wrap('&lt;strong&gt;&lt;/strong&gt;');                   //在 div 外层包裹一层 strong
</span><span class='line'>$('div').wrap('&lt;strong&gt;123&lt;/strong&gt;');                //包裹的元素可以带内容
</span><span class='line'>$('div').wrap('&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;');          //包裹多个元素
</span><span class='line'>$('div').wrap($('strong').get(0));                    //也可以包裹一个原生 DOM 
</span><span class='line'>$('div').wrap(document.createElement('strong'));      //临时的原生DOM
</span><span class='line'>$('div').wrap(function (index) {
</span><span class='line'>  return '&lt;strong&gt;&lt;/strong&gt;'; 
</span><span class='line'>  });
</span><span class='line'>$('div').unwrap();                                    //移除一层包裹内容,多个需移除多次
</span><span class='line'>$('div').wrapAll('&lt;strong&gt;&lt;/strong&gt;');                //所有 div 外面只包一层 strong
</span><span class='line'>$('div').wrapAll($('strong').get(0)); 
</span><span class='line'>$('div').wrapInner('&lt;strong&gt;&lt;/strong&gt;');              //向指定元素的子内容包裹一层 html 
</span><span class='line'>$('div').wrapInner($('strong').get(0));               //DOM 节点
</span><span class='line'>$('div').wrapInner(function () {
</span><span class='line'>  return '&lt;strong&gt;&lt;/strong&gt;'; 
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<h2>三、节点操作</h2>

<pre><code>$('body').append($('div').clone(true));     //复制一个节点添加到 HTML 中
</code></pre>

<p>注意 : <code>clone(true)</code> 参数可以为空,表示只复制元素和内容,不复制事件行为。而加上 <code>true</code> 参数的话,这个元素附带的事件处理行为也复制出来。</p>

<pre><code>$('div').remove(); //直接删除 div 元素
</code></pre>

<p>注意 : <code>.remove()</code> 不带参数时,删除前面对象选择器指定的元素。而<code>.remove()</code> 也可以 带选择符参数的,比如 :<code>$('div').remove('#box');</code> 只删除 <code>id=box</code>  的<code>div。</code></p>

<pre><code>$('div').detach(); //保留事件行为的删除
</code></pre>

<p>注意 : <code>.remove()</code> 和 <code>.detach()</code> 都是删除节点,而删除后本身方法可以返回当前被删除的节 点对象,但区别在于前者在恢复时不保留事件行为,后者则保留。</p>

<pre><code>$('div').empty();   //删除掉节点里的内容
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').replaceWith('&lt;span&gt;节点&lt;/span&gt;');      //将 div 替换成 span 元素
</span><span class='line'>$('&lt;span&gt;节点&lt;/span&gt;').replaceAll('div');        //同上</span></code></pre></td></tr></table></div></figure>


<p>注意 : 节点被替换后,所包含的事件行为就全部消失了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 基础DOM操作]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/10/jquery-zhi-ji-chu-domhe-csscao-zuo/"/>
    <updated>2015-10-10T21:00:03+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/10/jquery-zhi-ji-chu-domhe-csscao-zuo</id>
    <content type="html"><![CDATA[<h3>一、设置元素及内容</h3>

<p>在常规的 DOM 元素中,使用 html()和 text()方法获取内部的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('#box').html();                       //获取 html 内容 
</span><span class='line'>$('#box').text();                       //获取文本内容,会自动清理 html 标签
</span><span class='line'>$('#box').html('&lt;em&gt;www.li.cc&lt;/em&gt;');   //设置 html 内容 
</span><span class='line'>$('#box').text('&lt;em&gt;www.li.cc&lt;/em&gt;');   //设置文本内容,会自动转义 html 标签</span></code></pre></td></tr></table></div></figure>


<p>使用 html()或 text()设置元素里的内容时,会清空原来的数据。而我们期 望能够追加数据的话,需要先获取原本的数据。</p>

<pre><code>$('#box').html($('#box').html() + '&lt;em&gt;www.li.cc&lt;/em&gt;'); //追加数据
</code></pre>

<p>如果元素是表单的话,jQuery 提供了 <code>val()</code>方法进行获取或设置内部的文本数据。</p>

<pre><code>$('input').val(); //获取表单内容 
$('input').val('www.li.cc'); //设置表单内容
</code></pre>

<p>如果想设置多个选项的选定状态,比如下拉列表、单选复选框等等,可以通过数组传递 操作。</p>

<pre><code>$("input").val(["check1","check2", "radio1" ]); //value 值是这些的将被选定
</code></pre>

<!--more-->


<h2>二、元素属性操作</h2>

<p>除了对元素内容进行设置和获取,通过 jQuery 也可以对元素本身的属性进行操作,包 括获取属性的属性值、设置属性的属性值,并且可以删除掉属性。</p>

<pre><code>$('div').attr('title');                            //获取属性的属性值
$('div').attr('title', '我是域名');                 //设置属性及属性值 
$('div').attr('title', function () {               //通过匿名函数返回属性值
    return '我是域名';});
$('div').attr('title', function (index, value) {  
    return value + (index+1) + ',我是域名';          //可以接受两个参数
});
</code></pre>

<p>注意: <code>attr()</code>方法里的 <code>function() {},</code>可以不传参数。可以只传一个参数 index,表示当前 元素的索引(从 0 开始)。也可以传递两个参数 index、value,第二个参数表示属性原本的值。</p>

<p>注意: jQuery 中很多方法都可以使用 <code>function() {}</code>来返回出字符串,比如<code>html()、text()、 val()</code>和上一章刚学过的 <code>is()、filter()</code>方法。而如果又涉及到多个元素集合的话,还可以传递 <code>index</code> 参数来获取索引值,并且可以使用第二个参数 <code>value</code>(并不是所有方法都适合,有兴趣 可以自己逐个尝试)。</p>

<pre><code>$('div').html(function (index) { //通过匿名函数赋值,并传递 index 
    return '我是' + (index+1) + '号 div';
});
$('div').html(function (index, value) { //还可以实现追加内容
     return '我是' + (index+1) + '号 div:'+value ;
});
$('div').removeAttr('title'); //这个方法就不可以使用匿名函数,传递 index 和 value 均无效。
</code></pre>

<h2>三、元素样式操作</h2>

<p>元素样式操作包括了直接设置 CSS 样式、增加 CSS 类别、类别切换、删除类别这几种操作方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').css('color');                   //获取元素行内 CSS 样式的颜色 
</span><span class='line'>$('div').css('color', 'red');           //设置元素行内 CSS 样式颜色为红色</span></code></pre></td></tr></table></div></figure>


<p>也可以获取多个 CSS 样式,而获取到的是一个对象数组,如果用 传统方式进行解析需要使用 for in 遍历。</p>

<pre><code>var box = $('div').css(['color', 'height', 'width']);              //得到多个 CSS 样式的数组对象 
    for (var i in box) {                                           //逐个遍历出来
    alert(i + ':' + box[i]); }
</code></pre>

<p>jQuery 提供了一个遍历工具专门来处理这种对象数组,<code>$.each()</code>方法,这个方法可以轻 松的遍历对象数组。</p>

<pre><code>$.each(box, function (attr, value) { //遍历 JavaScript 原生态的对象数组 
    alert(attr + ':' + value);
});
</code></pre>

<p>使用<code>$.each()</code>可以遍历原生的 JavaScript 对象数组,如果是 jQuery 对象的数组怎么使 用<code>.each()</code>方法呢?</p>

<pre><code>$('div').each(function (index, element) { //index 为索引,element 为元素 DOM 
    alert(index + ':' + element);
});
</code></pre>

<p>在需要设置多个样式的时候,我们可以传递多个 CSS 样式的键值对即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $('div').css({
</span><span class='line'>      'background-color' : '#ccc', 
</span><span class='line'>      'color' : 'red',
</span><span class='line'>      font-size' : '20px' 
</span><span class='line'>  });</span></code></pre></td></tr></table></div></figure>


<p> CSS 类的样式切换功能。</p>

<pre><code>$('div').click(function () { //当点击后触发
    $(this).toggleClass('red size'); //单个样式多个样式均可 
    });
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('div').click(function () { 
</span><span class='line'>  $(this).toggleClass(function () {
</span><span class='line'>      if ($(this).hasClass('red')) { 
</span><span class='line'>          $(this).removeClass('red'); 
</span><span class='line'>          return 'green';
</span><span class='line'>      } else { 
</span><span class='line'>          $(this).removeClass('green');
</span><span class='line'>          return 'red';
</span><span class='line'>      } 
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>四、CSS 方法</h2>

<p>jQuery 不但提供了 CSS 的核心操作方法,比如.css()、.addClass()等。还封装了一些特殊功能的 CSS 操作方法,我们分别来了解一下。</p>

<pre><code>$('div').width();                          //获取元素的长度,返回的类型为number 
$('div').width(500);                       //设置元素长度,直接传数值,默认加 px  
$('div').width('500pt');                   //同上,设置了 pt 单位
$('div').width(function (index, value) {   //index 是索引,value 是原本值 
    return value - 500;                    //无须调整类型,直接计算
});
</code></pre>

<p><code>height()</code>方法同上。</p>

<h4>内外边距和边框尺寸方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alert($('div').width());           //获取元素宽度 不包含
</span><span class='line'>alert($('div').innerWidth());      //包含内边距 padding
</span><span class='line'>alert($('div').outerWidth());      //包含内边距 padding+边框 border
</span><span class='line'>alert($('div').outerWidth(true));  //包含内边距 padding+边框 border+外边距 margin</span></code></pre></td></tr></table></div></figure>


<h4>元素偏移方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('strong').offset().left;       //获取某个元素相对于视口的偏移位置
</span><span class='line'>$('strong').position().left;     //相对于父元素的偏移
</span><span class='line'>$(window).scrollTop();           //获取当前滚动条的位置
</span><span class='line'>$(window).scrollTop(300);        //设置当前滚动条的位置</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 过滤选择器]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/09/jquery-guo-lu-xuan-ze-qi/"/>
    <updated>2015-10-09T21:54:41+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/09/jquery-guo-lu-xuan-ze-qi</id>
    <content type="html"><![CDATA[<p>过滤选择器简称:过滤器。它其实也是一种选择器,而这种选择器类似与 CSS3里的伪类,可以让不支持 CSS3 的低版本浏览器也能支持。</p>

<h2>一、基本过滤器</h2>

<p>通过特定的过滤规则来筛选所需的 DOM 元素,和CSS中的伪类的语法类似:使用冒号(:)开头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('li:first').css('background', '#ccc');       //第一个元素
</span><span class='line'>$('li:last).css('background', '#ccc');         //最后一个元素
</span><span class='line'>$('li:not(.red)).css('background', '#ccc');    //非 class 为 red 的元素 
</span><span class='line'>
</span><span class='line'>$('li:even').css('background', '#ccc');        //索引为偶数的元素
</span><span class='line'>$('li:odd).css('background', '#ccc');          //索引为奇数的元素
</span><span class='line'>$('li:eq(2)).css('background', '#ccc');        //指定索引值的元素 
</span><span class='line'>
</span><span class='line'>$('li:gt(2)').css('background', '#ccc');       //大于索引值的元素
</span><span class='line'>$('li:lt(2)').css('background', '#ccc');       //小于索引值的元素
</span><span class='line'>
</span><span class='line'>$(':header').css('background', '#ccc');        //页面所有 h1 ~ h6 元素</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<p>注意:<code>:focus</code>过滤器,必须是网页初始状态的已经被激活焦点的元素才能实现元素获取。 而不是鼠标点击或者 Tab 键盘敲击激活的。</p>

<pre><code>$('input').get(0).focus();                 //先初始化激活一个元素焦点 
$(':focus').css('background', 'red');      //被焦点的元素
</code></pre>

<p>jQuery 为最常用的过滤器提供了专用的方法,已达到提到性能和效率的作用:</p>

<pre><code>$('li').eq(2).css('background', '#ccc');         //元素 li 的第三个元素,负数从后开始
$('li').first().css('background', '#ccc');       //元素 li 的第一个元素
$('li').last().css('background', '#ccc');        //元素 li 的最后一个元素
$('li').not('.red').css('background', '#ccc');   //元素 li 不含 class 为 red 的元素
</code></pre>

<h2>二、内容过滤器</h2>

<p>内容过滤器的过滤规则主要是包含的子元素或文本内容上。</p>

<pre><code>$('div:contains("ycku.com")').css('background', '#ccc');   //选择元素文本节点含有 ycku.com 文本的元素
$('div:empty').css('background', '#ccc');                  //选择空元素
$('ul:has(.red)').css('background', '#ccc');               //选择子元素含有 class 是 red 的元素 
$(':parent').css('background', '#ccc');                    //选择非空元素  选取含有子元素或文本的元素
</code></pre>

<p>jQuery 提供了一个 has()方法来提高:has 过滤器的性能:</p>

<pre><code>$('ul').has('.red').css('background', '#ccc');         //选择子元素含有 class 是 red 的元素
</code></pre>

<p>jQuery 提供了一个名称和<code>:parent</code>相似的方法,但这个方法并不是选取含有子元素或文本 的元素,而是获取当前元素的父元素,返回的是元素集合。</p>

<pre><code>$('li').parent().css('background', '#ccc');               //选择当前元素的父元素 
$('li').parents().css('background', '#ccc');              //选择当前元素的父元素及祖先元素 
$('li').parentsUntil('div').css('background', '#ccc');    //选择当前元素遇到 div 父元素停止
</code></pre>

<h2>三、可见性过滤器</h2>

<pre><code>$('p:hidden).size(); //选取所有不可见元素
$('p:visible').size(); //元素 p 显示的元素
</code></pre>

<p>注意:<code>:hidden</code>过滤器一般是包含的内容为:CSS 样式为<code>display:none、</code>input 表单类型为 <code>type="hidden"</code>和 <code>visibility:hidden</code>的元素。</p>

<h2>四、子元素过滤器</h2>

<p>子元素过滤器的过滤规则是通过父元素和子元素的关系来获取相应的元素。</p>

<pre><code>$('li:first-child').css('background', '#ccc');       //每个父元素第一个 li 元素 
$('li:last-child').css('background', '#ccc');        //每个父元素最后一个 li 元素 
$('li:only-child').css('background', '#ccc');        //每个父元素只有一个 li 元素 
$('li:nth-child(odd)').css('background', '#ccc');    //每个父元素奇数 li 元素
$('li:nth-child(even)').css('background', '#ccc');   //每个父元素偶数 li 元素
$('li:nth-child(2)').css('background', '#ccc');      //每个父元素第三个 li 元素
</code></pre>

<h2>五、其他方法</h2>

<p>jQuery 在选择器和过滤器上,还提供了一些常用的方法,方便我们开发时灵活使用。</p>

<pre><code>$('.red').is('li');                             //true,选择器,检测 class 为是否为 red
$('.red').is($('li'));                          //true,jQuery 对象集合,同上
$('.red').is($('li').eq(2));                    //true,jQuery 对象集合,同上
$('.red').is($('li').get(2));                   //true,DOM 对象,同上
$('.red').is(function () {                      //true,方法,同上
    return $(this).attr('title') == '列表 3';    //可以自定义各种判断
}));   
$('li').eq(2).hasClass('red');                   //和 is 一样,只不过只能传递 class

$('li').slice(0,2).css('background', '#ccc');    //前三个变成色
</code></pre>

<p>注意:这个参数有多种传法和 JavaScript 的 slice 方法是一样的比如:slice(2);slice(2,4),第三和第四被选定;slice(0,-2),从倒数第三个位置,向前选定 所有;slice(2,-2),前两个和末尾两个未选定。</p>

<pre><code>$("div").find("p").end().get(0);        //返回 div 的原生 DOM
$('div').contents().size();             //返回子节点(包括文本)数量

$('li').filter('.red').css('background','#ccc');         //选择 li 的 class 为 red 的元素
$('li').filter('.red, :first, :last').css('background','#ccc');    //增加了首尾选择
</code></pre>

<p>特殊要求函数返回</p>

<pre><code>$('li').filter(function () {
        return $(this).attr('class') == 'red' &amp;&amp; $(this).attr('title') == '列表 3'; 
        }).css('background', '#ccc');
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery 之 常规选择器]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/09/jquery-chang-gui-qi/"/>
    <updated>2015-10-09T20:49:48+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/09/jquery-chang-gui-qi</id>
    <content type="html"><![CDATA[<p>jQuery 最核心的组成部分就是：选择器引擎。它继承了 CSS 的语法,不必担心浏览器的兼容性。</p>

<h3>一、简单选择器</h3>

<pre><code>$('div').css('color', 'red');          //元素名选择器,返回多个元素 
$('#box').css('color', 'red');         //ID 选择器,返回单个元素
$('.box').css('color', 'red');         //类(class)选择器,返回多个元素
</code></pre>

<p>可以用 jQuery 核心自带的一个属性 length 或 size()方法来查看返回的元素个数。</p>

<h5>容错功能：</h5>

<pre><code>$('#pox').css('color', 'red');       //不存在 ID 为 pox 的元素,也不报错 
document.getElementById('pox').style.color = 'red';     //报错了
</code></pre>

<!--more-->


<p>原生方法可以这么判断解决这个问题:</p>

<pre><code>if (document.getElementById('pox')) { //先判断是否存在这个对象 
    document.getElementById('pox').style.color = 'red';
}
</code></pre>

<p>使用 jQuery 调用的话,怎么去判断是否存在呢?因 为本身返回的是 jQuery 对象,可能会导致不存在元素存在与否,都会返回 true。</p>

<pre><code>if ($('#pox').length &gt; 0) { //判断元素包含数量即可 
    $('#pox').css('color', 'red');
}
</code></pre>

<p>可以用转换为 DOM 对象的方式来判断,例如:</p>

<pre><code>if ($('#pox').get(0)) {} 或 if ($('#pox')[0]) {} //通过数组下标也可以获取 DOM 对象
</code></pre>

<h3>二、进阶选择器</h3>

<pre><code>$('span, em, .box').css('color', 'red');    //群组选择器 
$('ul li a').css('color', 'red');           //后代选择器
$('*').css('color', 'red');                 //通配选择器
</code></pre>

<h3>三、高级选择器</h3>

<h4>1、层次选择器</h4>

<pre><code>$('#box p').css('color', 'red');              //后代选择器
$('#box').find('p').css('color', 'red');      //和后代选择器等价

$('#box &gt; p').css('color', 'red');            //子选择器,孙子后失明
$('#box').children('p').css('color', 'red');  //和子选择器等价

$('#box+p').css('color', 'red');              //next 选择器(下一个同级节点)
$('#box').next('p').css('color', 'red');      //和 next 选择器等价

$('#box ~ p').css('color', 'red');            //nextAll 选择器(后面所有同级节点)
$('#box').nextAll('p').css('color', 'red');   //和 nextAll 选择器等价
</code></pre>

<p>在 <code>find()、next()、nextAll()和 children()</code>这四个方法中,如果不传递参数,就相当于传递 了“*”,我们不建议这么做,不但影响性能,而且由于精准度不佳可能产生怪异的结果。</p>

<p>补充：</p>

<pre><code>$('#box').prev('p').css('color', 'red'); //同级上一个元素 
$('#box').prevAll('p').css('color', 'red'); //同级所有上面的元素

$('#box').prevUntil('p').css('color', 'red'); //同级上非指定元素选定,遇到则停止 
$('#box').nextUntil('p').css('color', 'red'); //同级下非指定元素选定,遇到则停止
</code></pre>

<p>siblings()方法正好集成了 prevAll()和 nextAll()两个功能的效果,及上下相邻的所有元素 进行选定:</p>

<pre><code>$('#box').siblings('p').css('color', 'red'); //同级上下所有元素选定
</code></pre>

<p>选择器快慢分析:</p>

<p>最快的是 find()方法,最慢的是$(&lsquo;#box p&rsquo;)这种高级选择器。如果一开始将 $(&lsquo;#box&rsquo;)进行赋值,那么 jQuery 就对其变量进行缓存,那么速度会进一步提高。</p>

<pre><code>var box = $('#box'); 
var p = box.find('p');
</code></pre>

<h4>2、属性选择器</h4>

<pre><code>$('a[title]').css('color', 'red');           //选定这个属性的
$('a[title=num1]').css('color', 'red');      //选定具有这个属性=这个属性值的
$('a[title=^num]').css('color', 'red');      //选定具有这个属性且开头属性值匹配的
$('a[title|="num"]').css('color', 'red');    //选定具有这个属性且等于属性值或开头属性值匹配后面跟一个“-”号
$('a[title$=num]').css('color','red');       //选定具有这个属性且结尾属性值匹配的
$('a[title!=num1]').css('color','red');      //选定具有这个属性且属性值不想等的
$('a[title~=num1]').css('color','red');      //选定具有这个属性且属性值是以一个空格分割的列表,其中包含属性值的
$('a[title*=num]').css('color','red');       //选定具有这个属性且属性值含有一个指定字串的
$('a[bbb][title=num1]').css('color','red');  //选定具有多个属性且属性值匹配成功的
</code></pre>

<h2>四、表单选择器</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$('input').val();                     //元素名定位,默认获取第一个
</span><span class='line'>$('input').eq(1).val();               //同上,获取第二个
</span><span class='line'>$('input[type=password]').val();      //选择 type 为 password 的字段
</span><span class='line'>$('input[name=user]').val();          //选择 name 为 user 的字段</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css3 Box-flex]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/07/css3-box-flexshu-xing/"/>
    <updated>2015-10-07T16:11:02+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/07/css3-box-flexshu-xing</id>
    <content type="html"><![CDATA[<p>CSS3中新的盒子模型——弹性盒子模型(Flexible Box Model)。”flex”一词中文有“收缩”之意。</p>

<h3>一、box-flex属性（和谐版）</h3>

<p>不过，从此属性实际上产生的效果来看，无论怎样用“收缩”一词解释都显得很牵强。所以，这里，直接抛开字面意思，我们可以将<code>”box-flex”</code>理解为”房子-分配”。box为“盒子”的意思，我们可以理解为当下价格巨高的“房子”，<code>”flex”</code>指兄弟几个“分配房子”。比如：</p>

<!--more-->


<pre><code>#老大 { 房子-分配: 2; }
#老二 { 房子-分配: 1; }
#老三 { 房子-分配: 1; }
</code></pre>

<p>换成CSS表示就是：</p>

<pre><code>#first_boy { box-flex: 2; }
#second_boy { box-flex: 1; }
#three_boy { box-flex: 1; }
</code></pre>

<p><code>box-flex</code>的值为至少为1的整数时起作用。但是，仅仅一个<code>box-flex</code>属性是不足以实现子元素间的空间分配，因为还要看其老爸的意思。只有老爸开口说：“这个房子现在你们随意分配。”其子女才能分配。</p>

<p>所以，父元素也是需要添加必要的声明的。此声明就是：</p>

<pre><code>#father { display: box; }
</code></pre>

<p>似乎也可以是：</p>

<pre><code>#father { display: inline-box; }
</code></pre>

<p><code>display: box;</code>的声明其实就是弹性盒子模型的声明，此声明下的子元素的行为与表现与CSS2中的传统盒子模型的表现是有显著的差异的。</p>

<p>毕竟属于CSS3的东西，目前而言，仅Firefox/Chrome/Safari浏览器支持弹性盒子模型（IE9不详，Opera尚未），且使用的时候，需要附带私有前缀。就是诸如<code>-moz-, -webkit-</code>之类。</p>

<h5>CSS实例代码如下：</h5>

<pre><code>.test_box {
    display: -moz-box; 
    display: -webkit-box; 
    display: box; 

    ...
 }
.list {
   ...
}
.list_one {
    -moz-box-flex: 1; 
    -webkit-box-flex: 1; 
    box-flex: 1;
}
.list_two{
    -moz-box-flex: 2; 
    -webkit-box-flex: 2; 
    box-flex: 2;
}
</code></pre>

<h5>HTML代码如下：</h5>

<pre><code>&lt;div class="test_box"&gt;
    &lt;div class="list list_two"&gt;1&lt;/div&gt;
    &lt;div class="list list_one"&gt;2&lt;/div&gt;
    &lt;div class="list list_one"&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<h3>二、CSS box-flex属性（不和谐版）</h3>

<p>改编成CSS剧本就是：</p>

<pre><code>#first_boy { box-flex: 2; }
#second_boy { box-flex: 1; }
#three_boy { width: 50px; }
</code></pre>

<p>新增CSS样式如下：</p>

<pre><code>.list_w300 { width: 300px; }
</code></pre>

<p>老三分得300像素的宽度，剩下的像素宽度老大和老二2:1比例分配。</p>

<h3>三、爸爸其实很厉害，的说~</h3>

<p>爸爸肚子中的货有：<code>box-orient, box-direction, box-align, box-pack, box-lines.</code>现在依次讲讲这里box打头的属性都是干嘛用的。</p>

<h5>box-orient</h5>

<p>待续。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css3 之 Transform]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/05/css3-zhi-transform/"/>
    <updated>2015-10-05T12:18:56+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/05/css3-zhi-transform</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Margin]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/05/css-zhi-margin/"/>
    <updated>2015-10-05T10:53:49+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/05/css-zhi-margin</id>
    <content type="html"><![CDATA[<p>你真的了解margin吗？你知道margin有什么特性吗？你知道什么是垂直外边距合并？&hellip; 我真的有点晕！！</p>

<h4>一、Margin是什么</h4>

<p>边界，元素周围生成额外的空白区。“空白区”通常是指其他元素不能出现且父元素背景可见的区域。——CSS权威指南<!--more--></p>

<h4>二、垂直外边距合并问题</h4>

<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距合并。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>

<p>垂直外边距合并问题常见于第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距，而且只在标准浏览器下(FirfFox、Chrome、Opera、Sarfi)产生问题，IE下反而表现良好。</p>

<p>如果你读过了上面W3Shcool的CSS外边距合并的文章后，就很容易讨论这个问题了。这个问题发生的原因是根据规范，一个盒子如果没有上补白<code>(padding-top)</code>和上边框<code>(border-top)</code>，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>

<p>再说了白点就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己“领导”(父元素，祖先元素)的麻烦。只要给领导设置个有效的 border或者padding就可以有效的管制这个目无领导的margin防止它越级。</p>

<p>个人认为：margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p>

<h4>三、 margin在块元素、内联元素中的区别</h4>

<p>HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。</p>

<p>顾名思义，block元素就是以”块”表现的元素<code>（block-like elements）</code>，inline元素即是以”行”表现的元素<code>（character level elements and text strings）</code>。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。</p>

<p>block元素（块元素）大致有：P|H1|H2|H3|H4|H5|H6|UL|OL|PRE| DL | DIV | NOSCRIPT | BLOCKQUOTE | FORM | HR | TABLE | FIELDSET | ADDRESS</p>

<p>inline元素（内联元素）大致有：#PCDATA（即文本）| TT | I | B | BIG | SMALL|EM | STRONG | DFN | CODE |SAMP | KBD | VAR | CITE | ABBR | ACRONYM|A | IMG | OBJECT | BR | SCRIPT | MAP | Q | SUB | SUP | SPAN | BDO|INPUT | SELECT | TEXTAREA | LABEL | BUTTON</p>

<p>其中有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。</p>

<p>置换元素（replaced element）主要是指<code>img, input, textarea, select, object</code>等这类默认就有 CSS 格式化外表范围的元素。进而可知，非置换元素（non-replaced element）就是除了<code>img, input, textarea, select, object</code>等置换元素以外的元素。</p>

<p><code>margin-top/margin-bottom</code>对内联元素没有多大实际效果，不过<code>margin-left/margin-right</code>还是能够对内联元素产生影响的。</p>

<h4>四、  负margin技术及其应用</h4>

<pre><code>margin:-10px 20px -30px 40px;
</code></pre>

<p><img src="http://www.planabc.net/wp-content/uploads/2008/02/margin_example.gif" alt="margin" /></p>

<p>物理大小指的是除去 margin，也就是包含 border 以内的 box 大小，而逻辑大小，则是 box 通过 margin 解析规则解析后得到的大小</p>

<p>box 的实际大小 = box 的物理大小 + 正的 margin</p>

<h5>结论：</h5>

<p>box 最后的显示大小等于 box 的 border 及 border 内的大小加上正的 margin 值。而负的 margin 值不会影响 box 的实际大小，如果是负的 top 或 left 值会引起 box 的向上或向左位置移动，如果是 bottom 或 right 只会影响下面 box 的显示的参考线。</p>

<h4>四、 常见的浏览器下margin出现的bug</h4>

<h5>IE6中双边距Bug</h5>

<ul>
<li>发生场合：当给父元素内第一个浮动元素设置<code>margin-left（元素float:left）</code>或<code>margin-right（元素float:right）</code>时margin加倍。</li>
</ul>


<p>解决方法：是给浮动元素加上<code>display:inline;</code>；或者用<code>padding-left</code>代替<code>margin-left</code>。</p>

<p>待整理。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 图片垂直居中]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/04/css-zhi-tu-pian-chui-zhi-ju-zhong/"/>
    <updated>2015-10-04T23:05:07+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/04/css-zhi-tu-pian-chui-zhi-ju-zhong</id>
    <content type="html"><![CDATA[<h3>大小不固定，图片的垂直居中</h3>

<h4>① 透明gif图片+背景定位</h4>

<p>这里利用了<code>background-position:center</code>实现图片居中显示。这是个很实用也是很聪明的办法，对于维护控制成本都很不错。微软必应图片搜索的图片排列就是使用的这种方法。 方法的原理很简单，使用一个透明的gif图片做覆盖层，高宽拉伸至所需要的大小，然后给这个gif图片一个<code>background-position:center center</code>的属性。而background-image建议写在页面上，因为实际项目中，这肯定是个动态的URL地址，css文件似乎不支持动态URL地址。下面就是此方法的实例表现。</p>

<!--more-->


<pre><code>&lt;ul class="zxx_align_box_3 fix"&gt;
    &lt;li&gt;
    &lt;img src="../image/pixel.gif" style="background-image:url(/image/study/s/s128/mm1.jpg);" /&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>css部分：</p>

<pre><code>.zxx_align_box_3 li{width:1em; height:1em; font-size:128px; float:left;}
.zxx_align_box_3 li img{display:block; width:100%; height:100%; background-repeat:no-repeat; background-position:center;}
</code></pre>

<h4>② display:inline-block和文字大小控制居中</h4>

<p>代码相当简洁，是个成本很低，效果惊人的方法，适用于多图显示的情况。只需要一层必须要的a标签就解决问题了！</p>

<pre><code>&lt;div class="zxx_align_box_5 fix"&gt;
    &lt;a href="#zhangxinxu"&gt;
        &lt;img src="http://image/study/s/s128/mm1.jpg" /&gt;
    &lt;/a&gt;
    &lt;a href="#zhangxinxu"&gt;
        &lt;img src="http://image/study/s/s128/mm2.jpg" /&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p>css:</p>

<pre><code>.zxx_align_box_5 a{display:inline-block; width:1.2em; font-size:128px; text-align:center; vertical-align:middle;}
.zxx_align_box_5 a img{vertical-align:middle; padding:2px; border:1px solid #beceeb;}
</code></pre>

<h6>需要说明的：</h6>

<p>1.img外的标签需是a标签或span这类inline属性的标签，div标签也可以，但是css代码多些:<code>display:inline; display:inline-block</code>先变成inline属性，再转变成inline-block属性，原因讲起来又是一篇长长的文章，放着。</p>

<p>2.此方法只需要两层标签即可，可谓代码超简洁，但是只适用于多图垂直居中对齐的情况。因为其对齐原理是相邻的图片居中对齐，如果只是一个图片，vertical-align:middle就只有与空格对齐了。</p>

<h4>③ 使用空白图片实现垂直对齐</h4>

<pre><code>&lt;ul class="zxx_align_box_6 fix"&gt;
    &lt;li&gt;
    &lt;img class="show_img" src="http://amy-liu.github.io/image/study/s/s128/mm1.jpg" /&gt;
    &lt;img class="alpha_img" src="../image/pixel.gif" /&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>css:</p>

<pre><code>.zxx_align_box_6 li{height:128px; width:150px;float:left;text-align:center; font-size:0;}
.zxx_align_box_6 li .alpha_img{height:100%; width:1px; vertical-align:middle;}
.zxx_align_box_6 li .show_img{vertical-align:middle;}
</code></pre>

<h6>原理简述：</h6>

<p>一句话，将要显示的图片与一张透明的高度100%，宽度1像素的透明图片<code>vertical-align:middle</code>对齐。</p>

<p>其核心原理其实与第二种利用font-size大小实现IE下图片垂直居中是一致的。将font-size设置得很大，目的是撑开IE下默认文字空间的高度，其性质类似于空格，然后通过<code>vertical-align:middle</code>属性让图片与这个高高的空白空格空间垂直居中对齐；</p>

<p>而这里将这个看不见的文字空间实例成一张透明的gif图片，高度可以轻松设置为外部标签的高度，然后通过<code>vertical-align:middle</code>对齐，就实现效果了，在各个浏览器下都是一样的表现，不需要担心什么兼容性的问题。而且代码很简单，很易懂，想出错都难！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Line-height]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/03/css-zhi-line-height/"/>
    <updated>2015-10-03T16:28:19+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/03/css-zhi-line-height</id>
    <content type="html"><![CDATA[<h3>一、字面意思</h3>

<p>“Line-height”顾名思意指一行文字的高度。具体来说是指两行文字间基线之间的距离。基线实在英文字母中用到的一个概念，我们刚学英语的时使用的那个英语本子每行有四条线，其中底部第二条线就是基线。</p>

<p><img src="http://amy-liu.github.io/images/base_line.jpg" alt="base_line" /></p>

<h3>二、line-height与line boxes高度</h3>

<p>css中起高度作用的应该就是height以及line-height了吧！如果一个标签没有定义height属性(包括百分比高度)，那么其最终表现的高度一定是由line-height起作用，即使是IE6下11像素左右默认高度bug也是如此。</p>

<!--more-->


<p>一个空的div，如果没有设置至少大于1像素高度height值时，该div的高度就是个0。如果该div里面打入了一个空格或是文字，则此div就会有一个高度。
深入理解inline模型后，会发现，不是文字撑开了div的高度，而是line-height！测试：</p>

<pre><code>.test1{font-size:20px; line-height:0; border:1px solid #cccccc; background:#eeeeee;}
.test2{font-size:0; line-height:20px; border:1px solid #cccccc; background:#eeeeee;}
</code></pre>

<p>在inline box模型中，有个line boxes，它是看不见的，它的工作就是包裹每行文字。一行文字一个line boxes。如果它们在一行显示，只有一个line boxe，但要是竖着写，一行一个，一个字罩着一个line boxes。line boxes什么特性也没有，就高度。所以一个没有设置height属性的div的高度就是由一个一个line boxes的高度堆积而成的。</p>

<p>line boxes的高度是由inline boxes决定的，inline boxes就是文字，图片啊，span之类的inline属性的标签。这些标签谁的实际line-height值最高，谁最高，line boxes就取谁的值，形成高度。</p>

<p>1、单行文字的垂直居中对齐</p>

<p>把<code>line-height</code>设置为需要的box的大小可以实现单行文字的垂直居中”。</p>

<p>2、多行文字的垂直居中</p>

<pre><code>.mulit_line{line-height:150px; border:1px dashed #cccccc; padding-left:5px;}
.mulit_line span{display:inline-block; line-height:1.4em; vertical-align:middle;}
</code></pre>

<p>html代码：</p>

<pre><code>&lt;p class="mulit_line"&gt;
&lt;span style="font-size:12px;"&gt;这里是高度为150像素的标签内的多行文字，文字大小为12像素。&lt;br /&gt;这里是第二行，用来测试多行的显示效果。&lt;/span&gt;&lt;/p&gt;
</code></pre>

<p>兼容性还未测 待后续补充</p>

<h3>三、行高在文章显示中的应用</h3>

<p>文章里面的文字是有大有小的，使用px定值，由于继承性，无法实现根据文字大小自动调整间距，会出现大号文字重叠的现象。一般文章显示最好是650像素的宽度，1.5倍的行距较好。</p>

<p>有个很搓的办法可以实现文字间距自动适应于文字的大小，那就是使用“*”通配符，例如：<code>.article_box *{line-height:150%;}</code>使用“*”通配符大大增加了css的渲染，效率低。</p>

<p>更好的方法，就是使用数值。150%和1.5在值上是一样的，但是它们也是有差别的，差别在于继承性，使用百分比会计算<code>line-height</code>的值，然后以px像素为单位继承下去，而1.5则是先继承1.5这个值，遍历到了该标签再计算<code>line-height</code>的像素值。所以同样的效果只需要.<code>article_box{line-height:1.5;}</code>就可以实现了。</p>

<h3>四、使用行高代替高度避免haslayout</h3>

<p>某些情形下，line-height可以和height互换，因为实现的效果一样。都能撑开一个高度，然而这两个css属性有一个较隐蔽的差异，就是使用height会使标签haslayout，而使用line-height则不会。以前只有IE6的时候曾流行使用height清除浮动，就是利用了IE下height使haslayout的属性。但有时候，haslayout并不需要，反而要避免。</p>

<p>有关自适应按钮使用了line-height代替了height，其原因在于：IE6，IE7下，类似inline-block属性的元素里如果有block属性的元素，如果该block haslayout，则该标签会冲破外部inline-block的显示而宽度100%显示，从使按钮自适应文字大小的效果失效，解决方法就是使用line-height代替height。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Inline-block]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/03/css-zhi-inline-block/"/>
    <updated>2015-10-03T15:10:13+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/03/css-zhi-inline-block</id>
    <content type="html"><![CDATA[<h3>替代float 的 inline-block列表布局</h3>

<p>浮动本身就是个魔鬼，所以，使用浮动布局还需要修复其带来的副作用——高度塌陷的问题，也就是常提到的“清除浮动”。</p>

<p>关于line box模型，就是每一行所有的inline元素和inline-block元素会共同形成一个line boxes，这个line box的高度由里面最高的元素决定。<code>inline-block</code>属性属于line box模型，其布局的列表元素高度异常时，撑开的是整个line boxes的高度，因而，不会与下一行的列表元素发生错位。</p>

<!--more-->


<h3>一、inline-block的兼容性</h3>

<p>对于IE8+以及现代浏览器，直接使用：</p>

<pre><code>{display:inline-block;}
</code></pre>

<p>对于不支持的IE6/7浏览器 如果是inline元素（如a标签，span标签之类）跟上面一样，直接：</p>

<pre><code>{display:inline-block;}
</code></pre>

<p>如果是block元素，如下所示：</p>

<pre><code>{display:inline-block; *display:inline；*zoom:1;}
</code></pre>

<h3>二、一点小阻挠：inline-block元素间的换行符空格间隙问题</h3>

<p>使用display:inline-block布局经常会遇到的“换行符/空格间隙问题”。</p>

<p>如果inline-block元素间有空格或是换行产生了间隙，那是正常的，真正的inline-block元素，就像个图片一样。例如，两个不在一行的img标签，形成的两个图片之间就会有间隙。要让这些空格不出现，最简单的最容易理解的就是让列表的结束标签与下一个列表的开始标签连在一起，这样代码的可读性很不好，不建议使用。</p>

<p>空格符本质上就是个字符，与a,b,c,d这些字符是个同一个属性的东西，只是他是空格，透明的看不见而已（但可以选中）。所以，只要我们使用让文字宽度为0的那些方法，是不是就可以解决inline-block元素间换行符间隙的问题呢！</p>

<pre><code>{font-size:0;}
</code></pre>

<p>结果IE7E和Safari 会有1像素空隙，Chrome下的空格对于<code>font-size:0</code>貌似很不屑一顾,置若罔闻，连同样内核的Safari都不会这样。</p>

<p>想到有个letter-spacing属性。可以控制文字间的水平距离的，支持负值，可以让文字水平方向上重叠（line-height是让文字垂直方向上重叠）。</p>

<pre><code>letter-spaceing:-4px;
</code></pre>

<p>既然IE6/7浏览器div,li 这些标签inline-block化后没有空格间隙，那么使用letter-spacing负值会不会让列表元素水平重叠呢？这个问题就不要担心了，如果元素间本身没有空格，使用letter-spacing属性是不会发生水平重叠的问题的。测试通过。
唯一有瑕疵的是在Opera浏览器下，两个inline-block元素间空白间隙使用letter-spacing去除的极限是1像素，当看上去要正好为0的时候，letter-spacing似乎失效，空白间距恢复成letter-spacing:0时的效果。</p>

<p>ok，整理一下：</p>

<p>» block水平的元素inline-block化后，IE6/7没有换行符间隙问题，其他浏览器均有；</p>

<p>» inline水平的元素inline-block后，所有主流浏览器都有换行符/空格间隙问题；</p>

<p>» font-size:0，去除换行符间隙，在IE6/7下残留1像素间隙，Chrome浏览器无效，其他浏览器都完美去除；</p>

<p>» letter-spacing负值可以去除所有浏览器的换行符间隙，但是，Opera浏览器下极限是间隙1像素，0像素会反弹，换行符间隙还原。</p>

<p>虽然font-size:0有缺陷，letter-spacing负值也有不足，但是一旦将它们同时出现，互补与整合，换行符间隙问题迎刃而解。</p>

<pre><code>letter-spacing:-3px; font-size:0
</code></pre>

<h6>所以，应用display:inline-block属性实现列表布局的几个关键字就是：block水平的标签，font-size:0和letter-spacing负值。</h6>

<h3>三、更进一步：更加灵活的inline-block列表布局</h3>

<p>使用white-space:nowrap;属性可以让列表不换行，你是否想到了列表元素的水平滚动切换</p>

<p>text-align:justify可以实现自动等宽水平排列的列表布局，而且是两端对齐的，不需要计算宽度，一切都是浏览器自动的，很方便很强大。尤其在自适应布局中。</p>

<pre><code>.box{width:50%; padding:20px; margin:20px auto; background-color:#f0f3f9; text-align:justify;}
.list{width:120px; display:inline-block; padding-bottom:20px; text-align:center; vertical-align:top;}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Float]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/03/css-zhi-float/"/>
    <updated>2015-10-03T11:07:53+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/03/css-zhi-float</id>
    <content type="html"><![CDATA[<h3>重识float浮动</h3>

<h6>- 目前大多数浮动应用都不是浮动应该做的</h6>

<h6>- 浮动的本质是“包裹及破坏”</h6>

<h6>- 浮动的意义仅仅是文字环绕显示而已</h6>

<h3>一、浮动的原始意义是什么？</h3>

<p>浮动真正的意义在哪里呢？假设现在CSS中没有浮动(float)属性，那么唯一一个实现不了的就是“文字环绕图片”，我是想不出来能有什么方法可以让文字环绕图片显示。好，这个替代不了的作用才是float真正的意义所在。所以请记住，浮动出现的意义其实只是用来让文字环绕图片而已，仅此而已。而我们目前用浮动实现页面布局本不是浮动该干的事情。</p>

<h3>二、浮动的本质是什么？</h3>

<p>我们可以将浮动的本质定义为“包裹与破坏”</p>

<p>浮动的“包裹性”：撇开浮动的“破坏性”，浮动就是个带有方位的<code>display:inline-block</code>属性。<code>display:inline-block</code>某种意义上的作用就是包裹<code>(wrap)</code></p>

<p>浮动的“破坏性”：文字之所以会环绕含有float属性的图片时因为浮动破坏了正常的line boxes。</p>

<p>inline boxes不会让内容成块显示，而是排成一行，如果外部含inline属性的标签(span,a,cite等)，则属于inline boxes，如果是个光秃秃的文字，则属于匿名inline boxes。</p>

<p>浮动破坏了inline boxes也就没有高度可言了 产生了两个结果：脱离了其原来所在的line box链无法与文字同行显示；二是没有了高度（无inline box -> 无line box -> 无高度）。真是由于浮动元素没有了inline boxes，没有了inline boxes高度，才能让其他inline boxes元素重新整合，环绕浮动元素排列。
而这些结果恰恰是文字环绕图片显示所必须的。</p>

<!--more-->


<h3>三、列表浮动布局的局限</h3>

<p>对于浮动局部的局限性，就是每个列表元素的高度必须要一致，否则就会像是俄罗斯方块一样，“锯齿相错”，例如一个左浮动列表布局，如果第一行有个列表高度高于其他列表，那就在第二行，第一个元素会沿着最高元素的右侧对齐，此原因是属于恶魔系的float属性破坏了inline box 。</p>

<h3>四、那么浮动布局更好的替代方案是什么</h3>

<p><code>inline-block</code>属性的元素适用于inline box模型，当其中的列表元素高度不一时，也不会有错位。下一章我们详细介绍下这个属性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 之 Absolute]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/02/css-zhi-absolute/"/>
    <updated>2015-10-02T15:34:13+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/02/css-zhi-absolute</id>
    <content type="html"><![CDATA[<h4>一、被遗忘的天使：absolute</h4>

<p>每个CSS属性都有一段故事，需要我们静下心来发现，体会。</p>

<p>  1、无定位值的absolute元素就是个连实际宽度也没有的float浮动元素。</p>

<p>  2、无定位值的absolute元素其会像个普通的inline－block属性元素一样静静地呆在这个div里面。</p>

<!--more-->


<h4>二、absolute 神技能</h4>

<p>1、absolute 解决iframe高度自适应问题。</p>

<pre><code> iframe{position:absolute;top:0px;height:100%;}
</code></pre>

<p>2、两列等高布局上也可以发挥强大的作用，当然这类框架布局也可以用最省心的table 来搞定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Css 疑难杂症 ［兼容篇］]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/02/css/"/>
    <updated>2015-10-02T12:52:42+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/02/css</id>
    <content type="html"><![CDATA[<h4>一、移除超链接的虚线</h4>

<p> FireFox下,当你点击一个超链接时会在外围出现一个虚线轮廓. 这很容易解决, 只需要在标签样式中加入：
<code>a{outline: none;}</code></p>

<h4>二、文字重复问题</h4>

<p>在IE中文字重复问题可能由于注释带来的,可以把注释改为：
<code>&lt;!–[if !IE]&gt;Put your commentary in here…&lt;![endif]–&gt;</code></p>

<!--more-->


<h4>三、完美的单象素外框线表格（在IE5、IE6、IE7及FF1.0.4以上中均可通过测试）</h4>

<pre><code>table{ border-collapse:collapse; }
td{ border:#000 solid 1px;}
</code></pre>

<h4>四、如果文字过长,则将过长的部分变成省略号显示：</h4>

<pre><code>&lt;div style="width:120px;height:50px;overflow:hidden;text-overflow:ellipsis"&gt;&lt;/div&gt;
</code></pre>

<p>另外介绍下：<code>white-space:nowrap;</code>是指禁止文字自动换行。</p>

<h4>五、min-height和min-width</h4>

<pre><code>&lt;div style="border:1px;min-height:100px;width:200px;padding:12px;"&gt;test&lt;/div&gt;
</code></pre>

<p><code>min-height</code> 不支持ie6.0,采用hack  <code>_height:100px</code>经测试完美支持.</p>

<p>我们想要min-width也达这样的效果。结果让我们很是意外，所有浏览器里统统失效。原因是容器的高度默认情况下是由内容多少决定的，但宽度不是啊！默认情况下是继承了父容器的宽度。当然，前提是display是block。so 我们想到了<code>display:inline-block;</code> , 为了兼容ie6 ie7 不得不填加如下代码：</p>

<pre><code>display:inline-block;*display:inline;zoom:1;min-width:220px;_width:220px；white-space:nowrap；
</code></pre>

<p>那么position:absolute 和 float 这两个看起来也行。</p>

<pre><code>position:absolute;min-width:220px;_width:220px;white-space:nowrap；
float:left;min-width:220px;_width:220px;white-space:nowrap
</code></pre>

<h4>六、兼容hack 写法。</h4>

<p>IE都能识别*，标准浏览器(如FF)不能识别</p>

<p>IE6能识别*，但不能识别 !important</p>

<p>IE7能识别*，也能识别!important</p>

<p>FF不能识别*，但能识别!important</p>

<p>另外再补充一个，下划线" _ ” ，IE6支持下划线，IE7和firefox均不支持下划线。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Octopress 搭建个人博客]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/01/test/"/>
    <updated>2015-10-01T15:28:28+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/01/test</id>
    <content type="html"><![CDATA[<h3>Octopress的安装配置</h3>

<h3>1.克隆Octopress安装文件至本地</h3>

<pre><code>1. git clone git@github.com:imathis/octopress.git
2. cd octopress
</code></pre>


<h3>2.安装依赖项</h3>

<p> 加入了淘宝的软件源。删除官方的自带软件源</p>

<pre><code>1.  gem sources --remove https://rubygems.org/
2.  gem sources -a http://ruby.taobao.org/
</code></pre>


<p> 输入查看软件源命令，查看当前软件源是否正确</p>

<pre><code>gem sources -l</code></pre>


<p> 修改完Gemfile文件后，我们就可以开始“bundler”的安装了</p>

<pre><code>bundle install</code></pre>


<!--more-->


<h3>3.安装Octopress并设定默认主题</h3>

<p> <pre><code>rake install</code></pre></p>

<p>  生成和本地预览命令</p>

<p>  <pre><code>rake generate
rake preview</code></pre></p>

<h3>4.Octopress网页加载速度慢的解决方法</h3>

<p> <pre><code>//libs.baidu.com/jquery/1.9.1/jquery.min.js</code></pre></p>

<h3>5. 部署到 GitHub 上</h3>

<p> <pre><code>rake setup_github_pages</code></pre></p>

<pre><code> rake new_post
</code></pre>

<p>你发布的文章被放在 <code>source/_posts</code>目录下,</p>

<p> 最后执行
 <pre><code>rake generate
rake deploy</code></pre></p>
]]></content>
  </entry>
  
</feed>
