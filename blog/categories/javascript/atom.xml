<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | 云端笔记]]></title>
  <link href="http://amy-liu.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://amy-liu.github.io/"/>
  <updated>2015-10-29T01:57:54+08:00</updated>
  <id>http://amy-liu.github.io/</id>
  <author>
    <name><![CDATA[amy-liu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 面向对象与原型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/28/jaxiang-dui-xiang-yu-yuan-xing/"/>
    <updated>2015-10-28T23:46:09+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/28/jaxiang-dui-xiang-yu-yuan-xing</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 基本包装类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/28/javascript-zhi-ji-ben-bao-zhuang-lei-xing/"/>
    <updated>2015-10-28T23:43:32+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/28/javascript-zhi-ji-ben-bao-zhuang-lei-xing</id>
    <content type="html"><![CDATA[<p>为了便于操作基本类型值 ,ECMAScript 提供了 3 个特殊的引用类型 : <code>Boolean</code> 、<code>Number</code> 和 <code>String</code>。这些类型与其他引用类型相似 ,但同时也具有与各自的基本类型相应的特殊行为 。 实际上,每当读取一个基本类型值的时候,后台就会创建一个对应的基本包装类型的对象 , 从而能够调用一些方法来操作这些数据。</p>

<h3>一、基本包装类型概述</h3>

<pre><code>var box = 'Mr. Lee';                     //定义一个字符串
var box2 = box.substring(2);             //截掉字符串前两位
alert(box2);
</code></pre>

<p>变量 box 是一个字符串类型,而 <code>box.substring(2)</code>又说明它是一个对象(<code>PS:只有对象才 会调用方法</code>),最后把处理结果赋值给 box2。<code>'Mr. Lee'</code>是一个字符串类型的值,按道理它不 应该是对象,不应该会有自己的方法,比如:</p>

<pre><code>alert('Mr. Lee'.substring(2));            //直接通过值来调用方法
</code></pre>

<p>1.字面量写法:</p>

<pre><code>var box = 'Mr. Lee';             //字面量 
box.name = 'Lee';                //无效属性
box.age = function () {          //无效方法
    return 100; 
};
alert(box);                      //Mr. Lee 
alert(box.substring(2));         //. Lee 
alert(typeof box);               //string
alert(box.name);                 //undefined
alert(box.age());                //错误
</code></pre>

<!--more-->


<p>2.new 运算符写法:</p>

<pre><code>var box = new String('Mr. Lee');      //new 运算符
box.name = 'Lee';                     //有效属性
box.age = function () {               //有效方法
    return 100;
};
alert(box);                          //Mr. Lee
alert(box.substring(2));             //. Lee
alert(typeof box);                   //object
alert(box.name);                     //Lee
alert(box.age());                    //100
</code></pre>

<p>以上字面量声明和 new 运算符声明很好的展示了他们之间的区别。但有一定还是可以 肯定的,那就是不管字面量形式还是 new 运算符形式,都可以使用它的内置方法。并 且 <code>Boolean</code> 和 <code>Number</code> 特性与 <code>String</code> 相同,三种类型可以成为基本包装类型。</p>

<p>PS:在使用 new 运算符创建以上三种类型的对象时,可以给自己添加属性和方法,但 我们建议不要这样使用,因为这样会导致根本分不清到底是基本类型值还是引用类型值。</p>

<h2>二、Boolean 类型</h2>

<p>Boolean 类型没有特定的属性或者方法。</p>

<h2>三、Number 类型</h2>

<p>Number 类型有一些静态属性(直接通过 <code>Number</code> 调用的属性,而无须 <code>new</code> 运算符)和方法。</p>

<p>Number 静态属性</p>

<pre><code>属性                   描述    
MAX_V ALUE            表示最大数    
MIN_V ALUE            表示最小值    
NaN                   非数值
NEGA TIVE_INFINITY    负无穷大,溢出返回该值
POSITIVE_INFINITY     无穷大,溢出返回该值
prototype             原型,用于增加新属性和方法
</code></pre>

<p>Number 对象的方法</p>

<pre><code>方法                    描述
toString()             将数值转化为字符串,并且可以转换进制
toLocaleString()       根据本地数字格式转换为字符串
toFixed()              将数字保留小数点后指定位数并转化为字符串
toExponential()        将数字以指数形式表示 ,保留小数点后指定位数并转化为 字符串
toPrecision()          指数形式或点形式表述数 ,保留小数点后面指定位数并转 化为字符串
</code></pre>

<pre><code>
    var box = 1000.789;            
    alert(box.toString());             //转换为字符串,传参可以转换进制 
    alert(box.toLocaleString());       //本地形式, 1,000.789
    alert(box.toFixed(2));             //小数点保留, 1000.78 
    alert(box.toExponential());        //指数形式,传参会保留小数点
    alert(box.toPrecision(3));         //指数或点形式,传参保留小数点
</code></pre>

<h2>四、String 类型</h2>

<p><code>String</code> 类型包含了三个属性和大量的可用内置方法。</p>

<ul>
<li><p>String 对象属性</p>

<p>  属性                     描述
  length                  返回字符串的字符长度
  constructor             返回创建 String 对象的函数
  prototype               通过添加属性和方法扩展字符串定义</p></li>
</ul>


<p>String 也包含对象的通用方法,比如 <code>valueOf()</code>、<code>toLocaleString()</code>和 <code>toString()</code> 方法,但这 些方法都返回字符串的基本值。</p>

<ul>
<li><p>字符方法</p>

<p>  charAt(n)          返回指定索引位置的字符
  charCodeAt(n)      以 Unicode 编码形式返回指定索引位置的字符</p></li>
</ul>


<pre><code>    var box = 'Mr.Lee'; 
    alert(box.charAt(1));               //r
    alert(box.charCodeAt(1));           //114
    alert(box[1]);                      //r,通过数组方式截取
</code></pre>

<p>PS: <code>box[1]</code> 在 IE 浏览器会显示 <code>undefined</code>,所以使用时要慎重。</p>

<ul>
<li><p>字符串操作方法</p>

<p>  concat(str1&hellip;str2)          将字符串参数串联到调用该方法的字符串
  slice(n,m)                   返回字符串 n 到 m 之间位置的字符串
  substring(n,m)               同上
  substr(n,m)                  返回字符串 n 开始的 m 个字符串</p></li>
</ul>


<pre><code>    var box = 'Mr.Lee';
    alert(box.concat(' is ', ' Teacher ', '!'));           //Mr.Lee is Teacher 
    alert(box.slice(3));                                   //Lee
    alert(box.slice(3,5));                                 //Le

    alert(box.substring(3));                               //Lee
    alert(box.substring(3,5));                             //Le
    alert(box.substr(3));                                  //Lee
    alert(box.substr(3,5));                                //Lee

    var box = 'Mr.Lee'; 
    alert(box.slice(-3));                //Lee,6+(-3)=3 位开始                          
    alert(box.substring(-3));            //Mr.Lee 负数返回全部
    alert(box.substr(-3));               //Lee,6+(-3)=3 位开始

    var box = 'Mr.Lee'; 
    alert(box.slice(3, -1));             //Le 6+(-1)=5, (3,5)
    alert(box.substring(3, -1));         //Mr. 第二参为负,直接转 0, 并且方法会把较小的数字提前, (0,3)
    alert(box.substr(3, -1));            //'' 第二参数为负,直接转 0 ,(3,0)
</code></pre>

<p>PS:IE 的 JavaScript 实现在处理向 substr()方法传递负值的情况下存在问题,它会返回 原始字符串,使用时要切记。</p>

<ul>
<li><p>字符串位置方法</p>

<p>  indexOf(str, n)        从 n 开始搜索的第一个 str,并将搜索的索引值返回
  lastIndexOf(str, n)    从 n 开始搜索的最后一个 str,并将搜索的索引值返回</p></li>
</ul>


<pre><code class="">var box = 'Mr.Lee is Lee'; 
alert(box.indexOf('L'));                  //3
alert(box.indexOf('L', 5));               //10           
alert(box.lastIndexOf('L'));              //10
alert(box.lastIndexOf('L', 5));           //3,从指定的位置向前搜索
</code></pre>

<p>PS:如果没有找到想要的字符串,则返回 -1。</p>

<p>示例:找出全部的 L</p>

<pre><code>var box = 'Mr.Lee is Lee';            //包含两个 L 的字符串
var boxarr = [];                      //存放 L 位置的数组 
var pos = box.indexOf('L');           //先获取第一个 L 的位置
while (pos &gt; -1) {                    //如果位置大于-1,说明还存在 L 
    boxarr.push(pos);                 //添加到数组
    pos = box.indexOf('L', pos + 1);  //从新赋值 pos 目前的位置
}
alert(boxarr);
</code></pre>

<ul>
<li><p>大小写转换方法</p>

<p>  var box = &lsquo;Mr.Lee is Lee&rsquo;;
  alert(box.toLowerCase());          //全部小写
  alert(box.toUpperCase());          //全部大写
  alert(box.toLocaleLowerCase());    //将字符串全部转换为小写,并且本地化
  alert(box.toLocaleUpperCase());    //将字符串全部转换为大写,并且本地化</p></li>
<li><p>字符串的模式匹配方法</p>

<p>  match(pattern)                    返回 pattern 中的子串或 null
  replace(pattern, replacement)     用 replacement 替换 pattern
  search(pattern)                   返回字符串中 pattern 开始位置
  split(pattern)                    返回字符串按指定 pattern 拆分的数组</p></li>
</ul>


<pre><code>    var box = 'Mr.Lee is Lee'; 
    alert(box.match('L'));             //找到 L,返回 L 否则返回 null 
    alert(box.search('L'));            //找到 L 的位置,和 indexOf 类型
    alert(box.replace('L', 'Q'));      //把 L 替换成 Q 
    alert(box.split(' '));             //以空格分割成字符串     
</code></pre>

<ul>
<li>其他方法</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 变量、作用域及内存]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/25/javascript-zhi-bian-liang-,-zuo-yong-yu-ji-nei-cun/"/>
    <updated>2015-10-25T00:40:04+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/25/javascript-zhi-bian-liang-,-zuo-yong-yu-ji-nei-cun</id>
    <content type="html"><![CDATA[<p>JavaScript 的变量与其他语言的变量有很大区别。 JavaScript 变量是松散型的 (不强制类 型)本质,决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个 变量必须要保存何种数据类型值的规则 ,变量的值及其数据类型可以在脚本的生命周期内改 变。</p>

<h3>一、变量及作用域</h3>

<p>1.基本类型和引用类型的值</p>

<p>ECMAScript 变量可能包含两种不同的数据类型的值:<code>基本类型值和引用类型值</code>。基本
类型值指的是那些保存在栈内存中的简单数据段,即这种值完全保存在内存中的一个位置 。 而引用类型值则是指那些保存在堆内存中的对象,意思是变量中保存的实际上只是一个指 针,这个指针指向内存中的另一个位置,该位置保存对象。</p>

<p>将一个值赋给变量时 ,解析器必须确定这个值是基本类型值 ,还是引用类型值 。基本类 型值有以下几种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>。这些类型在内存中分别占 有固定大小的空间,他们的值保存在栈空间,我们通过按值来访问的。</p>

<p>PS:在某些语言中,字符串以对象的形式来表示 ,因此被认为是引用类型 。ECMAScript 放弃这一传统。</p>

<p>如果赋值的是引用类型的值 ,则必须在堆内存中为这个值分配空间 。由于这种值的大小 不固定,因此不能把它们保存到栈内存中 。但内存地址大小的固定的 ,因此可以将内存地址 保存在栈内存中 。这样,当查询引用类型的变量时 ,先从栈中读取内存地址 ,然后再通过地 址找到堆中的值。对于这种,我们把它叫做<code>按引用访问</code>。</p>

<p>2.动态属性</p>

<p>定义基本类型值和引用类型值的方式是相似的:创建一个变量并为该变量赋值。但是 , 当这个值保存到变量中以后,对不同类型值可以执行的操作则大相径庭。</p>

<pre><code>var box = new Object();     //创建引用类型
box.name = 'Lee';           //新增一个属性 
alert(box.name);
</code></pre>

<p>如果是基本类型的值添加属性的话,就会出现问题了。</p>

<pre><code>var box = 'Lee';            //创建一个基本类型
box.age = 27;               //给基本类型添加属性
alert(box.age);             //undefined
</code></pre>

<!--more-->


<p>3.复制变量值</p>

<p>在变量复制方面 ,基本类型和引用类型也有所不同 。基本类型复制的是值本身 ,而引用 类型复制的是地址。</p>

<pre><code>var box = 'Lee';         //在栈内存生成一个 box 'Lee' 
var box2 = box;          //在栈内存再生成一个 box2 'Lee'
</code></pre>

<p>box2 是虽然是 box1 的一个副本,但从图示可以看出,它是完全独立的。也就是说 ,两 个变量分别操作时互不影响。</p>

<pre><code>var box = new Object();     //创建一个引用类型
box.name = 'Lee';           //新增一个属性
var box2 = box;             //把引用地址赋值给 box2
</code></pre>

<p>在引用类型中,box2 其实就是 box,因为他们指向的是同一个对象 。如果这个对象中的 name 属性被修改了,<code>box2.name</code> 和 <code>box.name</code>输出的值都会被相应修改掉了。</p>

<p>4.传递参数</p>

<p>ECMAScript 中所有函数的参数都是按值传递的,言下之意就是说,参数不会按引用传 递,虽然变量有基本类型和引用类型之分。</p>

<p>5.检测类型</p>

<p>要检测一个变量的类型,我们可以通过 typeof 运算符来判别。诸如:</p>

<pre><code>var box = 'Lee';
alert(typeof box);    //string
</code></pre>

<p>虽然 typeof 运算符在检查基本数据类型的时候非常好用 ,但检测引用类型的时候 ,它就 不是那么好用了 。通常,我们并不想知道它是不是对象 ,而是想知道它到底是什么类型的对 象。因为数组也是 object,null 也是 Object 等等。
这时我们应该采用 <code>instanceof</code> 运算符来查看。</p>

<p>PS:当使用 instanceof 检查基本类型的值时,它会返回 false。</p>

<p>待。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 之 Function类型]]></title>
    <link href="http://amy-liu.github.io/blog/2015/10/22/javascript-zhi-functionlei-xing/"/>
    <updated>2015-10-22T00:29:29+08:00</updated>
    <id>http://amy-liu.github.io/blog/2015/10/22/javascript-zhi-functionlei-xing</id>
    <content type="html"><![CDATA[<p>在 ECMAScript 中,Function(函数)类型实际上是对象。每个函数都是Function类型的实例,而且都与其他引用类型一样具有属性和方法 。由于函数是对象,因此函数名实际上也 是一个指向函数对象的指针。</p>

<h3>一、函数的声明方式</h3>

<ul>
<li>普通的函数声明
<code>
  function box(num1, num2) {
      return num1+ num2;
  }
</code></li>
<li>使用变量初始化函数
<code>
  var box= function(num1, num2) {
      return num1 + num2;
  };
</code></li>
<li>使用 Function 构造函数
<code>
  var box= new Function('num1', 'num2' ,'return num1 + num2');
</code>
PS: 第三种方式我们不推荐,因为这种语法会导致解析两次代码(第一次解析常 规 ECMAScript 代码,第二次是解析传入构造函数中的字符串 ),从而影响性能。但我们可以通 过这种语法来理解 &ldquo;函数是对象,函数名是指针 "的概念。</li>
</ul>


<!--more-->


<h2>二、作为值的函数</h2>

<p>ECMAScript 中的函数名本身就是变量,所以函数也可以作为值来使用。也就是说,不 仅可以像传递参数一样把一个函数传递给另一个函数 ,而且可以将一个函数作为另一个函数 的结果返回。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box(sumFunction, num) {
</span><span class='line'>    return sumFunction(num);              //Function
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function sum(num) { 
</span><span class='line'>return num + 10;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var result = box(sum, 10);            //传递函数到另一个函数里
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;三、函数内部属性&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在函数内部,有两个特殊的对象: &lt;code&gt;arguments&lt;/code&gt; 和 &lt;code&gt;this&lt;/code&gt;. &lt;code&gt;arguments&lt;/code&gt; 是一个类数组对象,包
</span><span class='line'>含着传入函数中的所有参数 ,主要用途是保存函数参数 。但这个对象还有一个名叫 &lt;code&gt;callee&lt;/code&gt; 的 属性,该属性是一个指针,指向拥有这个 &lt;code&gt;arguments&lt;/code&gt; 对象的函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(num) { 
</span><span class='line'>if (num &lt;= 1) {
</span><span class='line'>    return 1; 
</span><span class='line'>    } else {
</span><span class='line'>        return num * box(num-1);          //一个简单的的递归
</span><span class='line'>    } 
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于阶乘函数一般要用到递归算法 ,所以函数内部一定会调用自身 ;如果函数名不改变 是没有问题的,但一旦改变函数名,内部的自身调用需要逐一修改。为了解决这个问题 ,我 们可以使用 arguments.callee 来代替。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(num) { 
</span><span class='line'>if (num &lt;= 1) {
</span><span class='line'>    return 1; 
</span><span class='line'>    } else {
</span><span class='line'>        return num * arguments.callee(num-1);         //使用 callee 来执行自身 
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;函数内部另一个特殊对象是 &lt;code&gt;this&lt;/code&gt;, 其行为与 Java 和 C#中的 this 大致相似。换句话说, this 引用的是函数据以执行操作的对象 ,或者说函数调用语句所处的那个作用域 。PS:当在 全局作用域中调用函数时, &lt;code&gt;this&lt;/code&gt; 对象引用的就是 &lt;code&gt;window。&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//便于理解的改写例子&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;window.color = '红色的';            //全局的,或者 var color = '红色的';也行 
</span><span class='line'>alert(this.color);             //打印全局的 color
</span><span class='line'>var box = {
</span><span class='line'>color : '蓝色的',               //局部的 color
</span><span class='line'>sayColor : function () { 
</span><span class='line'>alert(this.color);             //此时的 this 只能 box 里的 color
</span><span class='line'>} 
</span><span class='line'>};
</span><span class='line'>box.sayColor();                    //打印局部的 color
</span><span class='line'>alert(this.color);                  //还是全局的
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;四、函数属性和方法&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ECMAScript 中的函数是对象,因此函数也有属性和方法。每个函数都包含两个属性 : &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;prototype&lt;/code&gt;。其中,&lt;code&gt;length&lt;/code&gt;属性表示函数希望接收的命名参数的个数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(name, age) { 
</span><span class='line'>alert(name + age);
</span><span class='line'>}
</span><span class='line'>alert(box.length);     //2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;PS:对于 &lt;code&gt;prototype&lt;/code&gt; 属性,它是保存所有实例方法的真正所在 ,也就是原型。这个属性, 我们将在面向对象一章详细介绍 。而 &lt;code&gt;prototype&lt;/code&gt; 下有两个方法:&lt;code&gt;apply()&lt;/code&gt;和 &lt;code&gt;call()&lt;/code&gt;,每个函数都 包含这两个非继承而来的方法 。这两个方法的用途都在特定的作用域中调用函数 ,实际上等 于设置函数体内 &lt;code&gt;this&lt;/code&gt; 对象的值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function box(num1, num2) {           //原函数
</span><span class='line'>return num1 + num2;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function sayBox(num1, num2) {
</span><span class='line'>return box.apply(this, [num1, num2]);          //this 表示作用域,这里是 window ,[]表示 box 所需要的参数
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function sayBox2(num1, num2) { 
</span><span class='line'>return box.apply(this, arguments);             //arguments 对象表示 box 所需要的参数
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>alert(sayBox(10,10));                             //20
</span><span class='line'>alert(sayBox2(10,10));                            //20
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;call()&lt;/code&gt; 方法于 &lt;code&gt;apply()&lt;/code&gt; 方法相同,他们的区别仅仅在于接收参数的方式不同 。对于 &lt;code&gt;call()&lt;/code&gt; 方 法而言,第一个参数是作用域,没有变化,变化只是其余的参数都是直接传递给函数的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;待续&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[JavaScript 之 对象和数组]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-10-20T22:19:20+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://amy-liu.github.io/blog/2015/10/20/javascript-zhi-dui-xiang-he-shu-zu&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;什么是对象,其实就是一种类型,即引用类型。而对象的值就是引用类型的实例。 在 ECMAScript 中引用类型是一种数据结构,用于将数据和功能组织在一起。它也常被称做为 类,但 ECMAScript 中却没有这种东西。虽然 ECMAScript 是一门面向对象的语言,却不具 备传统面向对象语言所支持的类和接口等基本结构。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;一、Object 类型&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;到目前为止,我们使用的引用类型最多的可能就是 Object 类型了。虽然 Object 的实例
</span><span class='line'>不具备多少功能,但对于在应用程序中的存储和传输数据而言,它确实是非常理想的选择 。 创建 Object 类型有两种。一种是使用 new 运算符,一种是字面量表示法。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1.使用 new 运算符创建 Object
</span><span class='line'>&lt;code&gt;
</span><span class='line'>var box = new Object();     //new 方式    new 关键字可以省略
</span><span class='line'>box.name = 'amy';           //创建属性字段
</span><span class='line'>box.age = 28;               //创建属性字段
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2.使用字面量方式创建 Object&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {              //字面量方式
</span><span class='line'>name : '李',         //创建属性字段
</span><span class='line'>age : 28 
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;!--more--&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3.属性字段也可以使用字符串形式&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {
</span><span class='line'>'name' : '李炎恢',             //也可以用字符串形式
</span><span class='line'>'age' : 28 
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4.使用字面量及传统附值方式&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {};                     //字面量方式声明空的对象
</span><span class='line'>box.name = '李炎恢';               //点符号给属性付值
</span><span class='line'>box.age = 28;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;5.两种属性输出方式&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;alert(box.age);                   //点 表示法输出
</span><span class='line'>alert(box['age']);                //中括号表示法输出,注意引号不能省
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;6.给对象创建方法&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;var box = {
</span><span class='line'>run : function () {           //对象中的方法
</span><span class='line'>return '运行';
</span><span class='line'>} 
</span><span class='line'>}
</span><span class='line'>alert(box.run());                 //调用对象中的方法
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;7.使用 delete 删除对象属性&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;delete box.name;                 //删除属性
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在实际开发过程中,一般我们更加喜欢字面量的声明方式。因为它清晰,语法代码少 , 而且还给人一种封装的感觉。字面量也是向函数传递大量可选参数的首选方式。</span></code></pre></td></tr></table></div></figure>
    function box(obj) {                                 //参数是一个对象
        if (obj.name != undefined) alert(obj.name);     //判断属性是否存在
        if (obj.age != undefined) alert(obj.age);
    }</p>

<pre><code>box({                                    //调用函数传递一个对象
    name : '李炎恢',
    age : 28 
});
</code></pre>

<pre><code class="">
## 二、Array 类型

除了 Object 类型之外,Array 类型是 ECMAScript 最常用的类型。而且 ECMAScript 中
的 Array 类型和其他语言中的数组有着很大的区别 。虽然数组都是有序排列 ,但 ECMAScript 中的数组每个元素可以保存任何类型。 ECMAScript 中数组的大小也是可以调整的。

创建 Array 类型有两种方式:第一种是 new 运算符,第二种是字面量。

1.使用 new 关键字创建数组

    var box = new Array();                              //创建了一个数组           
    var box = new Array(10);                            //创建一个包含 10 个元素的数组
    var box = new Array('李',28,'教师','盐城');          //创建一个数组并分配好了元素   都可以省略 new 关键字


2.使用字面量方式创建数组

    var box = [];                           //创建一个空的数组
    var box = ['李',28,'教师','盐城'];       //创建包含元素的数组
    var box = [1,2,];                      //禁止这么做,IE 会识别 3 个元素   最后的逗号要删掉
    var box = [,,,,,];                     //同样,IE 的会有识别问题

3.使用索引下标来读取数组的值 

    alert(box[2]);              //获取第三个元素
    box[2] = '学生';             //修改第三个元素 
    box[4] = '计算机编程';        //增加第五个元素

4.使用 `length` 属性获取数组元素量 

    alert(box.length)               //获取元素个数
    box.length = 10;                //强制给元素个数
    box[box.length] = 'JS 技术';     //通过 length 给数组最后面增加一个元素


5.创建一个稍微复杂一点的数组 

    var box = [             

                {                                     //第一个元素是一个对象
                name : '李炎恢', age : 28,
                run : function () {
                return 'run 了'; 
                    }
                },
                ['马云','李彦宏',new Object()],        //第二个元素是数组
                '江苏',                               //第三个元素是字符串 
                25+25,                               //第四个元素是数值
                new Array(1,2,3)                     //第五个元素是数组

            ]; 

        alert(box);

PS:数组最多可包含 4294967295 个元素,超出即会发生异常。

## 三、对象中的方法

转换方法

对象或数组都具有 `toLocaleString()` `toString()`和 `valueOf()` 方法。其中 `toString()` 和 `valueOf()` 重写了谁,都会返回相同的值。数组会将每个值进行字符串形式的拼接以逗号隔开 。

    var box = ['李',28,'计算机编程'];             //字面量数组 
    alert(box);                                    //隐式调用了 toString() 
    alert(box.toString());                         //和 valueOf()返回一致
    alert(box.toLocaleString());                   //返回值和上面两种一致

默认情况下,数组字符串都会以逗号隔开。如果使用 `join()` 方法,则可以使用不同的分 隔符来构建这个字符串。

    var box = ['李', 28, '计算机编程'];
    alert(box.join('|'));                       //李炎恢|28|计算机编程

栈方法

ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法。也就是说,可以让数组像栈一样,可以限制插入和删除项的数据结构。栈是一种数据结构 (后进先出),也 就是说最新添加的元素最早被移除。而栈中元素的插入 (或叫推入)和移除(或叫弹出),只发 生在一个位置——栈的顶部。ECMAScript 为数组专门提供了 `push()`和 `pop()` 方法。

`push()` 方法可以接收任意数量的参数 ,把它们逐个添加到数组的末尾 ,并返回修改后数 组的长度。而 `pop()` 方法则从数组末尾移除最后一个元素,减少数组的 `length` 值,然后返回 移除的元素。
</code></pre>

<pre><code>var box = ['李', 28, '计算机编程'];               //字面量声明
alert(box.push(' 盐城'));                           //数组末尾添加一个元素 ,并且返回长度 
alert(box);                                        //查看数组
box.pop();                                         //移除数组末尾元素 ,并返回移除的元素 
alert(box);                                        //查看元素
</code></pre>

<pre><code>
队列方法

栈方法是后进先出 ,而列队方法就是先进先出 。列队在数组的末端添加元素 ,从数组的 前端移除元素。通过 `push()`向数组末端添加一个元素,然后通过 `shift()` 方法从数组前端移除 一个元素。
</code></pre>

<pre><code>var box = ['李', 28, '计算机编程'];                    //字面量声明
alert(box.push(' 盐城'));                             //数组末尾添加一个元素 ,并且返回长度
alert(box);
alert(box.shift());                                  //移除数组开头元素 ,并返回移除的元素 
alert(box);
</code></pre>

<pre><code>
ECMAScript 还为数组提供了一个 `unshift()` 方法,它和 `shift()` 方法的功能完全相反。 `unshift()`方法为数组的前端添加一个元素。
</code></pre>

<pre><code>var box = ['李炎恢', 28, '计算机编程'];            //字面量声明
alert(box.unshift('盐城','江苏'));                //数组开头添加两个元素
alert(box);
alert(box.pop());                                //移除数组末尾元素 ,并返回移除的元素 /
alert(box);
</code></pre>

<p>```
PS:IE 浏览器对 unshift()方法总是返回 undefined 而不是数组的新长度。</p>

<p>重排序方法</p>

<p>数组中已经存在两个可以直接用来排序的方法: <code>reverse()</code> 和 <code>sort()</code> 。</p>

<p><code>reverse()</code> 逆向排序</p>

<pre><code>var box = [1,2,3,4,5];              //数组 
alert(box.reverse());               //逆向排序方法,返回排序后的数组 
alert(box);                         //源数组也被逆向排序了,说明是引用
</code></pre>

<p>sort() 从小到大排序</p>

<pre><code>var box = [4,1,7,3,9,2];               //数组
alert(box.sort());                     //从小到大排序,返回排序后的数组 
alert(box);                             //源数组也被从小到大排序了
</code></pre>

<p>sort 方法的默认排序在数字排序上有些问题 ,因为数字排序和数字字符串排序的算法是 一样的。我们必须修改这一特征,修改的方式,就是给 sort(参数)方法传递一个函数参数。 这点可以参考手册说明。</p>

<pre><code>function compare(value1, value2) {            //数字排序的函数参数 
    if (value1 &lt; value2) {                    //小于,返回负数
            return -1;
        } else if (value1 &gt; value2) {         //大于,返回正数
        return 1; } else {
            return 0;                         //其他,返回 0
        }
        }
var box = [0,1,5,10,15];                      //验证数字字符串,和数字的区别
alert(box.sort(compare));                     //传参
</code></pre>

<p>操作方法</p>

<p>ECMAScript 为操作已经包含在数组中的元素提供了很多方法 。<code>concat()</code>方法可以基于当 前数组创建一个新数组。<code>slice()</code>方法可以基于当前数组获取指定区域元素并创建一个新数组 。 <code>splice()</code>主要用途是向数组的中部插入元素。</p>

<pre><code>var box = ['李', 28, '盐城'];                       //当前数组 
var box2 = box.concat('计算机编程');                //创建新数组,并添加新元素 
alert(box2);                                      //输出新数组 
alert(box);                                       //当前数组没有任何变化

var box = ['李', 28, '盐城'];                      //当前数组
var box2 = box.slice(1);                          //box.slice(1,3) ,2-4 之间的元素
alert(box2);                                      //28,盐城
alert(box);                                       //当前数组
</code></pre>

<p> splice 中的删除功能:</p>

<pre><code>var box = ['李', 28, '盐城'];                  //当前数组
var box2 = box.splice(0,2);                      //截取前两个元素 
alert(box2);                                     //返回截取的元素 
alert(box);                                      //当前数组被截取的元素被删除
</code></pre>

<p>splice 中的插入功能:</p>

<pre><code>var box = ['李', 28, '盐城'];
var box2 = box.splice(1,0,'计算机编程','江苏');         //没有截取,但插入了两条    
alert(box2);                                          //在第 2 个位置插入两条
alert(box);
</code></pre>

<p>splice 中的替换功能:</p>

<pre><code>var box = ['李', 28, '盐城']; 
var box2 = box.splice(1,1,100);                  //截取了第 2 条,替换成 100
alert(box2);                                     //输出截取的 28
alert(box);
</code></pre>
]]></content>
  </entry>
  
</feed>
