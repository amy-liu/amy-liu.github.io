
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>JavaScript - 匿名函数和闭包 - 云端笔记</title>
  <meta name="author" content="amy-liu">

  
  <meta name="description" content="匿名函数就是没有名字的函数,闭包是可访问一个函数作用域里变量的函数。 一、匿名函数 function () { //匿名函数 return 'Lee'; } 1
2
3
4
5
6
7 function box () { //函数里的匿名函数 return function () { // &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://amy-liu.github.io/blog/2015/11/02/javascript-ni-ming-han-shu-he-bi-bao/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="云端笔记" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts 
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">云端笔记</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="amy-liu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/"> Blog </a></li>
  <li><a href="/blog/archives"> Archives </a></li>
  <!--<li><a href="/blog/categories/sui-bi/">随笔</a></li>-->
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">JavaScript - 匿名函数和闭包</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-02T22:28:19+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:28 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>匿名函数就是没有名字的函数,闭包是可访问一个函数作用域里变量的函数。</p>

<h3>一、匿名函数</h3>

<pre><code>function () {                 //匿名函数
    return 'Lee'; 
}
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  function box () {                    //函数里的匿名函数 
</span><span class='line'>      return function () {            //函数里的匿名函数,产生闭包
</span><span class='line'>          return 'Lee';
</span><span class='line'>      } 
</span><span class='line'>  }
</span><span class='line'>  alert(box()());                   //调用匿名函数</span></code></pre></td></tr></table></div></figure>


<h2>二、闭包</h2>

<p>闭包是指有权访问另一个函数作用域中的变量的函数 ,创建闭包的常见的方式,就是在一个函数内部创建另一个函数,通过另一个函数访问这个函数的局部变量。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box() {
</span><span class='line'>  var user = 'Lee'; 
</span><span class='line'>  return function () {           //通过匿名函数返回 box()局部变量
</span><span class='line'>      return user; 
</span><span class='line'>      };
</span><span class='line'>  } 
</span><span class='line'>alert(box()());                   //通过 box()()来直接调用匿名函数返回值
</span><span class='line'>var b = box();                    //另一种调用匿名函数返回值
</span><span class='line'>alert(b());</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>使用闭包有一个优点 ,也是它的缺点 :就是可以把局部变量驻留在内存中 ,可以避免使 用全局变量。 (全局变量污染导致应用程序不可预测性,每个模块都可调用必将引来灾难, 所以推荐使用私有的,封装的局部变量 )。</p>

<p>//通过全局变量来累加</p>

<pre><code>var age = 100;                   //全局变量 
function box() {
    age ++;                     //模块级可以调用全局变量,进行累加
}
box();                          //执行函数,累加了
alert(age);                     //输出全局变量
</code></pre>

<p>//通过局部变量无法实现累加</p>

<pre><code>function box() {
    var age = 100;              
    age ++;                   //累加
    return age;
}
alert(box());                 //101
alert(box());                 //101,无法实现,因为又被初始化了
</code></pre>

<p>//通过闭包可以实现局部变量的累加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box() {
</span><span class='line'>  var age = 100; 
</span><span class='line'>  return function () {
</span><span class='line'>      age ++; 
</span><span class='line'>      return age;
</span><span class='line'>      } 
</span><span class='line'>  }
</span><span class='line'>  var b = box();             //获得函数
</span><span class='line'>  alert(b());                //调用匿名函数 
</span><span class='line'>  alert(b());                //第二次调用匿名函数,实现累加</span></code></pre></td></tr></table></div></figure>


<p>PS:由于闭包里作用域返回的局部变量资源不会被立刻销毁回收,所以可能会占用更 多的内存。过度使用闭包会导致性能下降,建议在非常有必要的时候才使用闭包。</p>

<p>作用域链的机制导致一个问题,在循环中里的匿名函数取得的任何变量都是最后一个 值。</p>

<p>//循环里包含匿名函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box() {
</span><span class='line'>  var arr = [];
</span><span class='line'>  for (var i = 0; i &lt; 5; i++) { 
</span><span class='line'>  arr[i] = function () {
</span><span class='line'>  return i; 
</span><span class='line'>  };
</span><span class='line'>}
</span><span class='line'>return arr;                    
</span><span class='line'>}
</span><span class='line'>var b = box();              //得到函数数组 
</span><span class='line'>alert(b.length);            //得到函数集合长度
</span><span class='line'>
</span><span class='line'>for (var i = 0; i &lt; b.length; i++) {
</span><span class='line'>  alert(b[i]());                            //输出每个函数的值,都是最后一个值
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的例子输出的结果都是 5,也就是循环后得到的最大的 i 值。因为 <code>b[i]</code> 调用的是匿 名函数,匿名函数并没有自我执行,等到调用的时候, <code>box()</code>已执行完毕,i 早已变成 5,所 以最终的结果就是 5 个 5。</p>

<p>//循环里包含匿名函数-改  1,自我执行匿名函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function box() {
</span><span class='line'>  var arr = [];
</span><span class='line'>  for (var i = 0; i &lt; 5; i++) { 
</span><span class='line'>      arr[i] = (function (num) {          //自我执行 
</span><span class='line'>          return num; 
</span><span class='line'>          })(i);                          //并且传参
</span><span class='line'>}
</span><span class='line'>return arr;
</span><span class='line'>}
</span><span class='line'>var b = box();
</span><span class='line'>for (var i = 0; i &lt; b.length; i++) {
</span><span class='line'>  alert(b[i]); //这里返回的是数组,直接打印即可 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>改1中,我们让匿名函数进行自我执行,导致最终返回给 a[i]的是数组而不是函数了。 最终导致 b[0]-b[4]中保留了 0,1,2,3,4 的值。</p>

<p>关于 this 对象  <br/>
在闭包中使用 <code>this</code> 对象也可能会导致一些问题 ,<code>this</code> 对象是在运行时基于函数的执行环 境绑定的,如果 this 在全局范围就是 window,如果在对象内部就指向这个对象。而闭包却 在运行时指向 window 的,因为闭包并不属于这个对象的属性或方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var user = 'The Window';
</span><span class='line'>var obj = {
</span><span class='line'>  user : 'The Object',
</span><span class='line'>  getUserFunction : function () { 
</span><span class='line'>      return function () {               //闭包不属于 obj,里面的 this 指向 window
</span><span class='line'>      return this.user;
</span><span class='line'>      }; 
</span><span class='line'>      }
</span><span class='line'>}; 
</span><span class='line'>alert(obj.getUserFunction()());            //The window
</span><span class='line'>
</span><span class='line'>alert(obj.getUserFunction().call(obj));    //可以强制指向某个对象
</span><span class='line'>
</span><span class='line'>getUserFunction : function () {           //也可以从上一个作用域中得到对象
</span><span class='line'>  var that = this;                     /从对象的方法里得对象
</span><span class='line'>  return function () {
</span><span class='line'>  return that.user; };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>内存泄漏</h3>

<p>由于 IE 的 JScript 对象和 DOM 对象使用不同的垃圾收集方式 ,因此闭包在 IE 中会导致 一些问题。就是内存泄漏的问题 ,也就是无法销毁驻留在内存中的元素 。</p>

<pre><code>function box() {
    var oDiv = document.getElementById('oDiv');             //oDiv 用完之后一直驻留在内存 
    oDiv.onclick = function () {
    alert(oDiv.innerHTML);                                 //这里用 oDiv 导致内存泄漏

}; }
box();
</code></pre>

<p>那么在最后应该将 oDiv 解除引用来避免内存泄漏。</p>

<pre><code>function box() {
    var oDiv = document.getElementById('oDiv'); 
    var text = oDiv.innerHTML;
    oDiv.onclick = function () {
        alert(text); 
        };
    oDiv = null;          //解除引用
    }
</code></pre>

<p>PS:如果并没有使用解除引用,那么需要等到浏览器关闭才得以释放。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">amy-liu</span></span>

      




<time class='entry-date' datetime='2015-11-02T22:28:19+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:28 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/javascript/'>javascript</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/10/28/jaxiang-dui-xiang-yu-yuan-xing/" title="Previous Post: JavaScript 之 面向对象与原型">&laquo; JavaScript 之 面向对象与原型</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/11/02/javascript-json/" title="Next Post: JavaScript - JSON ">JavaScript - JSON  &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>文章分类</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/css'>css (7)</a></li>
<li class='category'><a href='/blog/categories/css3'>css3 (2)</a></li>
<li class='category'><a href='/blog/categories/javascript'>javascript (12)</a></li>
<li class='category'><a href='/blog/categories/jquery'>jquery (9)</a></li>
<li class='category'><a href='/blog/categories/yong-octopressjian-bo'>用octopress建博 (1)</a></li>

  </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/02/javascript-ajax/">JavaScript - Ajax</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/02/javascript-json/">JavaScript - JSON</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/02/javascript-ni-ming-han-shu-he-bi-bao/">JavaScript - 匿名函数和闭包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/28/jaxiang-dui-xiang-yu-yuan-xing/">JavaScript 之 面向对象与原型</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/28/javascript-zhi-ji-ben-bao-zhuang-lei-xing/">JavaScript 之 基本包装类型</a>
      </li>
    
  </ul>
</section>





  
</aside>




    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - amy-liu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
